{"version":3,"sources":["TreeNode.js"],"names":["isNode","obj","Node","Object","keys","forEach","key","type","children","child","push","array","Array","isArray","every","element","add","length","ret","clone","use","i","concat","toArray","undefined","node","rootExtra","startIndex","root","stack","current","pop"],"mappings":"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","sourcesContent":["/**\n * TreeNode.js - build, construct, and deconstruct a tree\n *\n * @license\n * Copyright Â© 2019, 2021 JEDLSoft\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction isNode(obj) {\n    return typeof(obj) === \"object\" && obj instanceof Node;\n}\n\n/**\n * @class Node\n * @param {Object} an object to make into a tree node\n */\nexport default class Node {\n    /**\n     * Create a new node instance.\n     */\n    constructor(obj) {\n        if (obj) {\n            // shallow copy all properties into this node\n            Object.keys(obj).forEach(key => {\n                if (key !== \"children\" && typeof(obj[key]) !== 'undefined') {\n                    this[key] = obj[key];\n                }\n            });\n        } else {\n            this.type = \"text\";\n        }\n        this.children = [];\n    }\n\n    /**\n     * Add a child node to the current context of the tree.\n     * @param {Node} child the child to add\n     */\n    add(child) {\n        if (!isNode(child)) {\n            return;\n        }\n\n        this.children.push(child);\n    }\n\n    addChildren(array) {\n        if (!Array.isArray(array) || !array.every(element => (element instanceof Node))) {\n            return;\n        }\n        array.forEach(element => this.add(element));\n    }\n\n    /**\n     * Flatten the current node and all of its descendents into an\n     * array and return it. When a node has children, it is\n     * flattened into two nodes: a start node, followed by nodes for\n     * all its children, and an end node. The start and end nodes\n     * are marked by a \"use\" property set to \"start\" and \"end\".\n     *\n     * @returns {Array.<Node>} an array of Nodes flattened from\n     * the current node\n     */\n    toArray() {\n        if (this.children.length) {\n            var ret = [];\n\n            var clone = new Node(this);\n            clone.use = \"start\";\n            ret.push(clone);\n\n            for (var i = 0; i < this.children.length; i++) {\n                ret = ret.concat(this.children[i].toArray());\n            }\n\n            clone = new Node(this);\n            clone.use = \"end\";\n            ret.push(clone);\n\n            return ret;\n        } else if (this.type === \"text\") {\n            this.use = undefined;\n            return [this];\n        } else {\n            // self closing component\n            var clone = new Node(this);\n            clone.use = \"startend\";\n            return [clone];\n        }\n    }\n\n    /**\n     * Recreate a full tree again from a flattened array of Node\n     * instances. If the instances are well-formed (that is,\n     * all start nodes are matched with end nodes with strict\n     * nesting), then the tree is valid. If the array is not\n     * well-formed, then the shape of the resulting tree will\n     * probably not be valid and the results of this static method\n     * are not defined.\n     *\n     * @static\n     * @param {Array.<Node>} array the array of Node instances\n     * to reconstruct into a tree\n     * @returns {Node} a node that is the root of a tree\n     * reconstructed from the array of Nodes\n     */\n    static fromArray(array) {\n        if (!array || !Array.isArray(array) || !array.length) {\n            return undefined;\n        }\n\n        if (!array.every(node => typeof node === \"object\")) {\n            return undefined;\n        }\n\n        var clone;\n        if (array.length === 1) {\n            if (isNode(array[0])) {\n                clone = new Node(array[0]);\n                clone.use = undefined;\n            }\n            return clone;\n        }\n\n        let rootExtra, startIndex = 0;\n        if (array[0].use === \"start\") {\n            rootExtra = array[0];\n            startIndex = 1;\n        } else {\n            rootExtra = {type: \"root\"};\n            startIndex = 0;\n        }\n        // not a tree? Make a wrapper node!\n        let root = new Node(rootExtra);\n        let stack = [];\n        let current = root;\n\n        root.use = undefined;\n        stack.push(root);\n\n        for (var i = startIndex; i < array.length; i++) {\n            if (isNode(array[i])) {\n                if (array[i].use === \"start\") {\n                    clone = new Node(array[i]);\n                    clone.use = undefined;\n                    stack.push(clone);\n                    current.add(clone);\n                    current = clone;\n                } else if (array[i].use === \"end\") {\n                    if (stack.length > 1) {\n                        stack.pop();\n                        current = stack[stack.length-1];\n                    }\n                } else {\n                    current.add(array[i]);\n                }\n            }\n        }\n\n        return root;\n    }\n}\n"],"file":"TreeNode-es5.js"}