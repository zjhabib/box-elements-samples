{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\n/**\n * \n * @file Helper for the Box metadata related API\n * @author Box\n */\nimport getProp from 'lodash/get';\nimport uniqueId from 'lodash/uniqueId';\nimport { getBadItemError, getBadPermissionsError, isUserCorrectableError } from '../utils/error';\nimport { getTypedFileId } from '../utils/file';\nimport File from './File';\nimport { HEADER_CONTENT_TYPE, METADATA_SCOPE_ENTERPRISE, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_FETCH_LIMIT, METADATA_TEMPLATE_PROPERTIES, METADATA_TEMPLATE_CLASSIFICATION, METADATA_TEMPLATE_SKILLS, FIELD_METADATA_SKILLS, CACHE_PREFIX_METADATA, ERROR_CODE_UPDATE_SKILLS, ERROR_CODE_UPDATE_METADATA, ERROR_CODE_CREATE_METADATA, ERROR_CODE_DELETE_METADATA, ERROR_CODE_FETCH_METADATA, ERROR_CODE_FETCH_METADATA_TEMPLATES, ERROR_CODE_FETCH_SKILLS } from '../constants';\nvar Metadata = /*#__PURE__*/\nfunction (_File) {\n  _inherits(Metadata, _File);\n  function Metadata() {\n    _classCallCheck(this, Metadata);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Metadata).apply(this, arguments));\n  }\n  _createClass(Metadata, [{\n    key: \"getMetadataCacheKey\",\n    /**\n     * Creates a key for the metadata cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    value: function getMetadataCacheKey(id) {\n      return \"\".concat(CACHE_PREFIX_METADATA).concat(id);\n    }\n    /**\n     * Creates a key for the skills cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n  }, {\n    key: \"getSkillsCacheKey\",\n    value: function getSkillsCacheKey(id) {\n      return \"\".concat(this.getMetadataCacheKey(id), \"_skills\");\n    }\n    /**\n     * Creates a key for the classification cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n  }, {\n    key: \"getClassificationCacheKey\",\n    value: function getClassificationCacheKey(id) {\n      return \"\".concat(this.getMetadataCacheKey(id), \"_classification\");\n    }\n    /**\n     * API URL for metadata\n     *\n     * @param {string} id - a Box file id\n     * @param {string} field - metadata field\n     * @return {string} base url for files\n     */\n  }, {\n    key: \"getMetadataUrl\",\n    value: function getMetadataUrl(id, scope, template) {\n      var baseUrl = \"\".concat(this.getUrl(id), \"/metadata\");\n      if (scope && template) {\n        return \"\".concat(baseUrl, \"/\").concat(scope, \"/\").concat(template);\n      }\n      return baseUrl;\n    }\n    /**\n     * API URL for metadata templates for a scope\n     *\n     * @param {string} scope - metadata scope\n     * @return {string} base url for files\n     */\n  }, {\n    key: \"getMetadataTemplateUrl\",\n    value: function getMetadataTemplateUrl() {\n      return \"\".concat(this.getBaseApiUrl(), \"/metadata_templates\");\n    }\n    /**\n     * API URL for metadata template for an instance\n     *\n     * @param {string} id - metadata instance id\n     * @return {string} base url for files\n     */\n  }, {\n    key: \"getMetadataTemplateUrlForInstance\",\n    value: function getMetadataTemplateUrlForInstance(id) {\n      return \"\".concat(this.getMetadataTemplateUrl(), \"?metadata_instance_id=\").concat(id);\n    }\n    /**\n     * API URL for getting metadata template schema by template key\n     *\n     * @param {string} templateKey - metadata template key\n     * @return {string} API url for getting template schema by template key\n     */\n  }, {\n    key: \"getMetadataTemplateSchemaUrl\",\n    value: function getMetadataTemplateSchemaUrl(templateKey) {\n      return \"\".concat(this.getMetadataTemplateUrl(), \"/enterprise/\").concat(templateKey, \"/schema\");\n    }\n    /**\n     * API URL for metadata templates\n     *\n     * @param {string} scope - metadata scope or id\n     * @return {string} base url for files\n     */\n  }, {\n    key: \"getMetadataTemplateUrlForScope\",\n    value: function getMetadataTemplateUrlForScope(scope) {\n      return \"\".concat(this.getMetadataTemplateUrl(), \"/\").concat(scope);\n    }\n    /**\n     * Returns the custom properties template\n     *\n     * @return {Object} temaplte for custom properties\n     */\n  }, {\n    key: \"getCustomPropertiesTemplate\",\n    value: function getCustomPropertiesTemplate() {\n      return {\n        id: uniqueId('metadata_template_'),\n        scope: METADATA_SCOPE_GLOBAL,\n        templateKey: METADATA_TEMPLATE_PROPERTIES,\n        hidden: false\n      };\n    }\n    /**\n     * Utility to create editors from metadata instances\n     * and metadata templates.\n     *\n     * @param {Object} instance - metadata instance\n     * @param {Object} template - metadata template\n     * @param {boolean} canEdit - is instance editable\n     * @return {Object} metadata editor\n     */\n  }, {\n    key: \"createEditor\",\n    value: function createEditor(instance, template, canEdit) {\n      var data = {};\n      Object.keys(instance).forEach(function (key) {\n        if (!key.startsWith('$')) {\n          // $FlowFixMe\n          data[key] = instance[key];\n        }\n      });\n      return {\n        template: template,\n        instance: {\n          id: instance.$id,\n          canEdit: instance.$canEdit && canEdit,\n          data: data\n        }\n      };\n    }\n    /**\n     * Gets metadata templates for enterprise\n     *\n     * @param {string} id - file id\n     * @param {string} scope - metadata scope\n     * @param {string|void} [instanceId] - metadata instance id\n     * @return {Object} array of metadata templates\n     */\n  }, {\n    key: \"getTemplates\",\n    value: function () {\n      var _getTemplates = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(id, scope, instanceId) {\n        var templates, url, status;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.errorCode = ERROR_CODE_FETCH_METADATA_TEMPLATES;\n                templates = {};\n                url = instanceId ? this.getMetadataTemplateUrlForInstance(instanceId) : this.getMetadataTemplateUrlForScope(scope);\n                _context.prev = 3;\n                _context.next = 6;\n                return this.xhr.get({\n                  url: url,\n                  id: getTypedFileId(id),\n                  params: {\n                    limit: METADATA_TEMPLATE_FETCH_LIMIT // internal hard limit is 500\n                  }\n                });\n\n              case 6:\n                templates = _context.sent;\n                _context.next = 14;\n                break;\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](3);\n                status = _context.t0.status;\n                if (!isUserCorrectableError(status)) {\n                  _context.next = 14;\n                  break;\n                }\n                throw _context.t0;\n              case 14:\n                return _context.abrupt(\"return\", getProp(templates, 'data.entries', []));\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 9]]);\n      }));\n      function getTemplates(_x, _x2, _x3) {\n        return _getTemplates.apply(this, arguments);\n      }\n      return getTemplates;\n    }()\n    /**\n     * Gets metadata template schema by template key\n     *\n     * @param {string} templateKey - template key\n     * @return {Promise} Promise object of metadata template\n     */\n  }, {\n    key: \"getSchemaByTemplateKey\",\n    value: function getSchemaByTemplateKey(templateKey) {\n      var url = this.getMetadataTemplateSchemaUrl(templateKey);\n      return this.xhr.get({\n        url: url\n      });\n    }\n    /**\n     * Gets metadata instances for a Box file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n  }, {\n    key: \"getInstances\",\n    value: function () {\n      var _getInstances = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(id) {\n        var instances, status;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.errorCode = ERROR_CODE_FETCH_METADATA;\n                instances = {};\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this.xhr.get({\n                  url: this.getMetadataUrl(id),\n                  id: getTypedFileId(id)\n                });\n              case 5:\n                instances = _context2.sent;\n                _context2.next = 13;\n                break;\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](2);\n                status = _context2.t0.status;\n                if (!isUserCorrectableError(status)) {\n                  _context2.next = 13;\n                  break;\n                }\n                throw _context2.t0;\n              case 13:\n                return _context2.abrupt(\"return\", getProp(instances, 'data.entries', []));\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 8]]);\n      }));\n      function getInstances(_x4) {\n        return _getInstances.apply(this, arguments);\n      }\n      return getInstances;\n    }()\n    /**\n     * Returns a list of templates that can be added by the user.\n     * For collabed files, only custom properties is allowed.\n     *\n     * @return {Object} template for custom properties\n     */\n  }, {\n    key: \"getUserAddableTemplates\",\n    value: function getUserAddableTemplates(customPropertiesTemplate, enterpriseTemplates, hasMetadataFeature, isExternallyOwned) {\n      var userAddableTemplates = [];\n      if (hasMetadataFeature) {\n        userAddableTemplates = isExternallyOwned ? [customPropertiesTemplate] : [customPropertiesTemplate].concat(enterpriseTemplates);\n      } // Only templates that are not hidden and not classification\n\n      return userAddableTemplates.filter(function (template) {\n        return !template.hidden && template.templateKey !== METADATA_TEMPLATE_CLASSIFICATION;\n      });\n    }\n    /**\n     * Extracts classification for different representation in the UI.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @return {Array} metadata instances without classification\n     */\n  }, {\n    key: \"extractClassification\",\n    value: function extractClassification(id, instances) {\n      var classification = instances.find(function (instance) {\n        return instance.$template === METADATA_TEMPLATE_CLASSIFICATION;\n      });\n      if (classification) {\n        instances.splice(instances.indexOf(classification), 1);\n        var cache = this.getCache();\n        var key = this.getClassificationCacheKey(id);\n        cache.set(key, classification);\n      }\n      return instances;\n    }\n    /**\n     * Finds template for a given metadata instance.\n     *\n     * @param {string} id - Box file id\n     * @param {Object} instance - metadata instance\n     * @param {Array} templates - metadata templates\n     * @return {Object|undefined} template for metadata instance\n     */\n  }, {\n    key: \"getTemplateForInstance\",\n    value: function () {\n      var _getTemplateForInstance = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(id, instance, templates) {\n        var instanceId, templateKey, scope, template, crossEnterpriseTemplate;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                instanceId = instance.$id;\n                templateKey = instance.$template;\n                scope = instance.$scope;\n                template = templates.find(function (t) {\n                  return t.templateKey === templateKey && t.scope === scope;\n                }); // Enterprise scopes are always enterprise_XXXXX\n\n                if (!(!template && scope.startsWith(METADATA_SCOPE_ENTERPRISE))) {\n                  _context3.next = 9;\n                  break;\n                }\n                _context3.next = 7;\n                return this.getTemplates(id, scope, instanceId);\n              case 7:\n                crossEnterpriseTemplate = _context3.sent;\n                // The API always returns an array of at most one item\n                template = crossEnterpriseTemplate[0];\n              // eslint-disable-line\n\n              case 9:\n                return _context3.abrupt(\"return\", template);\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function getTemplateForInstance(_x5, _x6, _x7) {\n        return _getTemplateForInstance.apply(this, arguments);\n      }\n      return getTemplateForInstance;\n    }()\n    /**\n     * Creates and returns metadata editors.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @param {Object} customPropertiesTemplate - custom properties template\n     * @param {Array} enterpriseTemplates - enterprise templates\n     * @param {Array} globalTemplates - global templates\n     * @param {boolean} canEdit - metadata editability\n     * @return {Array} metadata editors\n     */\n  }, {\n    key: \"getEditors\",\n    value: function () {\n      var _getEditors = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(id, instances, customPropertiesTemplate, enterpriseTemplates, globalTemplates, canEdit) {\n        var _this = this;\n        var templates, filteredInstances, editors;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                // All usable templates for metadata instances\n                templates = [customPropertiesTemplate].concat(enterpriseTemplates, globalTemplates); // Filter out skills and classification\n                // let filteredInstances = this.extractSkills(id, instances);\n\n                filteredInstances = this.extractClassification(id, instances); // Create editors from each instance\n\n                editors = [];\n                _context5.next = 5;\n                return Promise.all(filteredInstances.map( /*#__PURE__*/\n                function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee4(instance) {\n                    var template;\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.next = 2;\n                            return _this.getTemplateForInstance(id, instance, templates);\n                          case 2:\n                            template = _context4.sent;\n                            if (template) {\n                              editors.push(_this.createEditor(instance, template, canEdit));\n                            }\n                          case 4:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n                  return function (_x14) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n              case 5:\n                return _context5.abrupt(\"return\", editors);\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n      function getEditors(_x8, _x9, _x10, _x11, _x12, _x13) {\n        return _getEditors.apply(this, arguments);\n      }\n      return getEditors;\n    }()\n    /**\n     * API for getting metadata editors\n     *\n     * @param {string} fileId - Box file id\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param {boolean} hasMetadataFeature - metadata feature check\n     * @param {Object} options - fetch options\n     * @return {Promise}\n     */\n  }, {\n    key: \"getMetadata\",\n    value: function () {\n      var _getMetadata = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(file, successCallback, errorCallback, hasMetadataFeature) {\n        var options,\n          id,\n          permissions,\n          is_externally_owned,\n          cache,\n          key,\n          customPropertiesTemplate,\n          _ref2,\n          _ref3,\n          instances,\n          globalTemplates,\n          enterpriseTemplates,\n          editors,\n          metadata,\n          _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                options = _args6.length > 4 && _args6[4] !== undefined ? _args6[4] : {};\n                id = file.id, permissions = file.permissions, is_externally_owned = file.is_externally_owned;\n                this.errorCode = ERROR_CODE_FETCH_METADATA;\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback; // Check for valid file object.\n                // Need to eventually check for upload permission.\n\n                if (!(!id || !permissions)) {\n                  _context6.next = 8;\n                  break;\n                }\n                this.errorHandler(getBadItemError());\n                return _context6.abrupt(\"return\");\n              case 8:\n                cache = this.getCache();\n                key = this.getMetadataCacheKey(id); // Clear the cache if needed\n\n                if (options.forceFetch) {\n                  cache.unset(key);\n                } // Return the cached value if it exists\n\n                if (!cache.has(key)) {\n                  _context6.next = 15;\n                  break;\n                }\n                this.successHandler(cache.get(key));\n                if (options.refreshCache) {\n                  _context6.next = 15;\n                  break;\n                }\n                return _context6.abrupt(\"return\");\n              case 15:\n                _context6.prev = 15;\n                customPropertiesTemplate = this.getCustomPropertiesTemplate();\n                _context6.next = 19;\n                return Promise.all([this.getInstances(id), this.getTemplates(id, METADATA_SCOPE_GLOBAL), hasMetadataFeature ? this.getTemplates(id, METADATA_SCOPE_ENTERPRISE) : Promise.resolve([])]);\n              case 19:\n                _ref2 = _context6.sent;\n                _ref3 = _slicedToArray(_ref2, 3);\n                instances = _ref3[0];\n                globalTemplates = _ref3[1];\n                enterpriseTemplates = _ref3[2];\n                _context6.next = 26;\n                return this.getEditors(id, instances, customPropertiesTemplate, enterpriseTemplates, globalTemplates, !!permissions.can_upload);\n              case 26:\n                editors = _context6.sent;\n                metadata = {\n                  editors: editors,\n                  templates: this.getUserAddableTemplates(customPropertiesTemplate, enterpriseTemplates, hasMetadataFeature, is_externally_owned)\n                };\n                cache.set(key, metadata);\n                if (!this.isDestroyed()) {\n                  this.successHandler(metadata);\n                }\n                _context6.next = 35;\n                break;\n              case 32:\n                _context6.prev = 32;\n                _context6.t0 = _context6[\"catch\"](15);\n                this.errorHandler(_context6.t0);\n              case 35:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[15, 32]]);\n      }));\n      function getMetadata(_x15, _x16, _x17, _x18) {\n        return _getMetadata.apply(this, arguments);\n      }\n      return getMetadata;\n    }()\n    /**\n     * Gets skills for file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n  }, {\n    key: \"getSkills\",\n    value: function () {\n      var _getSkills = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(file, successCallback, errorCallback) {\n        var forceFetch,\n          id,\n          cache,\n          key,\n          skills,\n          cards,\n          _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                forceFetch = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : false;\n                this.errorCode = ERROR_CODE_FETCH_SKILLS;\n                id = file.id;\n                if (id) {\n                  _context7.next = 6;\n                  break;\n                }\n                errorCallback(getBadItemError(), this.errorCode);\n                return _context7.abrupt(\"return\");\n              case 6:\n                cache = this.getCache();\n                key = this.getSkillsCacheKey(id);\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback; // Clear the cache if needed\n\n                if (forceFetch) {\n                  cache.unset(key);\n                } // Return the Cache value if it exists\n\n                if (!cache.has(key)) {\n                  _context7.next = 14;\n                  break;\n                }\n                this.successHandler(cache.get(key));\n                return _context7.abrupt(\"return\");\n              case 14:\n                // The file object may already have skills in it\n                skills = {\n                  data: getProp(file, FIELD_METADATA_SKILLS)\n                };\n                _context7.prev = 15;\n                if (skills.data) {\n                  _context7.next = 20;\n                  break;\n                }\n                _context7.next = 19;\n                return this.xhr.get({\n                  url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                  id: getTypedFileId(id)\n                });\n              case 19:\n                skills = _context7.sent;\n              case 20:\n                if (!this.isDestroyed()) {\n                  cards = skills.data.cards || [];\n                  cache.set(key, cards);\n                  this.successHandler(cards);\n                }\n                _context7.next = 26;\n                break;\n              case 23:\n                _context7.prev = 23;\n                _context7.t0 = _context7[\"catch\"](15);\n                this.errorHandler(_context7.t0);\n              case 26:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[15, 23]]);\n      }));\n      function getSkills(_x19, _x20, _x21) {\n        return _getSkills.apply(this, arguments);\n      }\n      return getSkills;\n    }()\n    /**\n     * API for patching skills on a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} field - Metadata field to patch\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n  }, {\n    key: \"updateSkills\",\n    value: function () {\n      var _updateSkills = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(file, operations, successCallback, errorCallback) {\n        var id, permissions, metadata, cards;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                this.errorCode = ERROR_CODE_UPDATE_SKILLS;\n                id = file.id, permissions = file.permissions;\n                if (!(!id || !permissions)) {\n                  _context8.next = 5;\n                  break;\n                }\n                errorCallback(getBadItemError(), this.errorCode);\n                return _context8.abrupt(\"return\");\n              case 5:\n                if (permissions.can_upload) {\n                  _context8.next = 8;\n                  break;\n                }\n                errorCallback(getBadPermissionsError(), this.errorCode);\n                return _context8.abrupt(\"return\");\n              case 8:\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback;\n                _context8.prev = 10;\n                _context8.next = 13;\n                return this.xhr.put({\n                  url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                  headers: _defineProperty({}, HEADER_CONTENT_TYPE, 'application/json-patch+json'),\n                  id: getTypedFileId(id),\n                  data: operations\n                });\n              case 13:\n                metadata = _context8.sent;\n                if (!this.isDestroyed()) {\n                  cards = metadata.data.cards || [];\n                  this.merge(this.getCacheKey(id), FIELD_METADATA_SKILLS, metadata.data);\n                  this.getCache().set(this.getSkillsCacheKey(id), cards);\n                  this.successHandler(cards);\n                }\n                _context8.next = 20;\n                break;\n              case 17:\n                _context8.prev = 17;\n                _context8.t0 = _context8[\"catch\"](10);\n                this.errorHandler(_context8.t0);\n              case 20:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[10, 17]]);\n      }));\n      function updateSkills(_x22, _x23, _x24, _x25) {\n        return _updateSkills.apply(this, arguments);\n      }\n      return updateSkills;\n    }()\n    /**\n     * API for patching metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n  }, {\n    key: \"updateMetadata\",\n    value: function () {\n      var _updateMetadata = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9(file, template, operations, successCallback, errorCallback) {\n        var id, permissions, canEdit, metadata, cache, key, cachedMetadata, editor;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this.errorCode = ERROR_CODE_UPDATE_METADATA;\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback;\n                id = file.id, permissions = file.permissions;\n                if (!(!id || !permissions)) {\n                  _context9.next = 7;\n                  break;\n                }\n                this.errorHandler(getBadItemError());\n                return _context9.abrupt(\"return\");\n              case 7:\n                canEdit = !!permissions.can_upload;\n                if (canEdit) {\n                  _context9.next = 11;\n                  break;\n                }\n                this.errorHandler(getBadPermissionsError());\n                return _context9.abrupt(\"return\");\n              case 11:\n                _context9.prev = 11;\n                _context9.next = 14;\n                return this.xhr.put({\n                  url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                  headers: _defineProperty({}, HEADER_CONTENT_TYPE, 'application/json-patch+json'),\n                  id: getTypedFileId(id),\n                  data: operations\n                });\n              case 14:\n                metadata = _context9.sent;\n                if (!this.isDestroyed()) {\n                  cache = this.getCache();\n                  key = this.getMetadataCacheKey(id);\n                  cachedMetadata = cache.get(key);\n                  editor = this.createEditor(metadata.data, template, canEdit);\n                  if (cachedMetadata && cachedMetadata.editors) {\n                    cachedMetadata.editors.splice(cachedMetadata.editors.findIndex(function (_ref4) {\n                      var instance = _ref4.instance;\n                      return instance.id === editor.instance.id;\n                    }), 1, editor);\n                  }\n                  this.successHandler(editor);\n                }\n                _context9.next = 21;\n                break;\n              case 18:\n                _context9.prev = 18;\n                _context9.t0 = _context9[\"catch\"](11);\n                this.errorHandler(_context9.t0);\n              case 21:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[11, 18]]);\n      }));\n      function updateMetadata(_x26, _x27, _x28, _x29, _x30) {\n        return _updateMetadata.apply(this, arguments);\n      }\n      return updateMetadata;\n    }()\n    /**\n     * API for creating metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n  }, {\n    key: \"createMetadata\",\n    value: function () {\n      var _createMetadata = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(file, template, successCallback, errorCallback) {\n        var id, permissions, is_externally_owned, canEdit, isProperties, metadata, cache, key, cachedMetadata, editor;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this.errorCode = ERROR_CODE_CREATE_METADATA;\n                if (!(!file || !template)) {\n                  _context10.next = 4;\n                  break;\n                }\n                errorCallback(getBadItemError(), this.errorCode);\n                return _context10.abrupt(\"return\");\n              case 4:\n                id = file.id, permissions = file.permissions, is_externally_owned = file.is_externally_owned;\n                if (!(!id || !permissions)) {\n                  _context10.next = 8;\n                  break;\n                }\n                errorCallback(getBadItemError(), this.errorCode);\n                return _context10.abrupt(\"return\");\n              case 8:\n                canEdit = !!permissions.can_upload;\n                isProperties = template.templateKey === METADATA_TEMPLATE_PROPERTIES && template.scope === METADATA_SCOPE_GLOBAL;\n                if (!(!canEdit || is_externally_owned && !isProperties)) {\n                  _context10.next = 13;\n                  break;\n                }\n                errorCallback(getBadPermissionsError(), this.errorCode);\n                return _context10.abrupt(\"return\");\n              case 13:\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback;\n                _context10.prev = 15;\n                _context10.next = 18;\n                return this.xhr.post({\n                  url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                  id: getTypedFileId(id),\n                  data: {}\n                });\n              case 18:\n                metadata = _context10.sent;\n                if (!this.isDestroyed()) {\n                  cache = this.getCache();\n                  key = this.getMetadataCacheKey(id);\n                  cachedMetadata = cache.get(key);\n                  editor = this.createEditor(metadata.data, template, canEdit);\n                  cachedMetadata.editors.push(editor);\n                  this.successHandler(editor);\n                }\n                _context10.next = 25;\n                break;\n              case 22:\n                _context10.prev = 22;\n                _context10.t0 = _context10[\"catch\"](15);\n                this.errorHandler(_context10.t0);\n              case 25:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[15, 22]]);\n      }));\n      function createMetadata(_x31, _x32, _x33, _x34) {\n        return _createMetadata.apply(this, arguments);\n      }\n      return createMetadata;\n    }()\n    /**\n     * API for deleting metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} scope - Metadata instance scope\n     * @param {string} template - Metadata template key\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n  }, {\n    key: \"deleteMetadata\",\n    value: function () {\n      var _deleteMetadata = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(file, template, successCallback, errorCallback) {\n        var scope, templateKey, id, permissions, cache, key, metadata;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                this.errorCode = ERROR_CODE_DELETE_METADATA;\n                if (!(!file || !template)) {\n                  _context11.next = 4;\n                  break;\n                }\n                errorCallback(getBadItemError(), this.errorCode);\n                return _context11.abrupt(\"return\");\n              case 4:\n                scope = template.scope, templateKey = template.templateKey;\n                id = file.id, permissions = file.permissions;\n                if (!(!id || !permissions)) {\n                  _context11.next = 9;\n                  break;\n                }\n                errorCallback(getBadItemError(), this.errorCode);\n                return _context11.abrupt(\"return\");\n              case 9:\n                if (permissions.can_upload) {\n                  _context11.next = 12;\n                  break;\n                }\n                errorCallback(getBadPermissionsError(), this.errorCode);\n                return _context11.abrupt(\"return\");\n              case 12:\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback;\n                _context11.prev = 14;\n                _context11.next = 17;\n                return this.xhr.delete({\n                  url: this.getMetadataUrl(id, scope, templateKey),\n                  id: getTypedFileId(id)\n                });\n              case 17:\n                if (!this.isDestroyed()) {\n                  cache = this.getCache();\n                  key = this.getMetadataCacheKey(id);\n                  metadata = cache.get(key);\n                  metadata.editors.splice(metadata.editors.findIndex(function (editor) {\n                    return editor.template.scope === scope && editor.template.templateKey === templateKey;\n                  }), 1);\n                  this.successHandler();\n                }\n                _context11.next = 23;\n                break;\n              case 20:\n                _context11.prev = 20;\n                _context11.t0 = _context11[\"catch\"](14);\n                this.errorHandler(_context11.t0);\n              case 23:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[14, 20]]);\n      }));\n      function deleteMetadata(_x35, _x36, _x37, _x38) {\n        return _deleteMetadata.apply(this, arguments);\n      }\n      return deleteMetadata;\n    }()\n  }]);\n  return Metadata;\n}(File);\nexport default Metadata;","map":{"version":3,"sources":["../../src/api/Metadata.js"],"names":["getProp","uniqueId","getBadItemError","getBadPermissionsError","isUserCorrectableError","getTypedFileId","File","HEADER_CONTENT_TYPE","METADATA_SCOPE_ENTERPRISE","METADATA_SCOPE_GLOBAL","METADATA_TEMPLATE_FETCH_LIMIT","METADATA_TEMPLATE_PROPERTIES","METADATA_TEMPLATE_CLASSIFICATION","METADATA_TEMPLATE_SKILLS","FIELD_METADATA_SKILLS","CACHE_PREFIX_METADATA","ERROR_CODE_UPDATE_SKILLS","ERROR_CODE_UPDATE_METADATA","ERROR_CODE_CREATE_METADATA","ERROR_CODE_DELETE_METADATA","ERROR_CODE_FETCH_METADATA","ERROR_CODE_FETCH_METADATA_TEMPLATES","ERROR_CODE_FETCH_SKILLS","Metadata","id","getMetadataCacheKey","scope","template","baseUrl","getUrl","getBaseApiUrl","getMetadataTemplateUrl","templateKey","hidden","instance","canEdit","data","Object","keys","forEach","key","startsWith","$id","$canEdit","instanceId","errorCode","templates","url","getMetadataTemplateUrlForInstance","getMetadataTemplateUrlForScope","xhr","get","params","limit","status","getMetadataTemplateSchemaUrl","instances","getMetadataUrl","customPropertiesTemplate","enterpriseTemplates","hasMetadataFeature","isExternallyOwned","userAddableTemplates","concat","filter","classification","find","$template","splice","indexOf","cache","getCache","getClassificationCacheKey","set","$scope","t","crossEnterpriseTemplate","getTemplates","globalTemplates","filteredInstances","extractClassification","editors","all","map","getTemplateForInstance","push","createEditor","file","successCallback","errorCallback","options","permissions","is_externally_owned","errorHandler","forceFetch","unset","has","successHandler","refreshCache","getCustomPropertiesTemplate","Promise","getInstances","resolve","getEditors","can_upload","metadata","getUserAddableTemplates","isDestroyed","getSkillsCacheKey","skills","cards","operations","put","headers","merge","getCacheKey","cachedMetadata","editor","findIndex","isProperties","post","delete"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the Box metadata related API\n * @author Box\n */\n\nimport getProp from 'lodash/get';\nimport uniqueId from 'lodash/uniqueId';\nimport { getBadItemError, getBadPermissionsError, isUserCorrectableError } from '../utils/error';\nimport { getTypedFileId } from '../utils/file';\nimport File from './File';\nimport {\n    HEADER_CONTENT_TYPE,\n    METADATA_SCOPE_ENTERPRISE,\n    METADATA_SCOPE_GLOBAL,\n    METADATA_TEMPLATE_FETCH_LIMIT,\n    METADATA_TEMPLATE_PROPERTIES,\n    METADATA_TEMPLATE_CLASSIFICATION,\n    METADATA_TEMPLATE_SKILLS,\n    FIELD_METADATA_SKILLS,\n    CACHE_PREFIX_METADATA,\n    ERROR_CODE_UPDATE_SKILLS,\n    ERROR_CODE_UPDATE_METADATA,\n    ERROR_CODE_CREATE_METADATA,\n    ERROR_CODE_DELETE_METADATA,\n    ERROR_CODE_FETCH_METADATA,\n    ERROR_CODE_FETCH_METADATA_TEMPLATES,\n    ERROR_CODE_FETCH_SKILLS,\n} from '../constants';\n\nimport type { RequestOptions, ElementsErrorCallback, JSONPatchOperations } from '../common/types/api';\nimport type {\n    MetadataTemplateSchemaResponse,\n    MetadataTemplate,\n    MetadataInstanceV2,\n    MetadataEditor,\n    MetadataFields,\n} from '../common/types/metadata';\nimport type { BoxItem } from '../common/types/core';\nimport type APICache from '../utils/Cache';\n\nclass Metadata extends File {\n    /**\n     * Creates a key for the metadata cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getMetadataCacheKey(id: string): string {\n        return `${CACHE_PREFIX_METADATA}${id}`;\n    }\n\n    /**\n     * Creates a key for the skills cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getSkillsCacheKey(id: string): string {\n        return `${this.getMetadataCacheKey(id)}_skills`;\n    }\n\n    /**\n     * Creates a key for the classification cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getClassificationCacheKey(id: string): string {\n        return `${this.getMetadataCacheKey(id)}_classification`;\n    }\n\n    /**\n     * API URL for metadata\n     *\n     * @param {string} id - a Box file id\n     * @param {string} field - metadata field\n     * @return {string} base url for files\n     */\n    getMetadataUrl(id: string, scope?: string, template?: string): string {\n        const baseUrl = `${this.getUrl(id)}/metadata`;\n        if (scope && template) {\n            return `${baseUrl}/${scope}/${template}`;\n        }\n        return baseUrl;\n    }\n\n    /**\n     * API URL for metadata templates for a scope\n     *\n     * @param {string} scope - metadata scope\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrl(): string {\n        return `${this.getBaseApiUrl()}/metadata_templates`;\n    }\n\n    /**\n     * API URL for metadata template for an instance\n     *\n     * @param {string} id - metadata instance id\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrlForInstance(id: string): string {\n        return `${this.getMetadataTemplateUrl()}?metadata_instance_id=${id}`;\n    }\n\n    /**\n     * API URL for getting metadata template schema by template key\n     *\n     * @param {string} templateKey - metadata template key\n     * @return {string} API url for getting template schema by template key\n     */\n    getMetadataTemplateSchemaUrl(templateKey: string): string {\n        return `${this.getMetadataTemplateUrl()}/enterprise/${templateKey}/schema`;\n    }\n\n    /**\n     * API URL for metadata templates\n     *\n     * @param {string} scope - metadata scope or id\n     * @return {string} base url for files\n     */\n    getMetadataTemplateUrlForScope(scope: string): string {\n        return `${this.getMetadataTemplateUrl()}/${scope}`;\n    }\n\n    /**\n     * Returns the custom properties template\n     *\n     * @return {Object} temaplte for custom properties\n     */\n    getCustomPropertiesTemplate(): MetadataTemplate {\n        return {\n            id: uniqueId('metadata_template_'),\n            scope: METADATA_SCOPE_GLOBAL,\n            templateKey: METADATA_TEMPLATE_PROPERTIES,\n            hidden: false,\n        };\n    }\n\n    /**\n     * Utility to create editors from metadata instances\n     * and metadata templates.\n     *\n     * @param {Object} instance - metadata instance\n     * @param {Object} template - metadata template\n     * @param {boolean} canEdit - is instance editable\n     * @return {Object} metadata editor\n     */\n    createEditor(instance: MetadataInstanceV2, template: MetadataTemplate, canEdit: boolean): MetadataEditor {\n        const data: MetadataFields = {};\n        Object.keys(instance).forEach(key => {\n            if (!key.startsWith('$')) {\n                // $FlowFixMe\n                data[key] = instance[key];\n            }\n        });\n\n        return {\n            template,\n            instance: {\n                id: instance.$id,\n                canEdit: instance.$canEdit && canEdit,\n                data,\n            },\n        };\n    }\n\n    /**\n     * Gets metadata templates for enterprise\n     *\n     * @param {string} id - file id\n     * @param {string} scope - metadata scope\n     * @param {string|void} [instanceId] - metadata instance id\n     * @return {Object} array of metadata templates\n     */\n    async getTemplates(id: string, scope: string, instanceId?: string): Promise<Array<MetadataTemplate>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA_TEMPLATES;\n        let templates = {};\n        const url = instanceId\n            ? this.getMetadataTemplateUrlForInstance(instanceId)\n            : this.getMetadataTemplateUrlForScope(scope);\n\n        try {\n            templates = await this.xhr.get({\n                url,\n                id: getTypedFileId(id),\n                params: {\n                    limit: METADATA_TEMPLATE_FETCH_LIMIT, // internal hard limit is 500\n                },\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n\n        return getProp(templates, 'data.entries', []);\n    }\n\n    /**\n     * Gets metadata template schema by template key\n     *\n     * @param {string} templateKey - template key\n     * @return {Promise} Promise object of metadata template\n     */\n    getSchemaByTemplateKey(templateKey: string): Promise<MetadataTemplateSchemaResponse> {\n        const url = this.getMetadataTemplateSchemaUrl(templateKey);\n        return this.xhr.get({ url });\n    }\n\n    /**\n     * Gets metadata instances for a Box file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n    async getInstances(id: string): Promise<Array<MetadataInstanceV2>> {\n        this.errorCode = ERROR_CODE_FETCH_METADATA;\n        let instances = {};\n        try {\n            instances = await this.xhr.get({\n                url: this.getMetadataUrl(id),\n                id: getTypedFileId(id),\n            });\n        } catch (e) {\n            const { status } = e;\n            if (isUserCorrectableError(status)) {\n                throw e;\n            }\n        }\n        return getProp(instances, 'data.entries', []);\n    }\n\n    /**\n     * Returns a list of templates that can be added by the user.\n     * For collabed files, only custom properties is allowed.\n     *\n     * @return {Object} template for custom properties\n     */\n    getUserAddableTemplates(\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        hasMetadataFeature: boolean,\n        isExternallyOwned?: boolean,\n    ): Array<MetadataTemplate> {\n        let userAddableTemplates: Array<MetadataTemplate> = [];\n        if (hasMetadataFeature) {\n            userAddableTemplates = isExternallyOwned\n                ? [customPropertiesTemplate]\n                : [customPropertiesTemplate].concat(enterpriseTemplates);\n        }\n        // Only templates that are not hidden and not classification\n        return userAddableTemplates.filter(\n            template => !template.hidden && template.templateKey !== METADATA_TEMPLATE_CLASSIFICATION,\n        );\n    }\n\n    /**\n     * Extracts classification for different representation in the UI.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @return {Array} metadata instances without classification\n     */\n    extractClassification(id: string, instances: Array<MetadataInstanceV2>): Array<MetadataInstanceV2> {\n        const classification = instances.find(instance => instance.$template === METADATA_TEMPLATE_CLASSIFICATION);\n        if (classification) {\n            instances.splice(instances.indexOf(classification), 1);\n            const cache: APICache = this.getCache();\n            const key = this.getClassificationCacheKey(id);\n            cache.set(key, classification);\n        }\n        return instances;\n    }\n\n    /**\n     * Finds template for a given metadata instance.\n     *\n     * @param {string} id - Box file id\n     * @param {Object} instance - metadata instance\n     * @param {Array} templates - metadata templates\n     * @return {Object|undefined} template for metadata instance\n     */\n    async getTemplateForInstance(\n        id: string,\n        instance: MetadataInstanceV2,\n        templates: Array<MetadataTemplate>,\n    ): Promise<?MetadataTemplate> {\n        const instanceId = instance.$id;\n        const templateKey = instance.$template;\n        const scope = instance.$scope;\n        let template = templates.find(t => t.templateKey === templateKey && t.scope === scope);\n\n        // Enterprise scopes are always enterprise_XXXXX\n        if (!template && scope.startsWith(METADATA_SCOPE_ENTERPRISE)) {\n            // If the template does not exist, it can be a template from another\n            // enterprise because the user is viewing a collaborated file.\n            const crossEnterpriseTemplate = await this.getTemplates(id, scope, instanceId);\n            // The API always returns an array of at most one item\n            template = crossEnterpriseTemplate[0]; // eslint-disable-line\n        }\n\n        return template;\n    }\n\n    /**\n     * Creates and returns metadata editors.\n     *\n     * @param {string} id - Box file id\n     * @param {Array} instances - metadata instances\n     * @param {Object} customPropertiesTemplate - custom properties template\n     * @param {Array} enterpriseTemplates - enterprise templates\n     * @param {Array} globalTemplates - global templates\n     * @param {boolean} canEdit - metadata editability\n     * @return {Array} metadata editors\n     */\n    async getEditors(\n        id: string,\n        instances: Array<MetadataInstanceV2>,\n        customPropertiesTemplate: MetadataTemplate,\n        enterpriseTemplates: Array<MetadataTemplate>,\n        globalTemplates: Array<MetadataTemplate>,\n        canEdit: boolean,\n    ): Promise<Array<MetadataEditor>> {\n        // All usable templates for metadata instances\n        const templates: Array<MetadataTemplate> = [customPropertiesTemplate].concat(\n            enterpriseTemplates,\n            globalTemplates,\n        );\n\n        // Filter out skills and classification\n        // let filteredInstances = this.extractSkills(id, instances);\n        const filteredInstances = this.extractClassification(id, instances);\n\n        // Create editors from each instance\n        const editors: Array<MetadataEditor> = [];\n        await Promise.all(\n            filteredInstances.map(async instance => {\n                const template: ?MetadataTemplate = await this.getTemplateForInstance(id, instance, templates);\n                if (template) {\n                    editors.push(this.createEditor(instance, template, canEdit));\n                }\n            }),\n        );\n        return editors;\n    }\n\n    /**\n     * API for getting metadata editors\n     *\n     * @param {string} fileId - Box file id\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param {boolean} hasMetadataFeature - metadata feature check\n     * @param {Object} options - fetch options\n     * @return {Promise}\n     */\n    async getMetadata(\n        file: BoxItem,\n        successCallback: ({ editors: Array<MetadataEditor>, templates: Array<MetadataTemplate> }) => void,\n        errorCallback: ElementsErrorCallback,\n        hasMetadataFeature: boolean,\n        options: RequestOptions = {},\n    ): Promise<void> {\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n        this.errorCode = ERROR_CODE_FETCH_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Check for valid file object.\n        // Need to eventually check for upload permission.\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key = this.getMetadataCacheKey(id);\n\n        // Clear the cache if needed\n        if (options.forceFetch) {\n            cache.unset(key);\n        }\n\n        // Return the cached value if it exists\n        if (cache.has(key)) {\n            this.successHandler(cache.get(key));\n            if (!options.refreshCache) {\n                return;\n            }\n        }\n\n        try {\n            const customPropertiesTemplate: MetadataTemplate = this.getCustomPropertiesTemplate();\n            const [instances, globalTemplates, enterpriseTemplates] = await Promise.all([\n                this.getInstances(id),\n                this.getTemplates(id, METADATA_SCOPE_GLOBAL),\n                hasMetadataFeature ? this.getTemplates(id, METADATA_SCOPE_ENTERPRISE) : Promise.resolve([]),\n            ]);\n\n            const editors = await this.getEditors(\n                id,\n                instances,\n                customPropertiesTemplate,\n                enterpriseTemplates,\n                globalTemplates,\n                !!permissions.can_upload,\n            );\n\n            const metadata = {\n                editors,\n                templates: this.getUserAddableTemplates(\n                    customPropertiesTemplate,\n                    enterpriseTemplates,\n                    hasMetadataFeature,\n                    is_externally_owned,\n                ),\n            };\n\n            cache.set(key, metadata);\n\n            if (!this.isDestroyed()) {\n                this.successHandler(metadata);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Gets skills for file\n     *\n     * @param {string} id - file id\n     * @return {Object} array of metadata instances\n     */\n    async getSkills(\n        file: BoxItem,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        forceFetch: boolean = false,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_FETCH_SKILLS;\n        const { id }: BoxItem = file;\n        if (!id) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key = this.getSkillsCacheKey(id);\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Clear the cache if needed\n        if (forceFetch) {\n            cache.unset(key);\n        }\n\n        // Return the Cache value if it exists\n        if (cache.has(key)) {\n            this.successHandler(cache.get(key));\n            return;\n        }\n\n        // The file object may already have skills in it\n        let skills = {\n            data: getProp(file, FIELD_METADATA_SKILLS),\n        };\n\n        try {\n            if (!skills.data) {\n                skills = await this.xhr.get({\n                    url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                    id: getTypedFileId(id),\n                });\n            }\n\n            if (!this.isDestroyed()) {\n                const cards = skills.data.cards || [];\n                cache.set(key, cards);\n                this.successHandler(cards);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for patching skills on a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} field - Metadata field to patch\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async updateSkills(\n        file: BoxItem,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_SKILLS;\n        const { id, permissions } = file;\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        if (!permissions.can_upload) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const metadata = await this.xhr.put({\n                url: this.getMetadataUrl(id, METADATA_SCOPE_GLOBAL, METADATA_TEMPLATE_SKILLS),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: getTypedFileId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cards = metadata.data.cards || [];\n                this.merge(this.getCacheKey(id), FIELD_METADATA_SKILLS, metadata.data);\n                this.getCache().set(this.getSkillsCacheKey(id), cards);\n                this.successHandler(cards);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for patching metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Array} operations - Array of JSON patch operations\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async updateMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        operations: JSONPatchOperations,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_UPDATE_METADATA;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        const { id, permissions } = file;\n        if (!id || !permissions) {\n            this.errorHandler(getBadItemError());\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n\n        if (!canEdit) {\n            this.errorHandler(getBadPermissionsError());\n            return;\n        }\n\n        try {\n            const metadata = await this.xhr.put({\n                url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                headers: {\n                    [HEADER_CONTENT_TYPE]: 'application/json-patch+json',\n                },\n                id: getTypedFileId(id),\n                data: operations,\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                const editor = this.createEditor(metadata.data, template, canEdit);\n                if (cachedMetadata && cachedMetadata.editors) {\n                    cachedMetadata.editors.splice(\n                        cachedMetadata.editors.findIndex(({ instance }) => instance.id === editor.instance.id),\n                        1,\n                        editor,\n                    );\n                }\n                this.successHandler(editor);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for creating metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {Object} template - Metadata template\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async createMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_CREATE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { id, permissions, is_externally_owned }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const canEdit = !!permissions.can_upload;\n        const isProperties =\n            template.templateKey === METADATA_TEMPLATE_PROPERTIES && template.scope === METADATA_SCOPE_GLOBAL;\n\n        if (!canEdit || (is_externally_owned && !isProperties)) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            const metadata = await this.xhr.post({\n                url: this.getMetadataUrl(id, template.scope, template.templateKey),\n                id: getTypedFileId(id),\n                data: {},\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const cachedMetadata = cache.get(key);\n                const editor = this.createEditor(metadata.data, template, canEdit);\n                cachedMetadata.editors.push(editor);\n                this.successHandler(editor);\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API for deleting metadata on file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} scope - Metadata instance scope\n     * @param {string} template - Metadata template key\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    async deleteMetadata(\n        file: BoxItem,\n        template: MetadataTemplate,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_DELETE_METADATA;\n        if (!file || !template) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        const { scope, templateKey }: MetadataTemplate = template;\n        const { id, permissions }: BoxItem = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return;\n        }\n\n        if (!permissions.can_upload) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return;\n        }\n\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        try {\n            await this.xhr.delete({\n                url: this.getMetadataUrl(id, scope, templateKey),\n                id: getTypedFileId(id),\n            });\n            if (!this.isDestroyed()) {\n                const cache: APICache = this.getCache();\n                const key = this.getMetadataCacheKey(id);\n                const metadata = cache.get(key);\n                metadata.editors.splice(\n                    metadata.editors.findIndex(\n                        editor => editor.template.scope === scope && editor.template.templateKey === templateKey,\n                    ),\n                    1,\n                );\n                this.successHandler();\n            }\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n}\n\nexport default Metadata;\n"]},"metadata":{},"sourceType":"module"}