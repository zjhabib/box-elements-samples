{"ast":null,"code":"import { EditorState, Modifier } from 'draft-js';\nvar defaultMentionTriggers = ['@', '＠', '﹫'];\nvar defaultMentionTriggersString = defaultMentionTriggers.reduce(function (prev, current) {\n  return \"\".concat(prev, \"\\\\\").concat(current);\n}, '');\nvar defaultMentionPattern = new RegExp(\"([\".concat(defaultMentionTriggersString, \"])([^\").concat(defaultMentionTriggersString, \"]*)$\"));\n/**\n * Extracts the active mention from the editor state\n */\n\nfunction getActiveMentionForEditorState(editorState) {\n  var mentionPattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultMentionPattern;\n  var contentState = editorState.getCurrentContent();\n  var selectionState = editorState.getSelection();\n  var startKey = selectionState.getStartKey();\n  var activeBlock = contentState.getBlockForKey(startKey);\n  var cursorPosition = selectionState.getStartOffset();\n  var result = null; // Break the active block into entity ranges.\n\n  activeBlock.findEntityRanges(function (character) {\n    return character.getEntity() === null;\n  }, function (start, end) {\n    // Find the active range (is the cursor inside this range?)\n    if (start <= cursorPosition && cursorPosition <= end) {\n      // Determine if the active range contains a mention.\n      var activeRangeText = activeBlock.getText().substr(start, cursorPosition - start);\n      var mentionMatch = activeRangeText.match(mentionPattern);\n      if (mentionMatch) {\n        result = {\n          blockID: startKey,\n          mentionString: mentionMatch[2],\n          mentionTrigger: mentionMatch[1],\n          start: start + mentionMatch.index,\n          end: cursorPosition\n        };\n      }\n    }\n    return null;\n  });\n  return result;\n}\n/**\n * Inserts a selected mention into the editor\n */\n\nfunction addMention(editorState, activeMention, mention) {\n  var _ref = activeMention || {},\n    start = _ref.start,\n    end = _ref.end;\n  var id = mention.id,\n    name = mention.name;\n  var contentState = editorState.getCurrentContent();\n  var selectionState = editorState.getSelection();\n  var preInsertionSelectionState = selectionState.merge({\n    anchorOffset: start,\n    focusOffset: end\n  });\n  var textToInsert = \"@\".concat(name);\n  var contentStateWithEntity = contentState.createEntity('MENTION', 'IMMUTABLE', {\n    id: id\n  });\n  var entityKey = contentStateWithEntity.getLastCreatedEntityKey();\n  var contentStateWithLink = Modifier.replaceText(contentState, preInsertionSelectionState, textToInsert, null, entityKey);\n  var spaceOffset = preInsertionSelectionState.getStartOffset() + textToInsert.length;\n  var selectionStateForAddingSpace = preInsertionSelectionState.merge({\n    anchorOffset: spaceOffset,\n    focusOffset: spaceOffset\n  });\n  var contentStateWithLinkAndExtraSpace = Modifier.insertText(contentStateWithLink, selectionStateForAddingSpace, ' ');\n  var editorStateWithLink = EditorState.push(editorState, contentStateWithLinkAndExtraSpace, 'change-block-type');\n  return editorStateWithLink;\n}\n/**\n * Formats the editor's text such that it will be accepted by the server.\n */\n\nfunction getFormattedCommentText(editorState) {\n  var contentState = editorState.getCurrentContent();\n  var blockMap = contentState.getBlockMap();\n  var resultStringArr = []; // The API needs to explicitly know if a message contains a mention.\n\n  var hasMention = false; // For all ContentBlocks in the ContentState:\n\n  blockMap.forEach(function (block) {\n    var text = block.getText();\n    var blockMapStringArr = []; // Break down the ContentBlock into ranges\n\n    block.findEntityRanges(function () {\n      return true;\n    }, function (start, end) {\n      var entityKey = block.getEntityAt(start); // If the range is an Entity, format its text eg \"@[1:Username]\"\n      // Otherwise append its text to the block result as-is\n\n      if (entityKey) {\n        var entity = contentState.getEntity(entityKey);\n        var stringToAdd = \"@[\".concat(entity.getData().id, \":\").concat(text.substring(start + 1, end), \"]\");\n        blockMapStringArr.push(stringToAdd);\n        hasMention = true;\n      } else {\n        blockMapStringArr.push(text.substring(start, end));\n      }\n    });\n    resultStringArr.push(blockMapStringArr.join(''));\n  }); // Concatenate the array of block strings with newlines\n  // (Each block represents a paragraph)\n\n  return {\n    text: resultStringArr.join('\\n'),\n    hasMention: hasMention\n  };\n}\nexport { addMention, defaultMentionTriggers, defaultMentionPattern, getActiveMentionForEditorState, getFormattedCommentText };","map":{"version":3,"sources":["../../../../src/components/form-elements/draft-js-mention-selector/utils.js"],"names":["EditorState","Modifier","defaultMentionTriggers","defaultMentionTriggersString","reduce","prev","current","defaultMentionPattern","RegExp","getActiveMentionForEditorState","editorState","mentionPattern","contentState","getCurrentContent","selectionState","getSelection","startKey","getStartKey","activeBlock","getBlockForKey","cursorPosition","getStartOffset","result","findEntityRanges","character","getEntity","start","end","activeRangeText","getText","substr","mentionMatch","match","blockID","mentionString","mentionTrigger","index","addMention","activeMention","mention","id","name","preInsertionSelectionState","merge","anchorOffset","focusOffset","textToInsert","contentStateWithEntity","createEntity","entityKey","getLastCreatedEntityKey","contentStateWithLink","replaceText","spaceOffset","length","selectionStateForAddingSpace","contentStateWithLinkAndExtraSpace","insertText","editorStateWithLink","push","getFormattedCommentText","blockMap","getBlockMap","resultStringArr","hasMention","forEach","text","block","blockMapStringArr","getEntityAt","entity","stringToAdd","getData","substring","join"],"mappings":"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","sourcesContent":["// @flow\nimport { EditorState, Modifier } from 'draft-js';\n\nexport type Mention = {\n    blockID: string,\n    end: number,\n    mentionString: string,\n    mentionTrigger: string,\n    start: number,\n};\n\nconst defaultMentionTriggers = ['@', '＠', '﹫'];\nconst defaultMentionTriggersString = defaultMentionTriggers.reduce((prev, current) => `${prev}\\\\${current}`, '');\nconst defaultMentionPattern = new RegExp(`([${defaultMentionTriggersString}])([^${defaultMentionTriggersString}]*)$`);\n\n/**\n * Extracts the active mention from the editor state\n */\nfunction getActiveMentionForEditorState(\n    editorState: EditorState,\n    mentionPattern: RegExp = defaultMentionPattern,\n): Mention | null {\n    const contentState = editorState.getCurrentContent();\n    const selectionState = editorState.getSelection();\n\n    const startKey = selectionState.getStartKey();\n    const activeBlock = contentState.getBlockForKey(startKey);\n\n    const cursorPosition = selectionState.getStartOffset();\n\n    let result = null;\n\n    // Break the active block into entity ranges.\n    activeBlock.findEntityRanges(\n        character => character.getEntity() === null,\n        (start, end) => {\n            // Find the active range (is the cursor inside this range?)\n            if (start <= cursorPosition && cursorPosition <= end) {\n                // Determine if the active range contains a mention.\n                const activeRangeText = activeBlock.getText().substr(start, cursorPosition - start);\n                const mentionMatch = activeRangeText.match(mentionPattern);\n\n                if (mentionMatch) {\n                    result = {\n                        blockID: startKey,\n                        mentionString: mentionMatch[2],\n                        mentionTrigger: mentionMatch[1],\n                        start: start + mentionMatch.index,\n                        end: cursorPosition,\n                    };\n                }\n            }\n\n            return null;\n        },\n    );\n\n    return result;\n}\n\n/**\n * Inserts a selected mention into the editor\n */\nfunction addMention(editorState: EditorState, activeMention: Mention | null, mention: Object): EditorState {\n    const { start, end } = activeMention || {};\n\n    const { id, name } = mention;\n\n    const contentState = editorState.getCurrentContent();\n    const selectionState = editorState.getSelection();\n\n    const preInsertionSelectionState = selectionState.merge({\n        anchorOffset: start,\n        focusOffset: end,\n    });\n\n    const textToInsert = `@${name}`;\n\n    const contentStateWithEntity = contentState.createEntity('MENTION', 'IMMUTABLE', { id });\n\n    const entityKey = contentStateWithEntity.getLastCreatedEntityKey();\n\n    const contentStateWithLink = Modifier.replaceText(\n        contentState,\n        preInsertionSelectionState,\n        textToInsert,\n        null,\n        entityKey,\n    );\n\n    const spaceOffset = preInsertionSelectionState.getStartOffset() + textToInsert.length;\n    const selectionStateForAddingSpace = preInsertionSelectionState.merge({\n        anchorOffset: spaceOffset,\n        focusOffset: spaceOffset,\n    });\n\n    const contentStateWithLinkAndExtraSpace = Modifier.insertText(\n        contentStateWithLink,\n        selectionStateForAddingSpace,\n        ' ',\n    );\n\n    const editorStateWithLink = EditorState.push(editorState, contentStateWithLinkAndExtraSpace, 'change-block-type');\n\n    return editorStateWithLink;\n}\n\n/**\n * Formats the editor's text such that it will be accepted by the server.\n */\nfunction getFormattedCommentText(editorState: EditorState): { hasMention: boolean, text: string } {\n    const contentState = editorState.getCurrentContent();\n    const blockMap = contentState.getBlockMap();\n\n    const resultStringArr = [];\n\n    // The API needs to explicitly know if a message contains a mention.\n    let hasMention = false;\n\n    // For all ContentBlocks in the ContentState:\n    blockMap.forEach(block => {\n        const text = block.getText();\n        const blockMapStringArr = [];\n\n        // Break down the ContentBlock into ranges\n        block.findEntityRanges(\n            () => true,\n            (start, end) => {\n                const entityKey = block.getEntityAt(start);\n                // If the range is an Entity, format its text eg \"@[1:Username]\"\n                // Otherwise append its text to the block result as-is\n                if (entityKey) {\n                    const entity = contentState.getEntity(entityKey);\n                    const stringToAdd = `@[${entity.getData().id}:${text.substring(start + 1, end)}]`;\n                    blockMapStringArr.push(stringToAdd);\n                    hasMention = true;\n                } else {\n                    blockMapStringArr.push(text.substring(start, end));\n                }\n            },\n        );\n        resultStringArr.push(blockMapStringArr.join(''));\n    });\n\n    // Concatenate the array of block strings with newlines\n    // (Each block represents a paragraph)\n    return { text: resultStringArr.join('\\n'), hasMention };\n}\n\nexport {\n    addMention,\n    defaultMentionTriggers,\n    defaultMentionPattern,\n    getActiveMentionForEditorState,\n    getFormattedCommentText,\n};\n"]},"metadata":{},"sourceType":"module"}