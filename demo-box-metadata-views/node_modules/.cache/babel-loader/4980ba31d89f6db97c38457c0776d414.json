{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport React, { Fragment } from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport AutoSizer from 'react-virtualized/dist/es/AutoSizer';\nimport classNames from 'classnames';\nimport find from 'lodash/find';\nimport getProp from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport isNil from 'lodash/isNil';\nimport isString from 'lodash/isString';\nimport MultiGrid from 'react-virtualized/dist/es/MultiGrid/MultiGrid';\nimport MetadataField from '../metadata-instance-fields/MetadataField';\nimport ReadOnlyMetadataField from '../metadata-instance-fields/ReadOnlyMetadataField';\nimport FileIcon from '../../icons/file-icon';\nimport IconWithTooltip from './IconWithTooltip';\nimport PlainButton from '../../components/plain-button';\nimport { getFileExtension } from '../../utils/file';\nimport messages from '../../elements/common/messages';\nimport './MetadataBasedItemList.scss';\nimport { CANCEL_ICON_TYPE, EDIT_ICON_TYPE, FILE_ICON_COLUMN_INDEX, FILE_ICON_COLUMN_WIDTH, FILE_ICON_SIZE, FILE_NAME_COLUMN_INDEX, FILE_NAME_COLUMN_WIDTH, FIXED_COLUMNS_NUMBER, FIXED_ROW_NUMBER, HEADER_ROW_INDEX, MIN_METADATA_COLUMN_WIDTH, SAVE_ICON_TYPE } from './constants';\nimport { FIELD_TYPE_FLOAT, FIELD_TYPE_INTEGER, FIELD_TYPE_STRING } from '../metadata-instance-fields/constants';\nimport { FIELD_METADATA } from '../../constants';\nvar MetadataBasedItemList = /*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MetadataBasedItemList, _React$Component);\n  function MetadataBasedItemList(props) {\n    var _this;\n    _classCallCheck(this, MetadataBasedItemList);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MetadataBasedItemList).call(this, props));\n    _defineProperty(_assertThisInitialized(_this), \"getInitialState\", function () {\n      return {\n        editedColumnIndex: -1,\n        editedRowIndex: -1,\n        hoveredRowIndex: -1,\n        hoveredColumnIndex: -1,\n        isUpdating: false,\n        scrollLeftOffset: 0,\n        scrollRightOffset: 0\n      };\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getItemWithPermissions\", function (item) {\n      /*\n          - @TODO: Remove permissions object once its part of API response.\n          - add \"can_preview: true\" so that users can click to launch the Preview modal. If users don't have access, they will see the error when Preview loads.\n          - add \"can_upload: true\" so that users can update the metadata values.\n      */\n      var permissions = {\n        can_preview: true,\n        can_upload: true\n      };\n      return _objectSpread({}, item, {\n        permissions: permissions\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleCancelEdit\", function () {\n      _this.setState({\n        editedColumnIndex: -1,\n        editedRowIndex: -1\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleSave\", function (item, field, type, currentValue, editedValue) {\n      var onMetadataUpdate = _this.props.onMetadataUpdate;\n      onMetadataUpdate(_this.getItemWithPermissions(item), field, currentValue, _this.getValueForType(type, editedValue));\n      _this.setState({\n        isUpdating: true\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleMouseEnter\", function (columnIndex, rowIndex) {\n      return _this.setState({\n        hoveredColumnIndex: columnIndex,\n        hoveredRowIndex: rowIndex\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleMouseLeave\", function () {\n      return _this.setState({\n        hoveredRowIndex: -1,\n        hoveredColumnIndex: -1\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleContentScroll\", function (_ref) {\n      var clientWidth = _ref.clientWidth,\n        scrollLeft = _ref.scrollLeft,\n        scrollWidth = _ref.scrollWidth;\n      _this.setState({\n        scrollLeftOffset: scrollLeft,\n        scrollRightOffset: scrollWidth - clientWidth - scrollLeft\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"cellRenderer\", function (_ref2) {\n      var columnIndex = _ref2.columnIndex,\n        rowIndex = _ref2.rowIndex,\n        key = _ref2.key,\n        style = _ref2.style;\n      var hoveredRowIndex = _this.state.hoveredRowIndex;\n      var isHeaderRow = rowIndex === HEADER_ROW_INDEX;\n      var isFileIconCell = !isHeaderRow && columnIndex === FILE_ICON_COLUMN_INDEX;\n      var isFileNameCell = !isHeaderRow && columnIndex === FILE_NAME_COLUMN_INDEX;\n      var isGridRowHovered = !isHeaderRow && rowIndex === hoveredRowIndex;\n      var data = isHeaderRow ? _this.getGridHeaderData(columnIndex) : _this.getGridCellData(columnIndex, rowIndex);\n      var classes = classNames('bdl-MetadataBasedItemList-cell', {\n        'bdl-MetadataBasedItemList-cell--fileIcon': isFileIconCell,\n        'bdl-MetadataBasedItemList-cell--filename': isFileNameCell,\n        'bdl-MetadataBasedItemList-cell--hover': isGridRowHovered\n      });\n      return React.createElement(\"div\", {\n        className: classes,\n        key: key,\n        onMouseEnter: function onMouseEnter() {\n          return _this.handleMouseEnter(columnIndex, rowIndex);\n        },\n        onMouseLeave: _this.handleMouseLeave,\n        style: style\n      }, data);\n    });\n    _this.state = _this.getInitialState();\n    return _this;\n  }\n  _createClass(MetadataBasedItemList, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var prevItems = getProp(prevProps, 'currentCollection.items');\n      var currentItems = getProp(this.props, 'currentCollection.items');\n      if (!isEqual(currentItems, prevItems)) {\n        // Either the view was refreshed or metadata was updated, reset edit part of the state to initial values\n        this.setState({\n          editedColumnIndex: -1,\n          editedRowIndex: -1,\n          isUpdating: false,\n          valueBeingEdited: undefined\n        });\n      }\n    }\n  }, {\n    key: \"getQueryResponseFields\",\n    value: function getQueryResponseFields() {\n      var fields = getProp(this.props, 'currentCollection.items[0].metadata.enterprise.fields', []);\n      return fields.map(function (_ref3) {\n        var key = _ref3.key,\n          displayName = _ref3.displayName;\n        return {\n          key: key,\n          displayName: displayName\n        };\n      });\n    }\n  }, {\n    key: \"getColumnWidth\",\n    value: function getColumnWidth(width) {\n      var fieldsToShow = this.props.fieldsToShow;\n      return function (_ref4) {\n        var index = _ref4.index;\n        if (index === FILE_ICON_COLUMN_INDEX) {\n          return FILE_ICON_COLUMN_WIDTH;\n        }\n        if (index === FILE_NAME_COLUMN_INDEX) {\n          return FILE_NAME_COLUMN_WIDTH;\n        }\n        var availableWidth = width - FILE_NAME_COLUMN_WIDTH - FILE_ICON_COLUMN_WIDTH; // total width minus width of sticky columns\n        // Maintain min column width, else occupy the rest of the space equally\n\n        return Math.max(availableWidth / fieldsToShow.length, MIN_METADATA_COLUMN_WIDTH);\n      };\n    }\n  }, {\n    key: \"handleItemClick\",\n    value: function handleItemClick(item) {\n      var onItemClick = this.props.onItemClick;\n      onItemClick(this.getItemWithPermissions(item));\n    }\n  }, {\n    key: \"handleEditIconClick\",\n    value: function handleEditIconClick(columnIndex, rowIndex, value) {\n      this.setState({\n        editedColumnIndex: columnIndex,\n        editedRowIndex: rowIndex,\n        valueBeingEdited: value\n      });\n    }\n  }, {\n    key: \"getValueForType\",\n    value: function getValueForType(type, value) {\n      if (type === FIELD_TYPE_FLOAT && !isNil(value)) {\n        return parseFloat(value);\n      }\n      if (type === FIELD_TYPE_INTEGER && !isNil(value)) {\n        return parseInt(value, 10);\n      }\n      return value;\n    }\n  }, {\n    key: \"isMetadataField\",\n    value: function isMetadataField(key) {\n      return key.startsWith(\"\".concat(FIELD_METADATA, \".\"));\n    }\n  }, {\n    key: \"getFieldNameFromKey\",\n    value: function getFieldNameFromKey(key) {\n      return key.split('.').pop();\n    }\n  }, {\n    key: \"getGridCellData\",\n    value: function getGridCellData(columnIndex, rowIndex) {\n      var _this2 = this;\n      var _this$props = this.props,\n        _this$props$currentCo = _this$props.currentCollection.items,\n        items = _this$props$currentCo === void 0 ? [] : _this$props$currentCo,\n        fieldsToShow = _this$props.fieldsToShow;\n      var _this$state = this.state,\n        editedColumnIndex = _this$state.editedColumnIndex,\n        editedRowIndex = _this$state.editedRowIndex,\n        hoveredColumnIndex = _this$state.hoveredColumnIndex,\n        hoveredRowIndex = _this$state.hoveredRowIndex,\n        isUpdating = _this$state.isUpdating,\n        valueBeingEdited = _this$state.valueBeingEdited;\n      var isCellBeingEdited = columnIndex === editedColumnIndex && rowIndex === editedRowIndex;\n      var isCellHovered = columnIndex === hoveredColumnIndex && rowIndex === hoveredRowIndex;\n      var fieldToShow = fieldsToShow[columnIndex - FIXED_COLUMNS_NUMBER];\n      var isCellEditable = !isCellBeingEdited && isCellHovered && getProp(fieldToShow, 'canEdit', false);\n      var item = items[rowIndex - 1];\n      var id = item.id,\n        name = item.name;\n      var fields = getProp(item, 'metadata.enterprise.fields', []);\n      var cellData;\n      switch (columnIndex) {\n        case FILE_ICON_COLUMN_INDEX:\n          cellData = React.createElement(FileIcon, {\n            dimension: FILE_ICON_SIZE,\n            extension: getFileExtension(name)\n          });\n          break;\n        case FILE_NAME_COLUMN_INDEX:\n          cellData = React.createElement(PlainButton, {\n            type: \"button\",\n            onClick: function onClick() {\n              return _this2.handleItemClick(item);\n            }\n          }, name);\n          break;\n        default:\n          {\n            var key = isString(fieldToShow) ? fieldToShow : fieldToShow.key;\n            var field;\n            var type = FIELD_TYPE_STRING;\n            var value;\n            var options = [];\n            var isMetadataField = this.isMetadataField(key);\n            if (isMetadataField) {\n              // If field is metadata instance field\n              field = find(fields, ['key', key]);\n              if (!field) {\n                return cellData;\n              }\n              var _field = field;\n              type = _field.type;\n              value = _field.value;\n              var _field$options = _field.options;\n              options = _field$options === void 0 ? [] : _field$options;\n            } else {\n              // If field is item field, e.g. name, size, description etc.\n              value = getProp(item, key);\n            }\n            var fieldName = this.getFieldNameFromKey(key);\n            var shouldShowEditIcon = isCellEditable && isString(type);\n            cellData = React.createElement(React.Fragment, null, !isCellBeingEdited && React.createElement(ReadOnlyMetadataField, {\n              dataValue: value,\n              displayName: \"\",\n              type: type\n            }), shouldShowEditIcon && React.createElement(IconWithTooltip, {\n              type: EDIT_ICON_TYPE,\n              tooltipText: React.createElement(FormattedMessage, messages.editLabel),\n              onClick: function onClick() {\n                return _this2.handleEditIconClick(columnIndex, rowIndex, value);\n              }\n            }), isCellBeingEdited && React.createElement(\"div\", {\n              className: \"bdl-MetadataBasedItemList-cell--edit\"\n            }, React.createElement(MetadataField, {\n              canEdit: true,\n              dataKey: \"\".concat(id).concat(key),\n              dataValue: valueBeingEdited,\n              displayName: \"\",\n              type: type,\n              onChange: function onChange(changeKey, changedValue) {\n                _this2.setState({\n                  valueBeingEdited: changedValue\n                });\n              },\n              onRemove: function onRemove() {\n                _this2.setState({\n                  valueBeingEdited: undefined\n                });\n              },\n              options: options\n            }), React.createElement(IconWithTooltip, {\n              className: \"bdl-MetadataBasedItemList-cell--cancelIcon\",\n              onClick: this.handleCancelEdit,\n              tooltipText: React.createElement(FormattedMessage, messages.cancel),\n              type: CANCEL_ICON_TYPE\n            }), value !== valueBeingEdited && React.createElement(IconWithTooltip, {\n              className: \"bdl-MetadataBasedItemList-cell--saveIcon\",\n              onClick: function onClick() {\n                return _this2.handleSave(item, fieldName, type, value, valueBeingEdited);\n              },\n              tooltipText: React.createElement(FormattedMessage, messages.save),\n              type: SAVE_ICON_TYPE,\n              isUpdating: isUpdating\n            })));\n          }\n      }\n      return cellData;\n    }\n  }, {\n    key: \"getGridHeaderData\",\n    value: function getGridHeaderData(columnIndex) {\n      var fieldsToShow = this.props.fieldsToShow;\n      if (columnIndex === 0) return undefined;\n      if (columnIndex === FILE_NAME_COLUMN_INDEX) {\n        return React.createElement(FormattedMessage, messages.name); // \"Name\" column header\n      }\n\n      var responseFields = this.getQueryResponseFields();\n      var field = fieldsToShow[columnIndex - FIXED_COLUMNS_NUMBER];\n      var key = isString(field) ? field : field.key; // Derive displayName in following order:\n      // 1. fieldsToShow prop ||\n      // 2. metadata template instance ||\n      // 3. field key\n\n      var displayName = getProp(field, 'displayName') || getProp(find(responseFields, ['key', key]), 'displayName', key);\n      return displayName;\n    }\n  }, {\n    key: \"getScrollPositionClasses\",\n    value: function getScrollPositionClasses(width) {\n      var _this$state2 = this.state,\n        scrollLeftOffset = _this$state2.scrollLeftOffset,\n        scrollRightOffset = _this$state2.scrollRightOffset;\n      var isViewScrolledLeft = this.calculateContentWidth() > width && scrollRightOffset > 0;\n      var isViewScrolledRight = scrollLeftOffset > 0;\n      var isViewScrolledInMiddle = isViewScrolledLeft && isViewScrolledRight;\n      return {\n        'is-scrolledLeft': isViewScrolledLeft && !isViewScrolledInMiddle,\n        // content scrolled all the way to the left\n        'is-scrolledRight': isViewScrolledRight && !isViewScrolledInMiddle,\n        // content scrolled all the way to the right\n        'is-scrolledMiddle': isViewScrolledInMiddle // content scrolled somewhere in between\n      };\n    }\n  }, {\n    key: \"calculateContentWidth\",\n    value: function calculateContentWidth() {\n      var fieldsToShow = this.props.fieldsToShow; // total width = sum of widths of sticky & non-sticky columns\n\n      return FILE_ICON_COLUMN_WIDTH + FILE_NAME_COLUMN_WIDTH + fieldsToShow.length * MIN_METADATA_COLUMN_WIDTH;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var _this$props2 = this.props,\n        currentCollection = _this$props2.currentCollection,\n        fieldsToShow = _this$props2.fieldsToShow;\n      var rowCount = currentCollection.items ? currentCollection.items.length : 0;\n      return React.createElement(AutoSizer, null, function (_ref5) {\n        var width = _ref5.width,\n          height = _ref5.height;\n        var scrollClasses = _this3.getScrollPositionClasses(width);\n        var classesTopRightGrid = classNames('bdl-MetadataBasedItemList-topRightGrid', scrollClasses);\n        var classesBottomRightGrid = classNames('bdl-MetadataBasedItemList-bottomRightGrid', scrollClasses);\n        return React.createElement(\"div\", {\n          className: \"bdl-MetadataBasedItemList\"\n        }, React.createElement(MultiGrid, {\n          cellRenderer: _this3.cellRenderer,\n          classNameBottomRightGrid: classesBottomRightGrid,\n          classNameTopRightGrid: classesTopRightGrid,\n          columnCount: fieldsToShow.length + FIXED_COLUMNS_NUMBER,\n          columnWidth: _this3.getColumnWidth(width),\n          fixedColumnCount: FIXED_COLUMNS_NUMBER,\n          fixedRowCount: FIXED_ROW_NUMBER,\n          height: height,\n          hideBottomLeftGridScrollbar: true,\n          hideTopRightGridScrollbar: true,\n          rowCount: rowCount + FIXED_ROW_NUMBER,\n          rowHeight: 50,\n          width: width,\n          onScroll: _this3.handleContentScroll\n        }));\n      });\n    }\n  }]);\n  return MetadataBasedItemList;\n}(React.Component);\nexport default MetadataBasedItemList;","map":{"version":3,"sources":["../../../src/features/metadata-based-view/MetadataBasedItemList.js"],"names":["React","Fragment","FormattedMessage","AutoSizer","classNames","find","getProp","isEqual","isNil","isString","MultiGrid","MetadataField","ReadOnlyMetadataField","FileIcon","IconWithTooltip","PlainButton","getFileExtension","messages","CANCEL_ICON_TYPE","EDIT_ICON_TYPE","FILE_ICON_COLUMN_INDEX","FILE_ICON_COLUMN_WIDTH","FILE_ICON_SIZE","FILE_NAME_COLUMN_INDEX","FILE_NAME_COLUMN_WIDTH","FIXED_COLUMNS_NUMBER","FIXED_ROW_NUMBER","HEADER_ROW_INDEX","MIN_METADATA_COLUMN_WIDTH","SAVE_ICON_TYPE","FIELD_TYPE_FLOAT","FIELD_TYPE_INTEGER","FIELD_TYPE_STRING","FIELD_METADATA","MetadataBasedItemList","Component","props","state","getInitialState","editedColumnIndex","editedRowIndex","hoveredRowIndex","hoveredColumnIndex","isUpdating","scrollLeftOffset","scrollRightOffset","prevProps","prevItems","currentItems","setState","valueBeingEdited","undefined","fields","map","key","displayName","width","fieldsToShow","index","availableWidth","Math","max","length","item","permissions","can_preview","can_upload","onItemClick","getItemWithPermissions","columnIndex","rowIndex","value","field","type","currentValue","editedValue","onMetadataUpdate","getValueForType","clientWidth","scrollLeft","scrollWidth","parseFloat","parseInt","startsWith","split","pop","currentCollection","items","isCellBeingEdited","isCellHovered","fieldToShow","isCellEditable","id","name","cellData","handleItemClick","options","isMetadataField","fieldName","getFieldNameFromKey","shouldShowEditIcon","editLabel","handleEditIconClick","changeKey","changedValue","handleCancelEdit","cancel","handleSave","save","responseFields","getQueryResponseFields","style","isHeaderRow","isFileIconCell","isFileNameCell","isGridRowHovered","data","getGridHeaderData","getGridCellData","classes","handleMouseEnter","handleMouseLeave","isViewScrolledLeft","calculateContentWidth","isViewScrolledRight","isViewScrolledInMiddle","rowCount","height","scrollClasses","getScrollPositionClasses","classesTopRightGrid","classesBottomRightGrid","cellRenderer","getColumnWidth","handleContentScroll"],"mappings":"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","sourcesContent":["// @flow strict\n\nimport React, { type Element, Fragment } from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport AutoSizer from 'react-virtualized/dist/es/AutoSizer';\nimport classNames from 'classnames';\nimport find from 'lodash/find';\nimport getProp from 'lodash/get';\nimport isEqual from 'lodash/isEqual';\nimport isNil from 'lodash/isNil';\nimport isString from 'lodash/isString';\nimport MultiGrid from 'react-virtualized/dist/es/MultiGrid/MultiGrid';\n\nimport MetadataField from '../metadata-instance-fields/MetadataField';\nimport ReadOnlyMetadataField from '../metadata-instance-fields/ReadOnlyMetadataField';\nimport FileIcon from '../../icons/file-icon';\nimport IconWithTooltip from './IconWithTooltip';\nimport PlainButton from '../../components/plain-button';\n\nimport { getFileExtension } from '../../utils/file';\nimport messages from '../../elements/common/messages';\n\nimport './MetadataBasedItemList.scss';\n\nimport type { MetadataFieldConfig, FieldsToShow } from '../../common/types/metadataQueries';\nimport type { MetadataFieldValue } from '../../common/types/metadata';\nimport type { StringAnyMap, Collection, BoxItem } from '../../common/types/core';\n\nimport {\n    CANCEL_ICON_TYPE,\n    EDIT_ICON_TYPE,\n    FILE_ICON_COLUMN_INDEX,\n    FILE_ICON_COLUMN_WIDTH,\n    FILE_ICON_SIZE,\n    FILE_NAME_COLUMN_INDEX,\n    FILE_NAME_COLUMN_WIDTH,\n    FIXED_COLUMNS_NUMBER,\n    FIXED_ROW_NUMBER,\n    HEADER_ROW_INDEX,\n    MIN_METADATA_COLUMN_WIDTH,\n    SAVE_ICON_TYPE,\n} from './constants';\nimport { FIELD_TYPE_FLOAT, FIELD_TYPE_INTEGER, FIELD_TYPE_STRING } from '../metadata-instance-fields/constants';\nimport { FIELD_METADATA } from '../../constants';\n\ntype State = {\n    editedColumnIndex: number,\n    editedRowIndex: number,\n    hoveredColumnIndex: number,\n    hoveredRowIndex: number,\n    isUpdating: boolean,\n    scrollLeftOffset: number,\n    scrollRightOffset: number,\n    valueBeingEdited?: ?MetadataFieldValue,\n};\n\ntype Props = {\n    currentCollection: Collection,\n    fieldsToShow: FieldsToShow,\n    onItemClick: BoxItem => void,\n    onMetadataUpdate: (BoxItem, string, ?MetadataFieldValue, ?MetadataFieldValue) => void,\n};\n\ntype CellRendererArgs = {\n    columnIndex: number,\n    key: string,\n    rowIndex: number,\n    style: StringAnyMap,\n};\n\ntype ColumnWidthCallback = ({ index: number }) => number;\ntype GridCellData = Element<typeof FileIcon | typeof PlainButton | typeof Fragment>;\n\ntype ScrollPositionClasses = {\n    'is-scrolledLeft': boolean,\n    'is-scrolledMiddle': boolean,\n    'is-scrolledRight': boolean,\n};\n\ntype ScrollEventData = {\n    clientWidth: number,\n    scrollLeft: number,\n    scrollWidth: number,\n};\n\nclass MetadataBasedItemList extends React.Component<Props, State> {\n    props: Props;\n\n    constructor(props: Props) {\n        super(props);\n        this.state = this.getInitialState();\n    }\n\n    getInitialState = () => {\n        return {\n            editedColumnIndex: -1,\n            editedRowIndex: -1,\n            hoveredRowIndex: -1,\n            hoveredColumnIndex: -1,\n            isUpdating: false,\n            scrollLeftOffset: 0,\n            scrollRightOffset: 0,\n        };\n    };\n\n    componentDidUpdate(prevProps: Props) {\n        const prevItems = getProp(prevProps, 'currentCollection.items');\n        const currentItems = getProp(this.props, 'currentCollection.items');\n\n        if (!isEqual(currentItems, prevItems)) {\n            // Either the view was refreshed or metadata was updated, reset edit part of the state to initial values\n            this.setState({\n                editedColumnIndex: -1,\n                editedRowIndex: -1,\n                isUpdating: false,\n                valueBeingEdited: undefined,\n            });\n        }\n    }\n\n    getQueryResponseFields() {\n        const fields = getProp(this.props, 'currentCollection.items[0].metadata.enterprise.fields', []);\n        return fields.map(({ key, displayName }) => ({ key, displayName }));\n    }\n\n    getColumnWidth(width: number): ColumnWidthCallback {\n        const { fieldsToShow } = this.props;\n\n        return ({ index }: { index: number }): number => {\n            if (index === FILE_ICON_COLUMN_INDEX) {\n                return FILE_ICON_COLUMN_WIDTH;\n            }\n\n            if (index === FILE_NAME_COLUMN_INDEX) {\n                return FILE_NAME_COLUMN_WIDTH;\n            }\n\n            const availableWidth = width - FILE_NAME_COLUMN_WIDTH - FILE_ICON_COLUMN_WIDTH; // total width minus width of sticky columns\n            // Maintain min column width, else occupy the rest of the space equally\n            return Math.max(availableWidth / fieldsToShow.length, MIN_METADATA_COLUMN_WIDTH);\n        };\n    }\n\n    getItemWithPermissions = (item: BoxItem): BoxItem => {\n        /*\n            - @TODO: Remove permissions object once its part of API response.\n            - add \"can_preview: true\" so that users can click to launch the Preview modal. If users don't have access, they will see the error when Preview loads.\n            - add \"can_upload: true\" so that users can update the metadata values.\n        */\n        const permissions = { can_preview: true, can_upload: true };\n        return { ...item, permissions };\n    };\n\n    handleItemClick(item: BoxItem): void {\n        const { onItemClick }: Props = this.props;\n        onItemClick(this.getItemWithPermissions(item));\n    }\n\n    handleEditIconClick(columnIndex: number, rowIndex: number, value: string): void {\n        this.setState({\n            editedColumnIndex: columnIndex,\n            editedRowIndex: rowIndex,\n            valueBeingEdited: value,\n        });\n    }\n\n    handleCancelEdit = (): void => {\n        this.setState({\n            editedColumnIndex: -1,\n            editedRowIndex: -1,\n        });\n    };\n\n    handleSave = (\n        item: BoxItem,\n        field: string,\n        type: string,\n        currentValue: ?MetadataFieldValue,\n        editedValue: ?MetadataFieldValue,\n    ): void => {\n        const { onMetadataUpdate } = this.props;\n        onMetadataUpdate(\n            this.getItemWithPermissions(item),\n            field,\n            currentValue,\n            this.getValueForType(type, editedValue),\n        );\n        this.setState({ isUpdating: true });\n    };\n\n    handleMouseEnter = (columnIndex: number, rowIndex: number): void =>\n        this.setState({\n            hoveredColumnIndex: columnIndex,\n            hoveredRowIndex: rowIndex,\n        });\n\n    handleMouseLeave = (): void =>\n        this.setState({\n            hoveredRowIndex: -1,\n            hoveredColumnIndex: -1,\n        });\n\n    handleContentScroll = ({ clientWidth, scrollLeft, scrollWidth }: ScrollEventData): void => {\n        this.setState({\n            scrollLeftOffset: scrollLeft,\n            scrollRightOffset: scrollWidth - clientWidth - scrollLeft,\n        });\n    };\n\n    getValueForType(type: string, value: MetadataFieldValue) {\n        if (type === FIELD_TYPE_FLOAT && !isNil(value)) {\n            return parseFloat(value);\n        }\n\n        if (type === FIELD_TYPE_INTEGER && !isNil(value)) {\n            return parseInt(value, 10);\n        }\n\n        return value;\n    }\n\n    isMetadataField(key: string): boolean {\n        return key.startsWith(`${FIELD_METADATA}.`);\n    }\n\n    getFieldNameFromKey(key: string): string {\n        return key.split('.').pop();\n    }\n\n    getGridCellData(columnIndex: number, rowIndex: number): GridCellData | void {\n        const {\n            currentCollection: { items = [] },\n            fieldsToShow,\n        }: Props = this.props;\n\n        const {\n            editedColumnIndex,\n            editedRowIndex,\n            hoveredColumnIndex,\n            hoveredRowIndex,\n            isUpdating,\n            valueBeingEdited,\n        }: State = this.state;\n        const isCellBeingEdited = columnIndex === editedColumnIndex && rowIndex === editedRowIndex;\n        const isCellHovered = columnIndex === hoveredColumnIndex && rowIndex === hoveredRowIndex;\n\n        const fieldToShow = fieldsToShow[columnIndex - FIXED_COLUMNS_NUMBER];\n        const isCellEditable = !isCellBeingEdited && isCellHovered && getProp(fieldToShow, 'canEdit', false);\n        const item = items[rowIndex - 1];\n        const { id, name } = item;\n        const fields = getProp(item, 'metadata.enterprise.fields', []);\n        let cellData;\n\n        switch (columnIndex) {\n            case FILE_ICON_COLUMN_INDEX:\n                cellData = <FileIcon dimension={FILE_ICON_SIZE} extension={getFileExtension(name)} />;\n                break;\n            case FILE_NAME_COLUMN_INDEX:\n                cellData = (\n                    <PlainButton type=\"button\" onClick={() => this.handleItemClick(item)}>\n                        {name}\n                    </PlainButton>\n                );\n                break;\n            default: {\n                const key = isString(fieldToShow) ? fieldToShow : fieldToShow.key;\n                let field;\n                let type = FIELD_TYPE_STRING;\n                let value;\n                let options = [];\n                const isMetadataField = this.isMetadataField(key);\n\n                if (isMetadataField) {\n                    // If field is metadata instance field\n                    field = find(fields, ['key', key]);\n                    if (!field) {\n                        return cellData;\n                    }\n                    ({ type, value, options = [] } = field);\n                } else {\n                    // If field is item field, e.g. name, size, description etc.\n                    value = getProp(item, key);\n                }\n                const fieldName = this.getFieldNameFromKey(key);\n                const shouldShowEditIcon = isCellEditable && isString(type);\n                cellData = (\n                    <>\n                        {!isCellBeingEdited && <ReadOnlyMetadataField dataValue={value} displayName=\"\" type={type} />}\n                        {shouldShowEditIcon && (\n                            <IconWithTooltip\n                                type={EDIT_ICON_TYPE}\n                                tooltipText={<FormattedMessage {...messages.editLabel} />}\n                                onClick={() => this.handleEditIconClick(columnIndex, rowIndex, value)}\n                            />\n                        )}\n                        {isCellBeingEdited && (\n                            <div className=\"bdl-MetadataBasedItemList-cell--edit\">\n                                <MetadataField\n                                    canEdit\n                                    dataKey={`${id}${key}`}\n                                    dataValue={valueBeingEdited}\n                                    displayName=\"\"\n                                    type={type}\n                                    onChange={(changeKey, changedValue) => {\n                                        this.setState({\n                                            valueBeingEdited: changedValue,\n                                        });\n                                    }}\n                                    onRemove={() => {\n                                        this.setState({\n                                            valueBeingEdited: undefined,\n                                        });\n                                    }}\n                                    options={options}\n                                />\n                                <IconWithTooltip\n                                    className=\"bdl-MetadataBasedItemList-cell--cancelIcon\"\n                                    onClick={this.handleCancelEdit}\n                                    tooltipText={<FormattedMessage {...messages.cancel} />}\n                                    type={CANCEL_ICON_TYPE}\n                                />\n                                {value !== valueBeingEdited && (\n                                    <IconWithTooltip\n                                        className=\"bdl-MetadataBasedItemList-cell--saveIcon\"\n                                        onClick={() => this.handleSave(item, fieldName, type, value, valueBeingEdited)}\n                                        tooltipText={<FormattedMessage {...messages.save} />}\n                                        type={SAVE_ICON_TYPE}\n                                        isUpdating={isUpdating}\n                                    />\n                                )}\n                            </div>\n                        )}\n                    </>\n                );\n            }\n        }\n\n        return cellData;\n    }\n\n    getGridHeaderData(columnIndex: number): string | Element<typeof FormattedMessage> | void {\n        const { fieldsToShow } = this.props;\n\n        if (columnIndex === 0) return undefined;\n        if (columnIndex === FILE_NAME_COLUMN_INDEX) {\n            return <FormattedMessage {...messages.name} />; // \"Name\" column header\n        }\n\n        const responseFields = this.getQueryResponseFields();\n        const field: string | MetadataFieldConfig = fieldsToShow[columnIndex - FIXED_COLUMNS_NUMBER];\n        const key = isString(field) ? field : field.key;\n\n        // Derive displayName in following order:\n        // 1. fieldsToShow prop ||\n        // 2. metadata template instance ||\n        // 3. field key\n        const displayName =\n            getProp(field, 'displayName') || getProp(find(responseFields, ['key', key]), 'displayName', key);\n\n        return displayName;\n    }\n\n    cellRenderer = ({ columnIndex, rowIndex, key, style }: CellRendererArgs): Element<'div'> => {\n        const { hoveredRowIndex } = this.state;\n        const isHeaderRow = rowIndex === HEADER_ROW_INDEX;\n        const isFileIconCell = !isHeaderRow && columnIndex === FILE_ICON_COLUMN_INDEX;\n        const isFileNameCell = !isHeaderRow && columnIndex === FILE_NAME_COLUMN_INDEX;\n        const isGridRowHovered = !isHeaderRow && rowIndex === hoveredRowIndex;\n\n        const data = isHeaderRow ? this.getGridHeaderData(columnIndex) : this.getGridCellData(columnIndex, rowIndex);\n\n        const classes = classNames('bdl-MetadataBasedItemList-cell', {\n            'bdl-MetadataBasedItemList-cell--fileIcon': isFileIconCell,\n            'bdl-MetadataBasedItemList-cell--filename': isFileNameCell,\n            'bdl-MetadataBasedItemList-cell--hover': isGridRowHovered,\n        });\n\n        return (\n            <div\n                className={classes}\n                key={key}\n                onMouseEnter={() => this.handleMouseEnter(columnIndex, rowIndex)}\n                onMouseLeave={this.handleMouseLeave}\n                style={style}\n            >\n                {data}\n            </div>\n        );\n    };\n\n    getScrollPositionClasses(width: number): ScrollPositionClasses {\n        const { scrollLeftOffset, scrollRightOffset } = this.state;\n        const isViewScrolledLeft = this.calculateContentWidth() > width && scrollRightOffset > 0;\n        const isViewScrolledRight = scrollLeftOffset > 0;\n        const isViewScrolledInMiddle = isViewScrolledLeft && isViewScrolledRight;\n\n        return {\n            'is-scrolledLeft': isViewScrolledLeft && !isViewScrolledInMiddle, // content scrolled all the way to the left\n            'is-scrolledRight': isViewScrolledRight && !isViewScrolledInMiddle, // content scrolled all the way to the right\n            'is-scrolledMiddle': isViewScrolledInMiddle, // content scrolled somewhere in between\n        };\n    }\n\n    calculateContentWidth(): number {\n        const { fieldsToShow } = this.props;\n        // total width = sum of widths of sticky & non-sticky columns\n        return FILE_ICON_COLUMN_WIDTH + FILE_NAME_COLUMN_WIDTH + fieldsToShow.length * MIN_METADATA_COLUMN_WIDTH;\n    }\n\n    render() {\n        const { currentCollection, fieldsToShow }: Props = this.props;\n        const rowCount = currentCollection.items ? currentCollection.items.length : 0;\n\n        return (\n            <AutoSizer>\n                {({ width, height }) => {\n                    const scrollClasses = this.getScrollPositionClasses(width);\n                    const classesTopRightGrid = classNames('bdl-MetadataBasedItemList-topRightGrid', scrollClasses);\n                    const classesBottomRightGrid = classNames(\n                        'bdl-MetadataBasedItemList-bottomRightGrid',\n                        scrollClasses,\n                    );\n                    return (\n                        <div className=\"bdl-MetadataBasedItemList\">\n                            <MultiGrid\n                                cellRenderer={this.cellRenderer}\n                                classNameBottomRightGrid={classesBottomRightGrid}\n                                classNameTopRightGrid={classesTopRightGrid}\n                                columnCount={fieldsToShow.length + FIXED_COLUMNS_NUMBER}\n                                columnWidth={this.getColumnWidth(width)}\n                                fixedColumnCount={FIXED_COLUMNS_NUMBER}\n                                fixedRowCount={FIXED_ROW_NUMBER}\n                                height={height}\n                                hideBottomLeftGridScrollbar\n                                hideTopRightGridScrollbar\n                                rowCount={rowCount + FIXED_ROW_NUMBER}\n                                rowHeight={50}\n                                width={width}\n                                onScroll={this.handleContentScroll}\n                            />\n                        </div>\n                    );\n                }}\n            </AutoSizer>\n        );\n    }\n}\n\nexport default MetadataBasedItemList;\n"]},"metadata":{},"sourceType":"module"}