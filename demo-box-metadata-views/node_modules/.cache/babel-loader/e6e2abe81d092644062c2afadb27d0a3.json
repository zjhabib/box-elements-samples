{"ast":null,"code":"/**\n * \n * @file Function utilities\n * @author Box\n */\n\n/**\n * Wrapper around the promises.create() method to allow a promise to retry\n * multiple times. A third parameter (besides resolve and reject) is passed\n * that allows the function to cancel retrying and immediately reject.\n *\n * @param {function} func - The function that performs the operation as a promise.\n * @param {number} times - Maximum number of times the operation should be attempted.\n * @param {number} [initialTimeout] - Optional timeout to retry the promise with after it fails, in milliseconds.\n * Otherwise, the input `func` is invoked after 1 event loop.\n * @param {number} [backoffFactor] - Optional exponential backoff factor to retry the promise with after it fails\n * @return {Promise} Promise - proxies the promise of the passed function.\n */\nfunction retryNumOfTimes(func, times) {\n  var initialTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var backoffFactor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n  var tries = 0;\n  var timeout = initialTimeout;\n  return new Promise(function (resolve, hardReject) {\n    function doTry() {\n      tries += 1;\n      new Promise(function (tryResolve, tryReject) {\n        func(tryResolve, tryReject, hardReject);\n      }).then(resolve).catch(function (reason) {\n        if (tries < times) {\n          timeout *= backoffFactor; // eslint-disable-next-line no-use-before-define\n\n          executeAfterTimeout(timeout);\n          return;\n        }\n        hardReject(reason);\n      });\n    }\n    function executeAfterTimeout(time) {\n      setTimeout(function () {\n        doTry();\n      }, time);\n    }\n    executeAfterTimeout(timeout);\n  });\n} // eslint-disable-next-line import/prefer-default-export\n\nexport { retryNumOfTimes };","map":{"version":3,"sources":["../../src/utils/function.js"],"names":["retryNumOfTimes","func","times","initialTimeout","backoffFactor","tries","timeout","Promise","resolve","hardReject","doTry","tryResolve","tryReject","then","catch","executeAfterTimeout","reason","time","setTimeout"],"mappings":"AAAA;;;;;;AAMA;;;;;;;;;;;;AAaA,SAASA,eAAT,CACIC,IADJ,EAEIC,KAFJ,EAKgB;EAAA,IAFZC,cAEY,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAFc,CAEd;EAAA,IADZC,aACY,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADa,CACb;EACZ,IAAIC,KAAK,GAAG,CAAZ;EACA,IAAIC,OAAO,GAAGH,cAAd;EAEA,OAAO,IAAII,OAAJ,CAAY,UAACC,OAAD,EAAUC,UAAV,EAAyB;IACxC,SAASC,KAAT,CAAA,EAAiB;MACbL,KAAK,IAAI,CAATA;MAEA,IAAIE,OAAJ,CAAY,UAACI,UAAD,EAAaC,SAAb,EAA2B;QACnCX,IAAI,CAACU,UAAD,EAAaC,SAAb,EAAwBH,UAAxB,CAAJR;MACH,CAFD,CAAA,CAGKY,IAHL,CAGUL,OAHV,CAAA,CAIKM,KAJL,CAIW,UAAA,MAAM,EAAI;QACb,IAAIT,KAAK,GAAGH,KAAZ,EAAmB;UACfI,OAAO,IAAIF,aAAXE,CADe,CAEf;;UACAS,mBAAmB,CAACT,OAAD,CAAnBS;UACA;QACH;QAEDN,UAAU,CAACO,MAAD,CAAVP;MACH,CAbL,CAAA;IAcH;IAED,SAASM,mBAAT,CAA6BE,IAA7B,EAAmC;MAC/BC,UAAU,CAAC,YAAM;QACbR,KAAK,CAAA,CAAA;MACR,CAFS,EAEPO,IAFO,CAAVC;IAGH;IAEDH,mBAAmB,CAACT,OAAD,CAAnBS;EACH,CA3BM,CAAP;AA4BH,C,CAED;;AACA,SAASf,eAAT","sourcesContent":["/**\n * @flow\n * @file Function utilities\n * @author Box\n */\n\n/**\n * Wrapper around the promises.create() method to allow a promise to retry\n * multiple times. A third parameter (besides resolve and reject) is passed\n * that allows the function to cancel retrying and immediately reject.\n *\n * @param {function} func - The function that performs the operation as a promise.\n * @param {number} times - Maximum number of times the operation should be attempted.\n * @param {number} [initialTimeout] - Optional timeout to retry the promise with after it fails, in milliseconds.\n * Otherwise, the input `func` is invoked after 1 event loop.\n * @param {number} [backoffFactor] - Optional exponential backoff factor to retry the promise with after it fails\n * @return {Promise} Promise - proxies the promise of the passed function.\n */\n\nfunction retryNumOfTimes(\n    func: Function,\n    times: number,\n    initialTimeout?: number = 0,\n    backoffFactor?: number = 1,\n): Promise<any> {\n    let tries = 0;\n    let timeout = initialTimeout;\n\n    return new Promise((resolve, hardReject) => {\n        function doTry() {\n            tries += 1;\n\n            new Promise((tryResolve, tryReject) => {\n                func(tryResolve, tryReject, hardReject);\n            })\n                .then(resolve)\n                .catch(reason => {\n                    if (tries < times) {\n                        timeout *= backoffFactor;\n                        // eslint-disable-next-line no-use-before-define\n                        executeAfterTimeout(timeout);\n                        return;\n                    }\n\n                    hardReject(reason);\n                });\n        }\n\n        function executeAfterTimeout(time) {\n            setTimeout(() => {\n                doTry();\n            }, time);\n        }\n\n        executeAfterTimeout(timeout);\n    });\n}\n\n// eslint-disable-next-line import/prefer-default-export\nexport { retryNumOfTimes };\n"]},"metadata":{},"sourceType":"module"}