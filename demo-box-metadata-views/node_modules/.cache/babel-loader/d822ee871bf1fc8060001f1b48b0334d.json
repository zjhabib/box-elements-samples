{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file File Keywords SkillCard component\n * @author Box\n */\nimport React, { PureComponent } from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport classNames from 'classnames';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\nimport IconEdit from '../../../../icons/general/IconEdit';\nimport LoadingIndicatorWrapper from '../../../../components/loading-indicator/LoadingIndicatorWrapper';\nimport InlineError from '../../../../components/inline-error/InlineError';\nimport Tooltip from '../../../../components/tooltip/Tooltip';\nimport messages from '../../../common/messages';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport EditableKeywords from './EditableKeywords';\nimport ReadOnlyKeywords from './ReadOnlyKeywords';\nimport './Keywords.scss';\nvar Keywords = /*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(Keywords, _PureComponent);\n\n  /**\n   * [constructor]\n   *\n   * @public\n   * @return {Keywords}\n   */\n  function Keywords(props) {\n    var _this;\n    _classCallCheck(this, Keywords);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Keywords).call(this, props));\n    _defineProperty(_assertThisInitialized(_this), \"toggleIsEditing\", function () {\n      _this.setState(function (prevState) {\n        return {\n          isEditing: !prevState.isEditing\n        };\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onAdd\", function (keyword) {\n      var transcript = _this.props.transcript;\n      var adds = _this.state.adds;\n      var locations = [];\n      var regex = new RegExp(\"\\\\b\".concat(keyword.text, \"\\\\b\"), 'i');\n      if (transcript && Array.isArray(transcript.entries)) {\n        transcript.entries.forEach(function (_ref) {\n          var text = _ref.text,\n            appears = _ref.appears;\n          if (text && regex.test(text) && Array.isArray(appears) && appears.length > 0) {\n            locations.push(appears[0]);\n          }\n        });\n      }\n      keyword.appears = locations;\n      adds.push(keyword);\n      _this.setState({\n        adds: adds.slice(0)\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onDelete\", function (keyword) {\n      var _this$state = _this.state,\n        adds = _this$state.adds,\n        removes = _this$state.removes;\n      var addedIndex = adds.findIndex(function (added) {\n        return added === keyword;\n      });\n      if (addedIndex > -1) {\n        adds.splice(addedIndex, 1);\n        _this.setState({\n          adds: adds.slice(0)\n        });\n      } else {\n        removes.push(keyword);\n        _this.setState({\n          removes: removes.slice(0)\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onSave\", function () {\n      var onSkillChange = _this.props.onSkillChange;\n      var _this$state2 = _this.state,\n        removes = _this$state2.removes,\n        adds = _this$state2.adds;\n      _this.toggleIsEditing();\n      if (removes.length > 0 || adds.length > 0) {\n        _this.setState({\n          isLoading: true\n        });\n        onSkillChange(removes, adds);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onCancel\", function () {\n      _this.resetState(_this.props);\n    });\n    _this.state = {\n      keywords: props.card.entries,\n      adds: [],\n      removes: [],\n      isEditing: props.hasError,\n      hasError: props.hasError,\n      isLoading: false\n    };\n    return _this;\n  }\n  /**\n   * Helper to reset the state\n   *\n   * @private\n   * @param {Object} props - component props\n   * @return {void}\n   */\n\n  _createClass(Keywords, [{\n    key: \"resetState\",\n    value: function resetState(props) {\n      this.setState({\n        keywords: props.card.entries,\n        adds: [],\n        removes: [],\n        isEditing: false,\n        hasError: false,\n        isLoading: false\n      });\n    }\n    /**\n     * Toggles the edit mode\n     *\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: \"render\",\n    /**\n     * Renders the keywords\n     *\n     * @private\n     * @return {void}\n     */\n    value: function render() {\n      var _this$props = this.props,\n        card = _this$props.card,\n        getViewer = _this$props.getViewer,\n        isEditable = _this$props.isEditable;\n      var duration = card.duration;\n      var _this$state3 = this.state,\n        isEditing = _this$state3.isEditing,\n        isLoading = _this$state3.isLoading,\n        hasError = _this$state3.hasError,\n        keywords = _this$state3.keywords,\n        removes = _this$state3.removes,\n        adds = _this$state3.adds;\n      var hasKeywords = keywords.length > 0;\n      var entries = keywords.filter(function (face) {\n        return !removes.includes(face);\n      }).concat(adds);\n      var editClassName = classNames('be-keyword-edit', {\n        'be-keyword-is-editing': isEditing\n      });\n      return React.createElement(LoadingIndicatorWrapper, {\n        className: \"be-keywords\",\n        isLoading: isLoading\n      }, hasKeywords && isEditable && !isLoading && React.createElement(Tooltip, {\n        text: React.createElement(FormattedMessage, messages.editLabel)\n      }, React.createElement(PlainButton, {\n        className: editClassName,\n        \"data-resin-target\": SKILLS_TARGETS.KEYWORDS.EDIT,\n        onClick: this.toggleIsEditing,\n        type: \"button\"\n      }, React.createElement(IconEdit, null))), hasError && React.createElement(InlineError, {\n        title: React.createElement(FormattedMessage, messages.sidebarSkillsErrorTitle)\n      }, React.createElement(FormattedMessage, messages.sidebarSkillsErrorContent)), isEditing && React.createElement(EditableKeywords, {\n        keywords: entries,\n        onAdd: this.onAdd,\n        onCancel: this.onCancel,\n        onDelete: this.onDelete,\n        onSave: this.onSave\n      }), !isEditing && hasKeywords && React.createElement(ReadOnlyKeywords, {\n        duration: duration,\n        getViewer: getViewer,\n        keywords: entries\n      }), !isEditing && !hasKeywords && React.createElement(FormattedMessage, messages.skillNoInfoFoundError));\n    }\n  }]);\n  return Keywords;\n}(PureComponent);\nexport default Keywords;","map":{"version":3,"sources":["../../../../../src/elements/content-sidebar/skills/keywords/Keywords.js"],"names":["React","PureComponent","FormattedMessage","classNames","PlainButton","IconEdit","LoadingIndicatorWrapper","InlineError","Tooltip","messages","SKILLS_TARGETS","EditableKeywords","ReadOnlyKeywords","Keywords","props","state","keywords","card","entries","adds","removes","isEditing","hasError","isLoading","setState","prevState","keyword","transcript","locations","regex","RegExp","text","Array","isArray","forEach","appears","test","length","push","slice","addedIndex","findIndex","added","splice","onSkillChange","toggleIsEditing","resetState","getViewer","isEditable","duration","hasKeywords","filter","face","includes","concat","editClassName","editLabel","KEYWORDS","EDIT","sidebarSkillsErrorTitle","sidebarSkillsErrorContent","onAdd","onCancel","onDelete","onSave","skillNoInfoFoundError"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file File Keywords SkillCard component\n * @author Box\n */\n\nimport React, { PureComponent } from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport classNames from 'classnames';\nimport PlainButton from '../../../../components/plain-button/PlainButton';\nimport IconEdit from '../../../../icons/general/IconEdit';\nimport LoadingIndicatorWrapper from '../../../../components/loading-indicator/LoadingIndicatorWrapper';\nimport InlineError from '../../../../components/inline-error/InlineError';\nimport Tooltip from '../../../../components/tooltip/Tooltip';\nimport messages from '../../../common/messages';\nimport { SKILLS_TARGETS } from '../../../common/interactionTargets';\nimport EditableKeywords from './EditableKeywords';\nimport ReadOnlyKeywords from './ReadOnlyKeywords';\nimport type { SkillCardEntry, SkillCard } from '../../../../common/types/skills';\n\nimport './Keywords.scss';\n\ntype Props = {\n    card: SkillCard,\n    getViewer?: Function,\n    hasError: boolean,\n    isEditable: boolean,\n    onSkillChange: Function,\n    transcript?: SkillCard,\n};\n\ntype State = {\n    adds: Array<SkillCardEntry>,\n    hasError: boolean,\n    isEditing: boolean,\n    isLoading: boolean,\n    keywords: Array<SkillCardEntry>,\n    removes: Array<SkillCardEntry>,\n};\n\nclass Keywords extends PureComponent<Props, State> {\n    props: Props;\n\n    state: State;\n\n    /**\n     * [constructor]\n     *\n     * @public\n     * @return {Keywords}\n     */\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            keywords: props.card.entries,\n            adds: [],\n            removes: [],\n            isEditing: props.hasError,\n            hasError: props.hasError,\n            isLoading: false,\n        };\n    }\n\n    /**\n     * Helper to reset the state\n     *\n     * @private\n     * @param {Object} props - component props\n     * @return {void}\n     */\n    resetState(props: Props): void {\n        this.setState({\n            keywords: props.card.entries,\n            adds: [],\n            removes: [],\n            isEditing: false,\n            hasError: false,\n            isLoading: false,\n        });\n    }\n\n    /**\n     * Toggles the edit mode\n     *\n     * @private\n     * @return {void}\n     */\n    toggleIsEditing = (): void => {\n        this.setState(prevState => ({\n            isEditing: !prevState.isEditing,\n        }));\n    };\n\n    /**\n     * Adds a new keyword.\n     * Iterates over the transcript to find locations\n     *\n     * @private\n     * @return {void}\n     */\n    onAdd = (keyword: SkillCardEntry): void => {\n        const { transcript }: Props = this.props;\n        const { adds } = this.state;\n        const locations = [];\n        const regex = new RegExp(`\\\\b${((keyword.text: any): string)}\\\\b`, 'i');\n\n        if (transcript && Array.isArray(transcript.entries)) {\n            transcript.entries.forEach(({ text, appears }: SkillCardEntry): void => {\n                if (text && regex.test(text) && Array.isArray(appears) && appears.length > 0) {\n                    locations.push(appears[0]);\n                }\n            });\n        }\n\n        keyword.appears = locations;\n        adds.push(keyword);\n        this.setState({ adds: adds.slice(0) });\n    };\n\n    /**\n     * Deletes a keyword\n     *\n     * @private\n     * @return {void}\n     */\n    onDelete = (keyword: SkillCardEntry): void => {\n        const { adds, removes } = this.state;\n        const addedIndex = adds.findIndex(added => added === keyword);\n        if (addedIndex > -1) {\n            adds.splice(addedIndex, 1);\n            this.setState({ adds: adds.slice(0) });\n        } else {\n            removes.push(keyword);\n            this.setState({ removes: removes.slice(0) });\n        }\n    };\n\n    /**\n     * Saves the new card data\n     *\n     * @private\n     * @return {void}\n     */\n    onSave = (): void => {\n        const { onSkillChange }: Props = this.props;\n        const { removes, adds }: State = this.state;\n        this.toggleIsEditing();\n        if (removes.length > 0 || adds.length > 0) {\n            this.setState({ isLoading: true });\n            onSkillChange(removes, adds);\n        }\n    };\n\n    /**\n     * Cancels editing\n     *\n     * @private\n     * @return {void}\n     */\n    onCancel = (): void => {\n        this.resetState(this.props);\n    };\n\n    /**\n     * Renders the keywords\n     *\n     * @private\n     * @return {void}\n     */\n    render() {\n        const { card, getViewer, isEditable }: Props = this.props;\n        const { duration }: SkillCard = card;\n        const { isEditing, isLoading, hasError, keywords, removes, adds }: State = this.state;\n        const hasKeywords = keywords.length > 0;\n        const entries = keywords.filter((face: SkillCardEntry) => !removes.includes(face)).concat(adds);\n        const editClassName = classNames('be-keyword-edit', {\n            'be-keyword-is-editing': isEditing,\n        });\n\n        return (\n            <LoadingIndicatorWrapper className=\"be-keywords\" isLoading={isLoading}>\n                {hasKeywords && isEditable && !isLoading && (\n                    <Tooltip text={<FormattedMessage {...messages.editLabel} />}>\n                        <PlainButton\n                            className={editClassName}\n                            data-resin-target={SKILLS_TARGETS.KEYWORDS.EDIT}\n                            onClick={this.toggleIsEditing}\n                            type=\"button\"\n                        >\n                            <IconEdit />\n                        </PlainButton>\n                    </Tooltip>\n                )}\n                {hasError && (\n                    <InlineError title={<FormattedMessage {...messages.sidebarSkillsErrorTitle} />}>\n                        <FormattedMessage {...messages.sidebarSkillsErrorContent} />\n                    </InlineError>\n                )}\n                {isEditing && (\n                    <EditableKeywords\n                        keywords={entries}\n                        onAdd={this.onAdd}\n                        onCancel={this.onCancel}\n                        onDelete={this.onDelete}\n                        onSave={this.onSave}\n                    />\n                )}\n                {!isEditing && hasKeywords && (\n                    <ReadOnlyKeywords duration={duration} getViewer={getViewer} keywords={entries} />\n                )}\n                {!isEditing && !hasKeywords && <FormattedMessage {...messages.skillNoInfoFoundError} />}\n            </LoadingIndicatorWrapper>\n        );\n    }\n}\n\nexport default Keywords;\n"]},"metadata":{},"sourceType":"module"}