{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nvar isHidden = function isHidden(obj) {\n  return !!obj.isHidden || !!obj.hidden;\n};\n/**\n * Utility function for converting a string or array of strings into a Set object\n * @param templateFilters - Array<string> | string\n * @returns {Set<T>}\n */\n\nvar normalizeTemplateFilters = function normalizeTemplateFilters(templateFilters) {\n  return typeof templateFilters === 'string' ? new Set([templateFilters]) : new Set(templateFilters);\n};\n/**\n * Utility function for cloning an array of metadata templates and filtering the templates and fields if necessary\n * @param templates Array<MetadataTemplate>\n * @param selectedTemplateKey - string\n * @param templateFilters - Array<string> | string\n * @returns {Array<T>}\n */\n\nvar normalizeTemplates = function normalizeTemplates(templates, selectedTemplateKey, templateFilters) {\n  if (!selectedTemplateKey) {\n    return _toConsumableArray(templates);\n  }\n  var clonedTemplates = templates.filter(function (template) {\n    return template.templateKey === selectedTemplateKey;\n  });\n  var fields = clonedTemplates[0] ? clonedTemplates[0].fields : null;\n  if (templateFilters && fields) {\n    var normalizedFilters = normalizeTemplateFilters(templateFilters);\n    clonedTemplates[0].fields = fields.filter(function (field) {\n      return normalizedFilters.has(field.id);\n    });\n  }\n  return clonedTemplates;\n};\nexport { isHidden, normalizeTemplates, normalizeTemplateFilters };","map":{"version":3,"sources":["../../../src/features/metadata-instance-editor/metadataUtil.js"],"names":["isHidden","obj","hidden","normalizeTemplateFilters","templateFilters","Set","normalizeTemplates","templates","selectedTemplateKey","clonedTemplates","filter","template","templateKey","fields","normalizedFilters","has","field","id"],"mappings":";;;;;;;;;;;;;;;;;AAGA,IAAMA,QAAQ,GAAG,SAAXA,QAAW,CAACC,GAAD,EAA4D;EACzE,OAAO,CAAC,CAACA,GAAG,CAACD,QAAN,IAAkB,CAAC,CAACC,GAAG,CAACC,MAA/B;AACH,CAFD;AAIA;;;;;;AAKA,IAAMC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACC,eAAD,EAA0D;EACvF,OAAO,OAAOA,eAAP,KAA2B,QAA3B,GAAsC,IAAIC,GAAJ,CAAQ,CAACD,eAAD,CAAR,CAAtC,GAAmE,IAAIC,GAAJ,CAAQD,eAAR,CAA1E;AACH,CAFD;AAIA;;;;;;;;AAOA,IAAME,kBAAkB,GAAG,SAArBA,kBAAqB,CACvBC,SADuB,EAEvBC,mBAFuB,EAGvBJ,eAHuB,EAIG;EAC1B,IAAI,CAACI,mBAAL,EAA0B;IACtB,OAAA,kBAAA,CAAWD,SAAX,CAAA;EACH;EACD,IAAME,eAAe,GAAG,SAAS,CAACC,MAAV,CAAiB,UAAA,QAAQ,EAAA;IAAA,OAAIC,QAAQ,CAACC,WAATD,KAAyBH,mBAA7B;EAAA,CAAzB,CAAxB;EACA,IAAMK,MAAM,GAAGJ,eAAe,CAAC,CAAD,CAAfA,GAAqBA,eAAe,CAAC,CAAD,CAAfA,CAAmBI,MAAxCJ,GAAiD,IAAhE;EACA,IAAIL,eAAe,IAAIS,MAAvB,EAA+B;IAC3B,IAAMC,iBAAiB,GAAGX,wBAAwB,CAACC,eAAD,CAAlD;IACAK,eAAe,CAAC,CAAD,CAAfA,CAAmBI,MAAnBJ,GAA4B,MAAM,CAACC,MAAP,CAAc,UAAA,KAAK,EAAA;MAAA,OAAII,iBAAiB,CAACC,GAAlBD,CAAsBE,KAAK,CAACC,EAA5BH,CAAJ;IAAA,CAAnB,CAA5BL;EACH;EACD,OAAOA,eAAP;AACH,CAfD;AAiBA,SAAST,QAAT,EAAmBM,kBAAnB,EAAuCH,wBAAvC","sourcesContent":["// @flow\nimport type { MetadataTemplateField, MetadataTemplate } from '../../common/types/metadata';\n\nconst isHidden = (obj: MetadataTemplate | MetadataTemplateField): boolean => {\n    return !!obj.isHidden || !!obj.hidden;\n};\n\n/**\n * Utility function for converting a string or array of strings into a Set object\n * @param templateFilters - Array<string> | string\n * @returns {Set<T>}\n */\nconst normalizeTemplateFilters = (templateFilters: Array<string> | string): Set<string> => {\n    return typeof templateFilters === 'string' ? new Set([templateFilters]) : new Set(templateFilters);\n};\n\n/**\n * Utility function for cloning an array of metadata templates and filtering the templates and fields if necessary\n * @param templates Array<MetadataTemplate>\n * @param selectedTemplateKey - string\n * @param templateFilters - Array<string> | string\n * @returns {Array<T>}\n */\nconst normalizeTemplates = (\n    templates: Array<MetadataTemplate>,\n    selectedTemplateKey?: string,\n    templateFilters?: Array<string> | string,\n): Array<MetadataTemplate> => {\n    if (!selectedTemplateKey) {\n        return [...templates];\n    }\n    const clonedTemplates = templates.filter(template => template.templateKey === selectedTemplateKey);\n    const fields = clonedTemplates[0] ? clonedTemplates[0].fields : null;\n    if (templateFilters && fields) {\n        const normalizedFilters = normalizeTemplateFilters(templateFilters);\n        clonedTemplates[0].fields = fields.filter(field => normalizedFilters.has(field.id));\n    }\n    return clonedTemplates;\n};\n\nexport { isHidden, normalizeTemplates, normalizeTemplateFilters };\n"]},"metadata":{},"sourceType":"module"}