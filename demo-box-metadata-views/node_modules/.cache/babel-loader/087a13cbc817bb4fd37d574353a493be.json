{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Network utilities\n * @author Box\n */\nimport axios from 'axios';\nimport getProp from 'lodash/get';\nimport includes from 'lodash/includes';\nimport lowerCase from 'lodash/lowerCase';\nimport TokenService from './TokenService';\nimport { HEADER_ACCEPT, HEADER_ACCEPT_LANGUAGE, HEADER_CLIENT_NAME, HEADER_CLIENT_VERSION, HEADER_CONTENT_TYPE, HTTP_GET, HTTP_POST, HTTP_PUT, HTTP_DELETE, HTTP_OPTIONS, HTTP_HEAD, HTTP_STATUS_CODE_RATE_LIMIT } from '../constants';\nvar DEFAULT_UPLOAD_TIMEOUT_MS = 120000;\nvar MAX_NUM_RETRIES = 3;\nvar RETRYABLE_HTTP_METHODS = [HTTP_GET, HTTP_OPTIONS, HTTP_HEAD].map(lowerCase);\nvar Xhr = /*#__PURE__*/\nfunction () {\n  /**\n   * [constructor]\n   *\n   * @param {Object} options\n   * @param {string} options.id - item id\n   * @param {string} options.clientName - Client Name\n   * @param {string|function} options.token - Auth token\n   * @param {string} [options.language] - Accept-Language header value\n   * @param {string} [options.sharedLink] - Shared link\n   * @param {string} [options.sharedLinkPassword] - Shared link password\n   * @param {string} [options.requestInterceptor] - Request interceptor\n   * @param {string} [options.responseInterceptor] - Response interceptor\n   * @param {number[]} [options.retryableStatusCodes] - Response codes to retry\n   * @param {boolean} [options.shouldRetry] - Should retry failed requests\n   * @return {Xhr} Cache instance\n   */\n  function Xhr() {\n    var _this = this;\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      id = _ref.id,\n      clientName = _ref.clientName,\n      language = _ref.language,\n      token = _ref.token,\n      version = _ref.version,\n      sharedLink = _ref.sharedLink,\n      sharedLinkPassword = _ref.sharedLinkPassword,\n      responseInterceptor = _ref.responseInterceptor,\n      requestInterceptor = _ref.requestInterceptor,\n      _ref$retryableStatusC = _ref.retryableStatusCodes,\n      retryableStatusCodes = _ref$retryableStatusC === void 0 ? [HTTP_STATUS_CODE_RATE_LIMIT] : _ref$retryableStatusC,\n      _ref$shouldRetry = _ref.shouldRetry,\n      _shouldRetry = _ref$shouldRetry === void 0 ? true : _ref$shouldRetry;\n    _classCallCheck(this, Xhr);\n    _defineProperty(this, \"retryCount\", 0);\n    _defineProperty(this, \"errorInterceptor\", function (error) {\n      var shouldRetry = _this.shouldRetryRequest(error);\n      if (shouldRetry) {\n        _this.retryCount += 1;\n        var delay = _this.getExponentialRetryTimeoutInMs(_this.retryCount);\n        return new Promise(function (resolve, reject) {\n          _this.retryTimeout = setTimeout(function () {\n            _this.axios(error.config).then(resolve, reject);\n          }, delay);\n        });\n      }\n      var errorObject = getProp(error, 'response.data') || error; // In the case of 401, response.data is empty so fall back to error\n\n      _this.responseInterceptor(errorObject);\n      return Promise.reject(error);\n    });\n    this.clientName = clientName;\n    this.id = id;\n    this.language = language;\n    this.responseInterceptor = responseInterceptor || this.defaultResponseInterceptor;\n    this.retryableStatusCodes = retryableStatusCodes;\n    this.sharedLink = sharedLink;\n    this.sharedLinkPassword = sharedLinkPassword;\n    this.shouldRetry = _shouldRetry;\n    this.token = token;\n    this.version = version;\n    this.axios = axios.create();\n    this.axiosSource = axios.CancelToken.source();\n    this.axios.interceptors.response.use(this.responseInterceptor, this.errorInterceptor);\n    if (typeof requestInterceptor === 'function') {\n      this.axios.interceptors.request.use(requestInterceptor);\n    }\n  }\n  /**\n   * Default response interceptor which just returns the response\n   *\n   * @param {Object} response - the axios response\n   * @return the response\n   */\n\n  _createClass(Xhr, [{\n    key: \"defaultResponseInterceptor\",\n    value: function defaultResponseInterceptor(response) {\n      return response;\n    }\n    /**\n     * Determines if a request should be retried\n     *\n     * @param {Object} error - Error object from axios\n     * @return {boolean} true if the request should be retried\n     */\n  }, {\n    key: \"shouldRetryRequest\",\n    value: function shouldRetryRequest(error) {\n      if (!this.shouldRetry || this.retryCount >= MAX_NUM_RETRIES) {\n        return false;\n      }\n      var response = error.response,\n        request = error.request,\n        config = error.config; // Retry if there is a network error (e.g. ECONNRESET) or rate limited\n\n      var status = getProp(response, 'status');\n      var method = getProp(config, 'method');\n      var isNetworkError = request && !response;\n      var isRateLimitError = status === HTTP_STATUS_CODE_RATE_LIMIT;\n      var isOtherRetryableError = includes(this.retryableStatusCodes, status) && includes(RETRYABLE_HTTP_METHODS, method);\n      return isNetworkError || isRateLimitError || isOtherRetryableError;\n    }\n    /**\n     * Calculate the exponential backoff time with randomized jitter.\n     *\n     * @param {number} numRetries Which retry number this one will be. Must be > 0\n     * @returns {number} The number of milliseconds after which to retry\n     */\n  }, {\n    key: \"getExponentialRetryTimeoutInMs\",\n    value: function getExponentialRetryTimeoutInMs(numRetries) {\n      var randomizationMs = Math.ceil(Math.random() * 1000);\n      var exponentialMs = Math.pow(2, numRetries - 1) * 1000;\n      return exponentialMs + randomizationMs;\n    }\n    /**\n     * Error interceptor that wraps the passed in responseInterceptor\n     *\n     * @param {Object} error - Error object from axios\n     * @return {Promise} rejected promise with error info\n     */\n  }, {\n    key: \"getParsedUrl\",\n    /**\n     * Utility to parse a URL.\n     *\n     * @param {string} url - Url to parse\n     * @return {Object} parsed url\n     */\n    value: function getParsedUrl(url) {\n      var a = document.createElement('a');\n      a.href = url;\n      return {\n        api: url.replace(\"\".concat(a.origin, \"/2.0\"), ''),\n        host: a.host,\n        hostname: a.hostname,\n        pathname: a.pathname,\n        origin: a.origin,\n        protocol: a.protocol,\n        hash: a.hash,\n        port: a.port\n      };\n    }\n    /**\n     * Builds a list of required XHR headers.\n     *\n     * @param {string} [id] - Optional box item id\n     * @param {Object} [args] - Optional existing headers\n     * @return {Object} Headers\n     */\n  }, {\n    key: \"getHeaders\",\n    value: function () {\n      var _getHeaders = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(id) {\n        var args,\n          headers,\n          itemId,\n          token,\n          _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                args = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                headers = _objectSpread(_defineProperty({\n                  Accept: 'application/json'\n                }, HEADER_CONTENT_TYPE, 'application/json'), args);\n                if (this.language && !headers[HEADER_ACCEPT_LANGUAGE]) {\n                  headers[HEADER_ACCEPT_LANGUAGE] = this.language;\n                }\n                if (this.sharedLink) {\n                  headers.BoxApi = \"shared_link=\".concat(this.sharedLink);\n                  if (this.sharedLinkPassword) {\n                    headers.BoxApi = \"\".concat(headers.BoxApi, \"&shared_link_password=\").concat(this.sharedLinkPassword);\n                  }\n                }\n                if (this.clientName) {\n                  headers[HEADER_CLIENT_NAME] = this.clientName;\n                }\n                if (this.version) {\n                  headers[HEADER_CLIENT_VERSION] = this.version;\n                } // If id is passed in, use that, otherwise default to this.id\n\n                itemId = id || this.id || '';\n                _context.next = 9;\n                return TokenService.getWriteToken(itemId, this.token);\n              case 9:\n                token = _context.sent;\n                if (token) {\n                  // Only add a token when there was one found\n                  headers.Authorization = \"Bearer \".concat(token);\n                }\n                return _context.abrupt(\"return\", headers);\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getHeaders(_x) {\n        return _getHeaders.apply(this, arguments);\n      }\n      return getHeaders;\n    }()\n    /**\n     * HTTP GETs a URL\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {Object} [params] - Key-value map of querystring params\n     * @return {Promise} - HTTP response\n     */\n  }, {\n    key: \"get\",\n    value: function get(_ref2) {\n      var _this2 = this;\n      var url = _ref2.url,\n        id = _ref2.id,\n        _ref2$params = _ref2.params,\n        params = _ref2$params === void 0 ? {} : _ref2$params,\n        _ref2$headers = _ref2.headers,\n        headers = _ref2$headers === void 0 ? {} : _ref2$headers;\n      return this.getHeaders(id, headers).then(function (hdrs) {\n        return _this2.axios.get(url, {\n          cancelToken: _this2.axiosSource.token,\n          params: params,\n          headers: hdrs,\n          parsedUrl: _this2.getParsedUrl(url)\n        });\n      });\n    }\n    /**\n     * HTTP POSTs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} params - Optional query params for the request\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {string} [method] - xhr type\n     * @return {Promise} - HTTP response\n     */\n  }, {\n    key: \"post\",\n    value: function post(_ref3) {\n      var _this3 = this;\n      var url = _ref3.url,\n        id = _ref3.id,\n        data = _ref3.data,\n        params = _ref3.params,\n        _ref3$headers = _ref3.headers,\n        headers = _ref3$headers === void 0 ? {} : _ref3$headers,\n        _ref3$method = _ref3.method,\n        method = _ref3$method === void 0 ? HTTP_POST : _ref3$method;\n      return this.getHeaders(id, headers).then(function (hdrs) {\n        return _this3.axios({\n          url: url,\n          data: data,\n          params: params,\n          method: method,\n          parsedUrl: _this3.getParsedUrl(url),\n          headers: hdrs\n        });\n      });\n    }\n    /**\n     * HTTP PUTs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} params - Optional query params for the request\n     * @param {Object} [headers] - Key-value map of headers\n     * @return {Promise} - HTTP response\n     */\n  }, {\n    key: \"put\",\n    value: function put(_ref4) {\n      var url = _ref4.url,\n        id = _ref4.id,\n        data = _ref4.data,\n        params = _ref4.params,\n        _ref4$headers = _ref4.headers,\n        headers = _ref4$headers === void 0 ? {} : _ref4$headers;\n      return this.post({\n        id: id,\n        url: url,\n        data: data,\n        params: params,\n        headers: headers,\n        method: HTTP_PUT\n      });\n    }\n    /**\n     * HTTP DELETEs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} [headers] - Key-value map of headers\n     * @return {Promise} - HTTP response\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(_ref5) {\n      var url = _ref5.url,\n        id = _ref5.id,\n        _ref5$data = _ref5.data,\n        data = _ref5$data === void 0 ? {} : _ref5$data,\n        _ref5$headers = _ref5.headers,\n        headers = _ref5$headers === void 0 ? {} : _ref5$headers;\n      return this.post({\n        id: id,\n        url: url,\n        data: data,\n        headers: headers,\n        method: HTTP_DELETE\n      });\n    }\n    /**\n     * HTTP OPTIONs a URL with JSON data.\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to post to\n     * @param {Object} data - The non-file post data that should accompany the post\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {Function} successHandler - Load success handler\n     * @param {Function} errorHandler - Error handler\n     * @return {void}\n     */\n  }, {\n    key: \"options\",\n    value: function options(_ref6) {\n      var _this4 = this;\n      var id = _ref6.id,\n        url = _ref6.url,\n        data = _ref6.data,\n        _ref6$headers = _ref6.headers,\n        headers = _ref6$headers === void 0 ? {} : _ref6$headers,\n        successHandler = _ref6.successHandler,\n        errorHandler = _ref6.errorHandler;\n      return this.getHeaders(id, headers).then(function (hdrs) {\n        return _this4.axios({\n          url: url,\n          data: data,\n          method: HTTP_OPTIONS,\n          headers: hdrs\n        }).then(successHandler).catch(errorHandler);\n      }).catch(errorHandler);\n    }\n    /**\n     * HTTP POST or PUT a URL with File data. Uses native XHR for progress event.\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to post to\n     * @param {Object} [data] - File data and attributes\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {string} [method] - XHR method, supports 'POST' and 'PUT'\n     * @param {Function} successHandler - Load success handler\n     * @param {Function} errorHandler - Error handler\n     * @param {Function} progressHandler - Progress handler\n     * @param {boolean} [withIdleTimeout] - enable idle timeout\n     * @param {number} [idleTimeoutDuration] - idle timeout duration\n     * @param {Function} [idleTimeoutHandler]\n     * @return {void}\n     */\n  }, {\n    key: \"uploadFile\",\n    value: function uploadFile(_ref7) {\n      var _this5 = this;\n      var id = _ref7.id,\n        url = _ref7.url,\n        data = _ref7.data,\n        _ref7$headers = _ref7.headers,\n        headers = _ref7$headers === void 0 ? {} : _ref7$headers,\n        _ref7$method = _ref7.method,\n        method = _ref7$method === void 0 ? HTTP_POST : _ref7$method,\n        successHandler = _ref7.successHandler,\n        errorHandler = _ref7.errorHandler,\n        progressHandler = _ref7.progressHandler,\n        _ref7$withIdleTimeout = _ref7.withIdleTimeout,\n        withIdleTimeout = _ref7$withIdleTimeout === void 0 ? false : _ref7$withIdleTimeout,\n        _ref7$idleTimeoutDura = _ref7.idleTimeoutDuration,\n        idleTimeoutDuration = _ref7$idleTimeoutDura === void 0 ? DEFAULT_UPLOAD_TIMEOUT_MS : _ref7$idleTimeoutDura,\n        idleTimeoutHandler = _ref7.idleTimeoutHandler;\n      return this.getHeaders(id, headers).then(function (hdrs) {\n        var idleTimeout;\n        var progressHandlerToUse = progressHandler;\n        if (withIdleTimeout) {\n          // Func that aborts upload and executes timeout callback\n          var idleTimeoutFunc = function idleTimeoutFunc() {\n            _this5.abort();\n            if (idleTimeoutHandler) {\n              idleTimeoutHandler();\n            }\n          };\n          idleTimeout = setTimeout(idleTimeoutFunc, idleTimeoutDuration); // Progress handler that aborts upload if there has been no progress for >= timeoutMs\n\n          progressHandlerToUse = function progressHandlerToUse(event) {\n            clearTimeout(idleTimeout);\n            idleTimeout = setTimeout(idleTimeoutFunc, idleTimeoutDuration);\n            progressHandler(event);\n          };\n        }\n        _this5.axios({\n          url: url,\n          data: data,\n          transformRequest: function transformRequest(reqData, reqHeaders) {\n            // Remove Accept & Content-Type added by getHeaders()\n            delete reqHeaders[HEADER_ACCEPT];\n            delete reqHeaders[HEADER_CONTENT_TYPE];\n            if (headers[HEADER_CONTENT_TYPE]) {\n              reqHeaders[HEADER_CONTENT_TYPE] = headers[HEADER_CONTENT_TYPE];\n            } // Convert to FormData if needed\n\n            if (reqData && !(reqData instanceof Blob) && reqData.attributes) {\n              var formData = new FormData();\n              Object.keys(reqData).forEach(function (key) {\n                formData.append(key, reqData[key]);\n              });\n              return formData;\n            }\n            return reqData;\n          },\n          method: method,\n          headers: hdrs,\n          onUploadProgress: progressHandlerToUse,\n          cancelToken: _this5.axiosSource.token\n        }).then(function (response) {\n          clearTimeout(idleTimeout);\n          successHandler(response);\n        }).catch(function (error) {\n          clearTimeout(idleTimeout);\n          errorHandler(error);\n        });\n      }).catch(errorHandler);\n    }\n    /**\n     * Aborts an axios request.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"abort\",\n    value: function abort() {\n      if (this.retryTimeout) {\n        clearTimeout(this.retryTimeout);\n      }\n      if (this.axiosSource) {\n        this.axiosSource.cancel();\n        this.axiosSource = axios.CancelToken.source();\n      }\n    }\n  }]);\n  return Xhr;\n}();\nexport default Xhr;","map":{"version":3,"sources":["../../src/utils/Xhr.js"],"names":["axios","getProp","includes","lowerCase","TokenService","HEADER_ACCEPT","HEADER_ACCEPT_LANGUAGE","HEADER_CLIENT_NAME","HEADER_CLIENT_VERSION","HEADER_CONTENT_TYPE","HTTP_GET","HTTP_POST","HTTP_PUT","HTTP_DELETE","HTTP_OPTIONS","HTTP_HEAD","HTTP_STATUS_CODE_RATE_LIMIT","DEFAULT_UPLOAD_TIMEOUT_MS","MAX_NUM_RETRIES","RETRYABLE_HTTP_METHODS","map","Xhr","id","clientName","language","token","version","sharedLink","sharedLinkPassword","responseInterceptor","requestInterceptor","retryableStatusCodes","shouldRetry","defaultResponseInterceptor","create","axiosSource","CancelToken","source","interceptors","response","use","errorInterceptor","request","error","retryCount","config","status","method","isNetworkError","isRateLimitError","isOtherRetryableError","numRetries","randomizationMs","Math","ceil","random","exponentialMs","shouldRetryRequest","delay","getExponentialRetryTimeoutInMs","Promise","resolve","reject","retryTimeout","setTimeout","then","errorObject","url","a","document","createElement","href","api","replace","origin","host","hostname","pathname","protocol","hash","port","args","headers","Accept","BoxApi","itemId","getWriteToken","Authorization","params","getHeaders","get","cancelToken","hdrs","parsedUrl","getParsedUrl","data","post","successHandler","errorHandler","catch","progressHandler","withIdleTimeout","idleTimeoutDuration","idleTimeoutHandler","idleTimeout","progressHandlerToUse","idleTimeoutFunc","abort","clearTimeout","event","transformRequest","reqData","reqHeaders","Blob","attributes","formData","FormData","Object","keys","forEach","append","key","onUploadProgress","cancel"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAMA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAOC,OAAP,MAAoB,YAApB;AACA,OAAOC,QAAP,MAAqB,iBAArB;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,SACIC,aADJ,EAEIC,sBAFJ,EAGIC,kBAHJ,EAIIC,qBAJJ,EAKIC,mBALJ,EAMIC,QANJ,EAOIC,SAPJ,EAQIC,QARJ,EASIC,WATJ,EAUIC,YAVJ,EAWIC,SAXJ,EAYIC,2BAZJ,QAaO,cAbP;AAiBA,IAAMC,yBAAyB,GAAG,MAAlC;AACA,IAAMC,eAAe,GAAG,CAAxB;AACA,IAAMC,sBAAsB,GAAG,CAACT,QAAD,EAAWI,YAAX,EAAyBC,SAAzB,CAAA,CAAoCK,GAApC,CAAwCjB,SAAxC,CAA/B;IAEMkB,G;;EAmCF;;;;;;;;;;;;;;;;EAgBA,SAAA,GAAA,CAAA,EAYoB;IAAA,IAAA,KAAA,GAAA,IAAA;IAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAJ,CAAA,CAAI;MAXhBC,EAWgB,GAAA,IAAA,CAXhBA,EAWgB;MAVhBC,UAUgB,GAAA,IAAA,CAVhBA,UAUgB;MAThBC,QASgB,GAAA,IAAA,CAThBA,QASgB;MARhBC,KAQgB,GAAA,IAAA,CARhBA,KAQgB;MAPhBC,OAOgB,GAAA,IAAA,CAPhBA,OAOgB;MANhBC,UAMgB,GAAA,IAAA,CANhBA,UAMgB;MALhBC,kBAKgB,GAAA,IAAA,CALhBA,kBAKgB;MAJhBC,mBAIgB,GAAA,IAAA,CAJhBA,mBAIgB;MAHhBC,kBAGgB,GAAA,IAAA,CAHhBA,kBAGgB;MAAA,qBAAA,GAAA,IAAA,CAFhBC,oBAEgB;MAFhBA,oBAEgB,GAAA,qBAAA,KAAA,KAAA,CAAA,GAFO,CAACf,2BAAD,CAEP,GAAA,qBAAA;MAAA,gBAAA,GAAA,IAAA,CADhBgB,WACgB;MADhBA,YACgB,GAAA,gBAAA,KAAA,KAAA,CAAA,GADF,IACE,GAAA,gBAAA;IAAA,eAAA,CAAA,IAAA,EAAA,GAAA,CAAA;IAAA,eAAA,CAAA,IAAA,EAAA,YAAA,EApCC,CAoCD,CAAA;IAAA,eAAA,CAAA,IAAA,EAAA,kBAAA,EAuED,UAACW,KAAD,EAA2C;MAC1D,IAAMX,WAAW,GAAG,KAAI,CAACyB,kBAAL,CAAwBd,KAAxB,CAApB;MACA,IAAIX,WAAJ,EAAiB;QACb,KAAI,CAACY,UAAL,IAAmB,CAAnB;QACA,IAAMc,KAAK,GAAG,KAAI,CAACC,8BAAL,CAAoC,KAAI,CAACf,UAAzC,CAAd;QACA,OAAO,IAAIgB,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;UACpC,KAAI,CAACC,YAAL,GAAoBC,UAAU,CAAC,YAAM;YACjC,KAAI,CAAChE,KAAL,CAAW2C,KAAK,CAACE,MAAjB,CAAA,CAAyBoB,IAAzB,CAA8BJ,OAA9B,EAAuCC,MAAvC,CAAA;UACH,CAF6B,EAE3BJ,KAF2B,CAA9B;QAGH,CAJM,CAAP;MAKH;MAED,IAAMQ,WAAW,GAAGjE,OAAO,CAAC0C,KAAD,EAAQ,eAAR,CAAP1C,IAAmC0C,KAAvD,CAZ0D,CAYI;;MAC9D,KAAI,CAACd,mBAAL,CAAyBqC,WAAzB,CAAA;MAEA,OAAON,OAAO,CAACE,MAARF,CAAejB,KAAfiB,CAAP;IACH,CAvFmB,CAAA;IAChB,IAAA,CAAKrC,UAAL,GAAkBA,UAAlB;IACA,IAAA,CAAKD,EAAL,GAAUA,EAAV;IACA,IAAA,CAAKE,QAAL,GAAgBA,QAAhB;IACA,IAAA,CAAKK,mBAAL,GAA2BA,mBAAmB,IAAI,IAAA,CAAKI,0BAAvD;IACA,IAAA,CAAKF,oBAAL,GAA4BA,oBAA5B;IACA,IAAA,CAAKJ,UAAL,GAAkBA,UAAlB;IACA,IAAA,CAAKC,kBAAL,GAA0BA,kBAA1B;IACA,IAAA,CAAKI,WAAL,GAAmBA,YAAnB;IACA,IAAA,CAAKP,KAAL,GAAaA,KAAb;IACA,IAAA,CAAKC,OAAL,GAAeA,OAAf;IAEA,IAAA,CAAK1B,KAAL,GAAaA,KAAK,CAACkC,MAANlC,CAAAA,CAAb;IACA,IAAA,CAAKmC,WAAL,GAAmBnC,KAAK,CAACoC,WAANpC,CAAkBqC,MAAlBrC,CAAAA,CAAnB;IACA,IAAA,CAAKA,KAAL,CAAWsC,YAAX,CAAwBC,QAAxB,CAAiCC,GAAjC,CAAqC,IAAA,CAAKX,mBAA1C,EAA+D,IAAA,CAAKY,gBAApE,CAAA;IAEA,IAAI,OAAOX,kBAAP,KAA8B,UAAlC,EAA8C;MAC1C,IAAA,CAAK9B,KAAL,CAAWsC,YAAX,CAAwBI,OAAxB,CAAgCF,GAAhC,CAAoCV,kBAApC,CAAA;IACH;EACJ;EAED;;;;;;;;;+CAM2BS,Q,EAA0B;MACjD,OAAOA,QAAP;IACH;IAED;;;;;;;;uCAMmBI,K,EAAkC;MACjD,IAAI,CAAC,IAAA,CAAKX,WAAN,IAAqB,IAAA,CAAKY,UAAL,IAAmB1B,eAA5C,EAA6D;QACzD,OAAO,KAAP;MACH;MAHgD,IAKzCqB,QALyC,GAKXI,KALW,CAKzCJ,QALyC;QAK/BG,OAL+B,GAKXC,KALW,CAK/BD,OAL+B;QAKtBG,MALsB,GAKXF,KALW,CAKtBE,MALsB,CAAA,CAMjD;;MACA,IAAMC,MAAM,GAAG7C,OAAO,CAACsC,QAAD,EAAW,QAAX,CAAtB;MACA,IAAMQ,MAAM,GAAG9C,OAAO,CAAC4C,MAAD,EAAS,QAAT,CAAtB;MACA,IAAMG,cAAc,GAAGN,OAAO,IAAI,CAACH,QAAnC;MACA,IAAMU,gBAAgB,GAAGH,MAAM,KAAK9B,2BAApC;MACA,IAAMkC,qBAAqB,GACvBhD,QAAQ,CAAC,IAAA,CAAK6B,oBAAN,EAA4Be,MAA5B,CAAR5C,IAA+CA,QAAQ,CAACiB,sBAAD,EAAyB4B,MAAzB,CAD3D;MAEA,OAAOC,cAAc,IAAIC,gBAAlBD,IAAsCE,qBAA7C;IACH;IAED;;;;;;;;mDAM+BC,U,EAA4B;MACvD,IAAMC,eAAe,GAAGC,IAAI,CAACC,IAALD,CAAUA,IAAI,CAACE,MAALF,CAAAA,CAAAA,GAAgB,IAA1BA,CAAxB;MACA,IAAMG,aAAa,GAAG,IAAA,CAAA,GAAA,CAAA,CAAA,EAAML,UAAU,GAAG,CAAnB,CAAA,GAAwB,IAA9C;MACA,OAAOK,aAAa,GAAGJ,eAAvB;IACH;IAED;;;;;;;;IAwBA;;;;;;iCAMae,G,EAAa;MACtB,IAAMC,CAAC,GAAGC,QAAQ,CAACC,aAATD,CAAuB,GAAvBA,CAAV;MACAD,CAAC,CAACG,IAAFH,GAASD,GAATC;MACA,OAAO;QACHI,GAAG,EAAEL,GAAG,CAACM,OAAJN,CAAAA,EAAAA,CAAAA,MAAAA,CAAeC,CAAC,CAACM,MAAjBP,EAAAA,MAAAA,CAAAA,EAA+B,EAA/BA,CADF;QAEHQ,IAAI,EAAEP,CAAC,CAACO,IAFL;QAGHC,QAAQ,EAAER,CAAC,CAACQ,QAHT;QAIHC,QAAQ,EAAET,CAAC,CAACS,QAJT;QAKHH,MAAM,EAAEN,CAAC,CAACM,MALP;QAMHI,QAAQ,EAAEV,CAAC,CAACU,QANT;QAOHC,IAAI,EAAEX,CAAC,CAACW,IAPL;QAQHC,IAAI,EAAEZ,CAAC,CAACY;MARL,CAAP;IAUH;IAED;;;;;;;;;;;gDAOiB1D,E;;;;;;;;;;gBAAa2D,I,2DAAkB,CAAA,C;gBACtCC,O;kBACFC,MAAM,EAAE;mBACP1E,mB,EAAsB,kB,GACpBwE,I;gBAGP,IAAI,IAAA,CAAKzD,QAAL,IAAiB,CAAC0D,OAAO,CAAC5E,sBAAD,CAA7B,EAAuD;kBACnD4E,OAAO,CAAC5E,sBAAD,CAAP4E,GAAkC,IAAA,CAAK1D,QAAvC0D;gBACH;gBAED,IAAI,IAAA,CAAKvD,UAAT,EAAqB;kBACjBuD,OAAO,CAACE,MAARF,GAAAA,cAAAA,CAAAA,MAAAA,CAAgC,IAAA,CAAKvD,UAArCuD,CAAAA;kBAEA,IAAI,IAAA,CAAKtD,kBAAT,EAA6B;oBACzBsD,OAAO,CAACE,MAARF,GAAAA,EAAAA,CAAAA,MAAAA,CAAoBA,OAAO,CAACE,MAA5BF,EAAAA,wBAAAA,CAAAA,CAAAA,MAAAA,CAA2D,IAAA,CAAKtD,kBAAhEsD,CAAAA;kBACH;gBACJ;gBAED,IAAI,IAAA,CAAK3D,UAAT,EAAqB;kBACjB2D,OAAO,CAAC3E,kBAAD,CAAP2E,GAA8B,IAAA,CAAK3D,UAAnC2D;gBACH;gBAED,IAAI,IAAA,CAAKxD,OAAT,EAAkB;kBACdwD,OAAO,CAAC1E,qBAAD,CAAP0E,GAAiC,IAAA,CAAKxD,OAAtCwD;gBACH,C,CAED;;gBACMG,M,GAAS/D,EAAE,IAAI,IAAA,CAAKA,EAAXA,IAAiB,E;;uBACZlB,YAAY,CAACkF,aAAblF,CAA2BiF,MAA3BjF,EAAmC,IAAA,CAAKqB,KAAxCrB,C;;gBAAdqB,K;gBACN,IAAIA,KAAJ,EAAW;kBACP;kBACAyD,OAAO,CAACK,aAARL,GAAAA,SAAAA,CAAAA,MAAAA,CAAkCzD,KAAlCyD,CAAAA;gBACH;iDAEMA,O;;;;;;;;;;;;;IAGX;;;;;;;;;;;+BAmB0B;MAAA,IAAA,MAAA,GAAA,IAAA;MAAA,IATtBf,GASsB,GAAA,KAAA,CATtBA,GASsB;QARtB7C,EAQsB,GAAA,KAAA,CARtBA,EAQsB;QAAA,YAAA,GAAA,KAAA,CAPtBkE,MAOsB;QAPtBA,MAOsB,GAAA,YAAA,KAAA,KAAA,CAAA,GAPb,CAAA,CAOa,GAAA,YAAA;QAAA,aAAA,GAAA,KAAA,CANtBN,OAMsB;QANtBA,OAMsB,GAAA,aAAA,KAAA,KAAA,CAAA,GANZ,CAAA,CAMY,GAAA,aAAA;MACtB,OAAO,IAAA,CAAKO,UAAL,CAAgBnE,EAAhB,EAAoB4D,OAApB,CAAA,CAA6BjB,IAA7B,CAAkC,UAAA,IAAI,EAAA;QAAA,OACzC,MAAI,CAACjE,KAAL,CAAW0F,GAAX,CAAevB,GAAf,EAAoB;UAChBwB,WAAW,EAAE,MAAI,CAACxD,WAAL,CAAiBV,KADd;UAEhB+D,MAAM,EAANA,MAFgB;UAGhBN,OAAO,EAAEU,IAHO;UAIhBC,SAAS,EAAE,MAAI,CAACC,YAAL,CAAkB3B,GAAlB;QAJK,CAApB,CADyC;MAAA,CAAtC,CAAP;IAQH;IAED;;;;;;;;;;;;;gCAyB0B;MAAA,IAAA,MAAA,GAAA,IAAA;MAAA,IAbtBA,GAasB,GAAA,KAAA,CAbtBA,GAasB;QAZtB7C,EAYsB,GAAA,KAAA,CAZtBA,EAYsB;QAXtByE,IAWsB,GAAA,KAAA,CAXtBA,IAWsB;QAVtBP,MAUsB,GAAA,KAAA,CAVtBA,MAUsB;QAAA,aAAA,GAAA,KAAA,CATtBN,OASsB;QATtBA,OASsB,GAAA,aAAA,KAAA,KAAA,CAAA,GATZ,CAAA,CASY,GAAA,aAAA;QAAA,YAAA,GAAA,KAAA,CARtBnC,MAQsB;QARtBA,MAQsB,GAAA,YAAA,KAAA,KAAA,CAAA,GARbpC,SAQa,GAAA,YAAA;MACtB,OAAO,IAAA,CAAK8E,UAAL,CAAgBnE,EAAhB,EAAoB4D,OAApB,CAAA,CAA6BjB,IAA7B,CAAkC,UAAA,IAAI,EAAA;QAAA,OACzC,MAAI,CAACjE,KAAL,CAAW;UACPmE,GAAG,EAAHA,GADO;UAEP4B,IAAI,EAAJA,IAFO;UAGPP,MAAM,EAANA,MAHO;UAIPzC,MAAM,EAANA,MAJO;UAKP8C,SAAS,EAAE,MAAI,CAACC,YAAL,CAAkB3B,GAAlB,CALJ;UAMPe,OAAO,EAAEU;QANF,CAAX,CADyC;MAAA,CAAtC,CAAP;IAUH;IAED;;;;;;;;;;;;+BAUiF;MAAA,IAA3EzB,GAA2E,GAAA,KAAA,CAA3EA,GAA2E;QAAtE7C,EAAsE,GAAA,KAAA,CAAtEA,EAAsE;QAAlEyE,IAAkE,GAAA,KAAA,CAAlEA,IAAkE;QAA5DP,MAA4D,GAAA,KAAA,CAA5DA,MAA4D;QAAA,aAAA,GAAA,KAAA,CAApDN,OAAoD;QAApDA,OAAoD,GAAA,aAAA,KAAA,KAAA,CAAA,GAA1C,CAAA,CAA0C,GAAA,aAAA;MAC7E,OAAO,IAAA,CAAKc,IAAL,CAAU;QAAE1E,EAAE,EAAFA,EAAF;QAAM6C,GAAG,EAAHA,GAAN;QAAW4B,IAAI,EAAJA,IAAX;QAAiBP,MAAM,EAANA,MAAjB;QAAyBN,OAAO,EAAPA,OAAzB;QAAkCnC,MAAM,EAAEnC;MAA1C,CAAV,CAAP;IACH;IAED;;;;;;;;;;;mCAmB0B;MAAA,IATtBuD,GASsB,GAAA,KAAA,CATtBA,GASsB;QARtB7C,EAQsB,GAAA,KAAA,CARtBA,EAQsB;QAAA,UAAA,GAAA,KAAA,CAPtByE,IAOsB;QAPtBA,IAOsB,GAAA,UAAA,KAAA,KAAA,CAAA,GAPf,CAAA,CAOe,GAAA,UAAA;QAAA,aAAA,GAAA,KAAA,CANtBb,OAMsB;QANtBA,OAMsB,GAAA,aAAA,KAAA,KAAA,CAAA,GANZ,CAAA,CAMY,GAAA,aAAA;MACtB,OAAO,IAAA,CAAKc,IAAL,CAAU;QAAE1E,EAAE,EAAFA,EAAF;QAAM6C,GAAG,EAAHA,GAAN;QAAW4B,IAAI,EAAJA,IAAX;QAAiBb,OAAO,EAAPA,OAAjB;QAA0BnC,MAAM,EAAElC;MAAlC,CAAV,CAAP;IACH;IAED;;;;;;;;;;;;;mCA0B0B;MAAA,IAAA,MAAA,GAAA,IAAA;MAAA,IAdtBS,EAcsB,GAAA,KAAA,CAdtBA,EAcsB;QAbtB6C,GAasB,GAAA,KAAA,CAbtBA,GAasB;QAZtB4B,IAYsB,GAAA,KAAA,CAZtBA,IAYsB;QAAA,aAAA,GAAA,KAAA,CAXtBb,OAWsB;QAXtBA,OAWsB,GAAA,aAAA,KAAA,KAAA,CAAA,GAXZ,CAAA,CAWY,GAAA,aAAA;QAVtBe,cAUsB,GAAA,KAAA,CAVtBA,cAUsB;QATtBC,YASsB,GAAA,KAAA,CATtBA,YASsB;MACtB,OAAO,IAAA,CAAKT,UAAL,CAAgBnE,EAAhB,EAAoB4D,OAApB,CAAA,CACFjB,IADE,CACG,UAAA,IAAI,EAAA;QAAA,OACN,MAAI,CAACjE,KAAL,CAAW;UACPmE,GAAG,EAAHA,GADO;UAEP4B,IAAI,EAAJA,IAFO;UAGPhD,MAAM,EAAEjC,YAHD;UAIPoE,OAAO,EAAEU;QAJF,CAAX,CAAA,CAMK3B,IANL,CAMUgC,cANV,CAAA,CAOKE,KAPL,CAOWD,YAPX,CADM;MAAA,CADP,CAAA,CAWFC,KAXE,CAWID,YAXJ,CAAP;IAYH;IAED;;;;;;;;;;;;;;;;;;sCAwCiB;MAAA,IAAA,MAAA,GAAA,IAAA;MAAA,IAvBb5E,EAuBa,GAAA,KAAA,CAvBbA,EAuBa;QAtBb6C,GAsBa,GAAA,KAAA,CAtBbA,GAsBa;QArBb4B,IAqBa,GAAA,KAAA,CArBbA,IAqBa;QAAA,aAAA,GAAA,KAAA,CApBbb,OAoBa;QApBbA,OAoBa,GAAA,aAAA,KAAA,KAAA,CAAA,GApBH,CAAA,CAoBG,GAAA,aAAA;QAAA,YAAA,GAAA,KAAA,CAnBbnC,MAmBa;QAnBbA,MAmBa,GAAA,YAAA,KAAA,KAAA,CAAA,GAnBJpC,SAmBI,GAAA,YAAA;QAlBbsF,cAkBa,GAAA,KAAA,CAlBbA,cAkBa;QAjBbC,YAiBa,GAAA,KAAA,CAjBbA,YAiBa;QAhBbE,eAgBa,GAAA,KAAA,CAhBbA,eAgBa;QAAA,qBAAA,GAAA,KAAA,CAfbC,eAea;QAfbA,eAea,GAAA,qBAAA,KAAA,KAAA,CAAA,GAfK,KAeL,GAAA,qBAAA;QAAA,qBAAA,GAAA,KAAA,CAdbC,mBAca;QAdbA,mBAca,GAAA,qBAAA,KAAA,KAAA,CAAA,GAdSrF,yBAcT,GAAA,qBAAA;QAbbsF,kBAaa,GAAA,KAAA,CAbbA,kBAaa;MACb,OAAO,IAAA,CAAKd,UAAL,CAAgBnE,EAAhB,EAAoB4D,OAApB,CAAA,CACFjB,IADE,CACG,UAAA,IAAI,EAAI;QACV,IAAIuC,WAAJ;QACA,IAAIC,oBAAoB,GAAGL,eAA3B;QAEA,IAAIC,eAAJ,EAAqB;UACjB;UACA,IAAMK,eAAe,GAAG,SAAlBA,eAAkB,CAAA,EAAM;YAC1B,MAAI,CAACC,KAAL,CAAA,CAAA;YAEA,IAAIJ,kBAAJ,EAAwB;cACpBA,kBAAkB,CAAA,CAAA;YACrB;UACJ,CAND;UAQAC,WAAW,GAAGxC,UAAU,CAAC0C,eAAD,EAAkBJ,mBAAlB,CAAxBE,CAViB,CAYjB;;UACAC,oBAAoB,GAAG,SAAA,oBAAA,CAAA,KAAK,EAAI;YAC5BG,YAAY,CAACJ,WAAD,CAAZI;YACAJ,WAAW,GAAGxC,UAAU,CAAC0C,eAAD,EAAkBJ,mBAAlB,CAAxBE;YACAJ,eAAe,CAACS,KAAD,CAAfT;UACH,CAJDK;QAKH;QACD,MAAI,CAACzG,KAAL,CAAW;UACPmE,GAAG,EAAHA,GADO;UAEP4B,IAAI,EAAJA,IAFO;UAGPe,gBAAgB,EAAE,SAAA,gBAAA,CAACC,OAAD,EAAUC,UAAV,EAAyB;YACvC;YACA,OAAOA,UAAU,CAAC3G,aAAD,CAAjB;YACA,OAAO2G,UAAU,CAACvG,mBAAD,CAAjB;YAEA,IAAIyE,OAAO,CAACzE,mBAAD,CAAX,EAAkC;cAC9BuG,UAAU,CAACvG,mBAAD,CAAVuG,GAAkC9B,OAAO,CAACzE,mBAAD,CAAzCuG;YACH,CAPsC,CASvC;;YACA,IAAID,OAAO,IAAI,EAAEA,OAAO,YAAYE,IAArB,CAAXF,IAAyCA,OAAO,CAACG,UAArD,EAAiE;cAC7D,IAAMC,QAAQ,GAAG,IAAIC,QAAJ,CAAA,CAAjB;cACAC,MAAM,CAACC,IAAPD,CAAYN,OAAZM,CAAAA,CAAqBE,OAArBF,CAA6B,UAAA,GAAG,EAAI;gBAChCF,QAAQ,CAACK,MAATL,CAAgBM,GAAhBN,EAAqBJ,OAAO,CAACU,GAAD,CAA5BN,CAAAA;cACH,CAFDE,CAAAA;cAIA,OAAOF,QAAP;YACH;YAED,OAAOJ,OAAP;UACH,CAvBM;UAwBPhE,MAAM,EAANA,MAxBO;UAyBPmC,OAAO,EAAEU,IAzBF;UA0BP8B,gBAAgB,EAAEjB,oBA1BX;UA2BPd,WAAW,EAAE,MAAI,CAACxD,WAAL,CAAiBV;QA3BvB,CAAX,CAAA,CA6BKwC,IA7BL,CA6BU,UAAA,QAAQ,EAAI;UACd2C,YAAY,CAACJ,WAAD,CAAZI;UACAX,cAAc,CAAC1D,QAAD,CAAd0D;QACH,CAhCL,CAAA,CAiCKE,KAjCL,CAiCW,UAAA,KAAK,EAAI;UACZS,YAAY,CAACJ,WAAD,CAAZI;UACAV,YAAY,CAACvD,KAAD,CAAZuD;QACH,CApCL,CAAA;MAqCH,CA7DE,CAAA,CA8DFC,KA9DE,CA8DID,YA9DJ,CAAP;IA+DH;IAED;;;;;;;4BAKc;MACV,IAAI,IAAA,CAAKnC,YAAT,EAAuB;QACnB6C,YAAY,CAAC,IAAA,CAAK7C,YAAN,CAAZ6C;MACH;MACD,IAAI,IAAA,CAAKzE,WAAT,EAAsB;QAClB,IAAA,CAAKA,WAAL,CAAiBwF,MAAjB,CAAA,CAAA;QACA,IAAA,CAAKxF,WAAL,GAAmBnC,KAAK,CAACoC,WAANpC,CAAkBqC,MAAlBrC,CAAAA,CAAnB;MACH;IACJ;;;;AAGL,eAAeqB,GAAf","sourcesContent":["/**\n * @flow\n * @file Network utilities\n * @author Box\n */\n\nimport axios from 'axios';\nimport type { $AxiosError, $AxiosXHR } from 'axios';\nimport getProp from 'lodash/get';\nimport includes from 'lodash/includes';\nimport lowerCase from 'lodash/lowerCase';\nimport TokenService from './TokenService';\nimport {\n    HEADER_ACCEPT,\n    HEADER_ACCEPT_LANGUAGE,\n    HEADER_CLIENT_NAME,\n    HEADER_CLIENT_VERSION,\n    HEADER_CONTENT_TYPE,\n    HTTP_GET,\n    HTTP_POST,\n    HTTP_PUT,\n    HTTP_DELETE,\n    HTTP_OPTIONS,\n    HTTP_HEAD,\n    HTTP_STATUS_CODE_RATE_LIMIT,\n} from '../constants';\nimport type { APIOptions, Method, PayloadType, RequestData } from '../common/types/api';\nimport type { StringAnyMap, StringMap, Token } from '../common/types/core';\n\nconst DEFAULT_UPLOAD_TIMEOUT_MS = 120000;\nconst MAX_NUM_RETRIES = 3;\nconst RETRYABLE_HTTP_METHODS = [HTTP_GET, HTTP_OPTIONS, HTTP_HEAD].map(lowerCase);\n\nclass Xhr {\n    id: ?string;\n\n    axios: Axios;\n\n    axiosSource: CancelTokenSource;\n\n    clientName: ?string;\n\n    language: ?string;\n\n    token: Token;\n\n    version: ?string;\n\n    sharedLink: ?string;\n\n    sharedLinkPassword: ?string;\n\n    xhr: XMLHttpRequest;\n\n    responseInterceptor: Function;\n\n    requestInterceptor: ?Function;\n\n    tokenService: TokenService;\n\n    retryCount: number = 0;\n\n    retryableStatusCodes: Array<number>;\n\n    retryTimeout: ?TimeoutID;\n\n    shouldRetry: boolean;\n\n    /**\n     * [constructor]\n     *\n     * @param {Object} options\n     * @param {string} options.id - item id\n     * @param {string} options.clientName - Client Name\n     * @param {string|function} options.token - Auth token\n     * @param {string} [options.language] - Accept-Language header value\n     * @param {string} [options.sharedLink] - Shared link\n     * @param {string} [options.sharedLinkPassword] - Shared link password\n     * @param {string} [options.requestInterceptor] - Request interceptor\n     * @param {string} [options.responseInterceptor] - Response interceptor\n     * @param {number[]} [options.retryableStatusCodes] - Response codes to retry\n     * @param {boolean} [options.shouldRetry] - Should retry failed requests\n     * @return {Xhr} Cache instance\n     */\n    constructor({\n        id,\n        clientName,\n        language,\n        token,\n        version,\n        sharedLink,\n        sharedLinkPassword,\n        responseInterceptor,\n        requestInterceptor,\n        retryableStatusCodes = [HTTP_STATUS_CODE_RATE_LIMIT],\n        shouldRetry = true,\n    }: APIOptions = {}) {\n        this.clientName = clientName;\n        this.id = id;\n        this.language = language;\n        this.responseInterceptor = responseInterceptor || this.defaultResponseInterceptor;\n        this.retryableStatusCodes = retryableStatusCodes;\n        this.sharedLink = sharedLink;\n        this.sharedLinkPassword = sharedLinkPassword;\n        this.shouldRetry = shouldRetry;\n        this.token = token;\n        this.version = version;\n\n        this.axios = axios.create();\n        this.axiosSource = axios.CancelToken.source();\n        this.axios.interceptors.response.use(this.responseInterceptor, this.errorInterceptor);\n\n        if (typeof requestInterceptor === 'function') {\n            this.axios.interceptors.request.use(requestInterceptor);\n        }\n    }\n\n    /**\n     * Default response interceptor which just returns the response\n     *\n     * @param {Object} response - the axios response\n     * @return the response\n     */\n    defaultResponseInterceptor(response: $AxiosXHR<any>) {\n        return response;\n    }\n\n    /**\n     * Determines if a request should be retried\n     *\n     * @param {Object} error - Error object from axios\n     * @return {boolean} true if the request should be retried\n     */\n    shouldRetryRequest(error: $AxiosError<any>): boolean {\n        if (!this.shouldRetry || this.retryCount >= MAX_NUM_RETRIES) {\n            return false;\n        }\n\n        const { response, request, config } = error;\n        // Retry if there is a network error (e.g. ECONNRESET) or rate limited\n        const status = getProp(response, 'status');\n        const method = getProp(config, 'method');\n        const isNetworkError = request && !response;\n        const isRateLimitError = status === HTTP_STATUS_CODE_RATE_LIMIT;\n        const isOtherRetryableError =\n            includes(this.retryableStatusCodes, status) && includes(RETRYABLE_HTTP_METHODS, method);\n        return isNetworkError || isRateLimitError || isOtherRetryableError;\n    }\n\n    /**\n     * Calculate the exponential backoff time with randomized jitter.\n     *\n     * @param {number} numRetries Which retry number this one will be. Must be > 0\n     * @returns {number} The number of milliseconds after which to retry\n     */\n    getExponentialRetryTimeoutInMs(numRetries: number): number {\n        const randomizationMs = Math.ceil(Math.random() * 1000);\n        const exponentialMs = 2 ** (numRetries - 1) * 1000;\n        return exponentialMs + randomizationMs;\n    }\n\n    /**\n     * Error interceptor that wraps the passed in responseInterceptor\n     *\n     * @param {Object} error - Error object from axios\n     * @return {Promise} rejected promise with error info\n     */\n    errorInterceptor = (error: $AxiosError<any>): Promise<any> => {\n        const shouldRetry = this.shouldRetryRequest(error);\n        if (shouldRetry) {\n            this.retryCount += 1;\n            const delay = this.getExponentialRetryTimeoutInMs(this.retryCount);\n            return new Promise((resolve, reject) => {\n                this.retryTimeout = setTimeout(() => {\n                    this.axios(error.config).then(resolve, reject);\n                }, delay);\n            });\n        }\n\n        const errorObject = getProp(error, 'response.data') || error; // In the case of 401, response.data is empty so fall back to error\n        this.responseInterceptor(errorObject);\n\n        return Promise.reject(error);\n    };\n\n    /**\n     * Utility to parse a URL.\n     *\n     * @param {string} url - Url to parse\n     * @return {Object} parsed url\n     */\n    getParsedUrl(url: string) {\n        const a = document.createElement('a');\n        a.href = url;\n        return {\n            api: url.replace(`${a.origin}/2.0`, ''),\n            host: a.host,\n            hostname: a.hostname,\n            pathname: a.pathname,\n            origin: a.origin,\n            protocol: a.protocol,\n            hash: a.hash,\n            port: a.port,\n        };\n    }\n\n    /**\n     * Builds a list of required XHR headers.\n     *\n     * @param {string} [id] - Optional box item id\n     * @param {Object} [args] - Optional existing headers\n     * @return {Object} Headers\n     */\n    async getHeaders(id?: string, args: StringMap = {}) {\n        const headers: StringMap = {\n            Accept: 'application/json',\n            [HEADER_CONTENT_TYPE]: 'application/json',\n            ...args,\n        };\n\n        if (this.language && !headers[HEADER_ACCEPT_LANGUAGE]) {\n            headers[HEADER_ACCEPT_LANGUAGE] = this.language;\n        }\n\n        if (this.sharedLink) {\n            headers.BoxApi = `shared_link=${this.sharedLink}`;\n\n            if (this.sharedLinkPassword) {\n                headers.BoxApi = `${headers.BoxApi}&shared_link_password=${this.sharedLinkPassword}`;\n            }\n        }\n\n        if (this.clientName) {\n            headers[HEADER_CLIENT_NAME] = this.clientName;\n        }\n\n        if (this.version) {\n            headers[HEADER_CLIENT_VERSION] = this.version;\n        }\n\n        // If id is passed in, use that, otherwise default to this.id\n        const itemId = id || this.id || '';\n        const token = await TokenService.getWriteToken(itemId, this.token);\n        if (token) {\n            // Only add a token when there was one found\n            headers.Authorization = `Bearer ${token}`;\n        }\n\n        return headers;\n    }\n\n    /**\n     * HTTP GETs a URL\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {Object} [params] - Key-value map of querystring params\n     * @return {Promise} - HTTP response\n     */\n    get({\n        url,\n        id,\n        params = {},\n        headers = {},\n    }: {\n        headers?: StringMap,\n        id?: string,\n        params?: StringAnyMap,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers).then(hdrs =>\n            this.axios.get(url, {\n                cancelToken: this.axiosSource.token,\n                params,\n                headers: hdrs,\n                parsedUrl: this.getParsedUrl(url),\n            }),\n        );\n    }\n\n    /**\n     * HTTP POSTs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} params - Optional query params for the request\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {string} [method] - xhr type\n     * @return {Promise} - HTTP response\n     */\n    post({\n        url,\n        id,\n        data,\n        params,\n        headers = {},\n        method = HTTP_POST,\n    }: {\n        data: PayloadType,\n        headers?: StringMap,\n        id?: string,\n        method?: Method,\n        params?: StringAnyMap,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers).then(hdrs =>\n            this.axios({\n                url,\n                data,\n                params,\n                method,\n                parsedUrl: this.getParsedUrl(url),\n                headers: hdrs,\n            }),\n        );\n    }\n\n    /**\n     * HTTP PUTs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} params - Optional query params for the request\n     * @param {Object} [headers] - Key-value map of headers\n     * @return {Promise} - HTTP response\n     */\n    put({ url, id, data, params, headers = {} }: RequestData): Promise<StringAnyMap> {\n        return this.post({ id, url, data, params, headers, method: HTTP_PUT });\n    }\n\n    /**\n     * HTTP DELETEs a URL with JSON data\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to fetch\n     * @param {Object} data - JS Object representation of JSON data to send\n     * @param {Object} [headers] - Key-value map of headers\n     * @return {Promise} - HTTP response\n     */\n    delete({\n        url,\n        id,\n        data = {},\n        headers = {},\n    }: {\n        data?: StringAnyMap,\n        headers?: StringMap,\n        id?: string,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.post({ id, url, data, headers, method: HTTP_DELETE });\n    }\n\n    /**\n     * HTTP OPTIONs a URL with JSON data.\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to post to\n     * @param {Object} data - The non-file post data that should accompany the post\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {Function} successHandler - Load success handler\n     * @param {Function} errorHandler - Error handler\n     * @return {void}\n     */\n    options({\n        id,\n        url,\n        data,\n        headers = {},\n        successHandler,\n        errorHandler,\n    }: {\n        data: StringAnyMap,\n        errorHandler: Function,\n        headers?: StringMap,\n        id?: string,\n        progressHandler?: Function,\n        successHandler: Function,\n        url: string,\n    }): Promise<StringAnyMap> {\n        return this.getHeaders(id, headers)\n            .then(hdrs =>\n                this.axios({\n                    url,\n                    data,\n                    method: HTTP_OPTIONS,\n                    headers: hdrs,\n                })\n                    .then(successHandler)\n                    .catch(errorHandler),\n            )\n            .catch(errorHandler);\n    }\n\n    /**\n     * HTTP POST or PUT a URL with File data. Uses native XHR for progress event.\n     *\n     * @param {string} id - Box item id\n     * @param {string} url - The URL to post to\n     * @param {Object} [data] - File data and attributes\n     * @param {Object} [headers] - Key-value map of headers\n     * @param {string} [method] - XHR method, supports 'POST' and 'PUT'\n     * @param {Function} successHandler - Load success handler\n     * @param {Function} errorHandler - Error handler\n     * @param {Function} progressHandler - Progress handler\n     * @param {boolean} [withIdleTimeout] - enable idle timeout\n     * @param {number} [idleTimeoutDuration] - idle timeout duration\n     * @param {Function} [idleTimeoutHandler]\n     * @return {void}\n     */\n    uploadFile({\n        id,\n        url,\n        data,\n        headers = {},\n        method = HTTP_POST,\n        successHandler,\n        errorHandler,\n        progressHandler,\n        withIdleTimeout = false,\n        idleTimeoutDuration = DEFAULT_UPLOAD_TIMEOUT_MS,\n        idleTimeoutHandler,\n    }: {\n        data?: ?Blob | ?StringAnyMap,\n        errorHandler: Function,\n        headers?: StringMap,\n        id?: string,\n        idleTimeoutDuration?: number,\n        idleTimeoutHandler?: Function,\n        method?: Method,\n        progressHandler: Function,\n        successHandler: Function,\n        url: string,\n        withIdleTimeout?: boolean,\n    }): Promise<any> {\n        return this.getHeaders(id, headers)\n            .then(hdrs => {\n                let idleTimeout;\n                let progressHandlerToUse = progressHandler;\n\n                if (withIdleTimeout) {\n                    // Func that aborts upload and executes timeout callback\n                    const idleTimeoutFunc = () => {\n                        this.abort();\n\n                        if (idleTimeoutHandler) {\n                            idleTimeoutHandler();\n                        }\n                    };\n\n                    idleTimeout = setTimeout(idleTimeoutFunc, idleTimeoutDuration);\n\n                    // Progress handler that aborts upload if there has been no progress for >= timeoutMs\n                    progressHandlerToUse = event => {\n                        clearTimeout(idleTimeout);\n                        idleTimeout = setTimeout(idleTimeoutFunc, idleTimeoutDuration);\n                        progressHandler(event);\n                    };\n                }\n                this.axios({\n                    url,\n                    data,\n                    transformRequest: (reqData, reqHeaders) => {\n                        // Remove Accept & Content-Type added by getHeaders()\n                        delete reqHeaders[HEADER_ACCEPT];\n                        delete reqHeaders[HEADER_CONTENT_TYPE];\n\n                        if (headers[HEADER_CONTENT_TYPE]) {\n                            reqHeaders[HEADER_CONTENT_TYPE] = headers[HEADER_CONTENT_TYPE];\n                        }\n\n                        // Convert to FormData if needed\n                        if (reqData && !(reqData instanceof Blob) && reqData.attributes) {\n                            const formData = new FormData();\n                            Object.keys(reqData).forEach(key => {\n                                formData.append(key, reqData[key]);\n                            });\n\n                            return formData;\n                        }\n\n                        return reqData;\n                    },\n                    method,\n                    headers: hdrs,\n                    onUploadProgress: progressHandlerToUse,\n                    cancelToken: this.axiosSource.token,\n                })\n                    .then(response => {\n                        clearTimeout(idleTimeout);\n                        successHandler(response);\n                    })\n                    .catch(error => {\n                        clearTimeout(idleTimeout);\n                        errorHandler(error);\n                    });\n            })\n            .catch(errorHandler);\n    }\n\n    /**\n     * Aborts an axios request.\n     *\n     * @return {void}\n     */\n    abort(): void {\n        if (this.retryTimeout) {\n            clearTimeout(this.retryTimeout);\n        }\n        if (this.axiosSource) {\n            this.axiosSource.cancel();\n            this.axiosSource = axios.CancelToken.source();\n        }\n    }\n}\n\nexport default Xhr;\n"]},"metadata":{},"sourceType":"module"}