{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * \n * @file Helper for Box uploads reachability test\n * @author Box\n */\nimport axios from 'axios';\nimport LocalStore from '../../utils/LocalStore';\nimport { DEFAULT_HOSTNAME_UPLOAD, HEADER_CONTENT_TYPE } from '../../constants';\nvar CACHED_RESULTS_LOCAL_STORE_KEY = 'bcu-uploads-reachability-cached-results';\nvar UploadsReachability = /*#__PURE__*/\nfunction () {\n  /**\n   * [constructor]\n   */\n  function UploadsReachability() {\n    _classCallCheck(this, UploadsReachability);\n    this.localStore = new LocalStore();\n    this.cachedResults = {}; // Populate cachedResults with valid values from the local store, and then save the new\n    // cachedResults back to local store.\n    // This cleanup of invalid entries is not strictly necessary to maintain correctness,\n    // but if we don't do this cleanup results may accumulate in local storage forever.\n\n    this.populateCachedResultsWithValidLocalStoreValues();\n    this.saveCachedResultsToLocalStore();\n  }\n  /**\n   * Returns existing reachability results from local store\n   *\n   * @private\n   * @return {?Object} The results, or null if there was a problem reading the value from local store\n   */\n\n  _createClass(UploadsReachability, [{\n    key: \"getCachedResultsFromLocalStore\",\n    value: function getCachedResultsFromLocalStore() {\n      return this.localStore.getItem(CACHED_RESULTS_LOCAL_STORE_KEY);\n    }\n    /**\n     * Saves the cachedResults variable as a JSON string in local store.\n     *\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: \"saveCachedResultsToLocalStore\",\n    value: function saveCachedResultsToLocalStore() {\n      this.localStore.setItem(CACHED_RESULTS_LOCAL_STORE_KEY, this.cachedResults);\n    }\n    /**\n     * Returns true if the given cached result is still valid (i.e. it has not expired yet)\n     *\n     * @private\n     * @param {StringAnyMap} result - A result object for one host\n     * @return {boolean} Whether or not the result is valid\n     */\n  }, {\n    key: \"isCachedHostValid\",\n    value: function isCachedHostValid(result) {\n      return result.expirationTimestampMS > Date.now();\n    }\n    /**\n     * Returns the cached result for the given uploadHost\n     *\n     * @private\n     * @param {string} uploadHost - The host URL\n     * @return {null|StringAnyMap} The result object or null if there isn't one\n     */\n  }, {\n    key: \"getCachedResult\",\n    value: function getCachedResult(uploadHost) {\n      if (uploadHost in this.cachedResults) {\n        var result = this.cachedResults[uploadHost];\n        if (this.isCachedHostValid(result)) {\n          return result;\n        }\n      }\n      return null;\n    }\n    /**\n     * Updates a cached result. Changes both the in-memory cachedResult variable and what's stored in local store\n     *\n     * @private\n     * @param {string} uploadHost - The host URL that was tested\n     * @param {boolean} isHostReachable - Whether or not the host was reachable\n     * @return {void}\n     */\n  }, {\n    key: \"updateCachedResult\",\n    value: function updateCachedResult(uploadHost, isHostReachable) {\n      this.cachedResults[uploadHost] = {\n        isReachable: isHostReachable,\n        expirationTimestampMS: Date.now() + 1000 * 86400\n      };\n      this.saveCachedResultsToLocalStore();\n    }\n    /**\n     * Adds to the cachedResults object with valid entries from local storage\n     *\n     * @private\n     * @return {void}\n     */\n  }, {\n    key: \"populateCachedResultsWithValidLocalStoreValues\",\n    value: function populateCachedResultsWithValidLocalStoreValues() {\n      var _this = this;\n      var localStoreResults = this.getCachedResultsFromLocalStore();\n      if (!localStoreResults) {\n        return;\n      }\n      Object.keys(localStoreResults).forEach(function (uploadHost) {\n        var result = localStoreResults[uploadHost];\n        if (_this.isCachedHostValid(result)) {\n          _this.cachedResults[uploadHost] = result;\n        }\n      });\n    }\n    /**\n     * Returns the host URLs that, according to the cached reachability test results, are unreachable\n     *\n     * @return {Array} The unreachable host URLs\n     */\n  }, {\n    key: \"getUnreachableHostsUrls\",\n    value: function getUnreachableHostsUrls() {\n      var _this2 = this;\n      var unreachableHosts = [];\n      if (!this.cachedResults) {\n        return unreachableHosts;\n      }\n      Object.keys(this.cachedResults).forEach(function (uploadHost) {\n        var value = _this2.cachedResults[uploadHost];\n        if (_this2.isCachedHostValid(value) && !value.isReachable) {\n          unreachableHosts.push(uploadHost);\n        }\n      });\n      return unreachableHosts;\n    }\n    /**\n     * Determines whether the given host is reachable by either making a test request to the uploadHost\n     * or returning the result of the last reachability test it did\n     *\n     * @param {string} uploadHost - The upload host URL that will be stored in the cached test result and returned in\n     * getUnreachableHostsUrls() if test fails (this is usually a prefix of the uploadUrl)\n     * @return {Promise<boolean>} Promise that resolved to true if the host is reachable, false if it is not\n     */\n  }, {\n    key: \"isReachable\",\n    value: function () {\n      var _isReachable = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(uploadHost) {\n        var cachedResult, isHostReachable;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(uploadHost === \"\".concat(DEFAULT_HOSTNAME_UPLOAD, \"/\"))) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt(\"return\", true);\n              case 2:\n                cachedResult = this.getCachedResult(uploadHost);\n                if (!cachedResult) {\n                  _context.next = 5;\n                  break;\n                }\n                return _context.abrupt(\"return\", cachedResult.isReachable);\n              case 5:\n                _context.next = 7;\n                return this.makeReachabilityRequest(uploadHost);\n              case 7:\n                isHostReachable = _context.sent;\n                this.updateCachedResult(uploadHost, isHostReachable);\n                return _context.abrupt(\"return\", isHostReachable);\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function isReachable(_x) {\n        return _isReachable.apply(this, arguments);\n      }\n      return isReachable;\n    }()\n    /**\n     * Determines if the given uploadHost is reachable by making a test upload request to it.\n     * Does not read or modify any cached results.\n     *\n     * @param {string} uploadHost - The upload host url to make a test request against\n     * @return {Promise<boolean>}\n     */\n  }, {\n    key: \"makeReachabilityRequest\",\n    value: function () {\n      var _makeReachabilityRequest = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(uploadHost) {\n        var _headers;\n        var url, headers, data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                url = \"\".concat(uploadHost, \"html5?reachability_test=run\");\n                headers = (_headers = {}, _defineProperty(_headers, HEADER_CONTENT_TYPE, 'application/x-www-form-urlencoded; charset=UTF-8'), _defineProperty(_headers, 'X-File-Name', 'reachability_pseudofile.txt'), _defineProperty(_headers, 'X-File-Size', '1234'), _headers);\n                data = 'reachability_file=test_file_data';\n                _context2.prev = 3;\n                _context2.next = 6;\n                return axios.post(url, data, {\n                  headers: headers\n                });\n              case 6:\n                _context2.next = 11;\n                break;\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](3);\n                return _context2.abrupt(\"return\", false);\n              case 11:\n                return _context2.abrupt(\"return\", true);\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[3, 8]]);\n      }));\n      function makeReachabilityRequest(_x2) {\n        return _makeReachabilityRequest.apply(this, arguments);\n      }\n      return makeReachabilityRequest;\n    }()\n  }]);\n  return UploadsReachability;\n}();\nexport default UploadsReachability;","map":{"version":3,"sources":["../../../src/api/uploads/UploadsReachability.js"],"names":["axios","LocalStore","DEFAULT_HOSTNAME_UPLOAD","HEADER_CONTENT_TYPE","CACHED_RESULTS_LOCAL_STORE_KEY","UploadsReachability","localStore","cachedResults","populateCachedResultsWithValidLocalStoreValues","saveCachedResultsToLocalStore","getItem","setItem","result","expirationTimestampMS","Date","now","uploadHost","isCachedHostValid","isHostReachable","isReachable","localStoreResults","getCachedResultsFromLocalStore","Object","keys","forEach","unreachableHosts","value","push","cachedResult","getCachedResult","makeReachabilityRequest","updateCachedResult","url","headers","data","post"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for Box uploads reachability test\n * @author Box\n */\n\nimport axios from 'axios';\nimport LocalStore from '../../utils/LocalStore';\nimport { DEFAULT_HOSTNAME_UPLOAD, HEADER_CONTENT_TYPE } from '../../constants';\nimport type { StringAnyMap, StringMap } from '../../common/types/core';\n\nconst CACHED_RESULTS_LOCAL_STORE_KEY = 'bcu-uploads-reachability-cached-results';\n\ntype CachedResult = {\n    expirationTimestampMS: number,\n    isReachable: boolean,\n};\n\nclass UploadsReachability {\n    localStore: LocalStore;\n\n    cachedResults: { string: CachedResult };\n\n    /**\n     * [constructor]\n     */\n    constructor() {\n        this.localStore = new LocalStore();\n        this.cachedResults = {};\n\n        // Populate cachedResults with valid values from the local store, and then save the new\n        // cachedResults back to local store.\n        // This cleanup of invalid entries is not strictly necessary to maintain correctness,\n        // but if we don't do this cleanup results may accumulate in local storage forever.\n        this.populateCachedResultsWithValidLocalStoreValues();\n        this.saveCachedResultsToLocalStore();\n    }\n\n    /**\n     * Returns existing reachability results from local store\n     *\n     * @private\n     * @return {?Object} The results, or null if there was a problem reading the value from local store\n     */\n    getCachedResultsFromLocalStore() {\n        return this.localStore.getItem(CACHED_RESULTS_LOCAL_STORE_KEY);\n    }\n\n    /**\n     * Saves the cachedResults variable as a JSON string in local store.\n     *\n     * @private\n     * @return {void}\n     */\n    saveCachedResultsToLocalStore() {\n        this.localStore.setItem(CACHED_RESULTS_LOCAL_STORE_KEY, this.cachedResults);\n    }\n\n    /**\n     * Returns true if the given cached result is still valid (i.e. it has not expired yet)\n     *\n     * @private\n     * @param {StringAnyMap} result - A result object for one host\n     * @return {boolean} Whether or not the result is valid\n     */\n    isCachedHostValid(result: StringAnyMap) {\n        return result.expirationTimestampMS > Date.now();\n    }\n\n    /**\n     * Returns the cached result for the given uploadHost\n     *\n     * @private\n     * @param {string} uploadHost - The host URL\n     * @return {null|StringAnyMap} The result object or null if there isn't one\n     */\n    getCachedResult(uploadHost: string) {\n        if (uploadHost in this.cachedResults) {\n            const result = this.cachedResults[uploadHost];\n            if (this.isCachedHostValid(result)) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Updates a cached result. Changes both the in-memory cachedResult variable and what's stored in local store\n     *\n     * @private\n     * @param {string} uploadHost - The host URL that was tested\n     * @param {boolean} isHostReachable - Whether or not the host was reachable\n     * @return {void}\n     */\n    updateCachedResult(uploadHost: string, isHostReachable: boolean) {\n        this.cachedResults[uploadHost] = {\n            isReachable: isHostReachable,\n            expirationTimestampMS: Date.now() + 1000 * 86400,\n        };\n        this.saveCachedResultsToLocalStore();\n    }\n\n    /**\n     * Adds to the cachedResults object with valid entries from local storage\n     *\n     * @private\n     * @return {void}\n     */\n    populateCachedResultsWithValidLocalStoreValues() {\n        const localStoreResults = this.getCachedResultsFromLocalStore();\n        if (!localStoreResults) {\n            return;\n        }\n\n        Object.keys(localStoreResults).forEach(uploadHost => {\n            const result = localStoreResults[uploadHost];\n            if (this.isCachedHostValid(result)) {\n                this.cachedResults[uploadHost] = result;\n            }\n        });\n    }\n\n    /**\n     * Returns the host URLs that, according to the cached reachability test results, are unreachable\n     *\n     * @return {Array} The unreachable host URLs\n     */\n    getUnreachableHostsUrls() {\n        const unreachableHosts = [];\n        if (!this.cachedResults) {\n            return unreachableHosts;\n        }\n\n        Object.keys(this.cachedResults).forEach(uploadHost => {\n            const value = this.cachedResults[uploadHost];\n            if (this.isCachedHostValid(value) && !value.isReachable) {\n                unreachableHosts.push(uploadHost);\n            }\n        });\n\n        return unreachableHosts;\n    }\n\n    /**\n     * Determines whether the given host is reachable by either making a test request to the uploadHost\n     * or returning the result of the last reachability test it did\n     *\n     * @param {string} uploadHost - The upload host URL that will be stored in the cached test result and returned in\n     * getUnreachableHostsUrls() if test fails (this is usually a prefix of the uploadUrl)\n     * @return {Promise<boolean>} Promise that resolved to true if the host is reachable, false if it is not\n     */\n    async isReachable(uploadHost: string) {\n        // The default upload host should always reachable\n        if (uploadHost === `${DEFAULT_HOSTNAME_UPLOAD}/`) {\n            return true;\n        }\n\n        const cachedResult = this.getCachedResult(uploadHost);\n        if (cachedResult) {\n            return cachedResult.isReachable;\n        }\n\n        const isHostReachable = await this.makeReachabilityRequest(uploadHost);\n        this.updateCachedResult(uploadHost, isHostReachable);\n        return isHostReachable;\n    }\n\n    /**\n     * Determines if the given uploadHost is reachable by making a test upload request to it.\n     * Does not read or modify any cached results.\n     *\n     * @param {string} uploadHost - The upload host url to make a test request against\n     * @return {Promise<boolean>}\n     */\n    async makeReachabilityRequest(uploadHost: string) {\n        const url = `${uploadHost}html5?reachability_test=run`;\n        const headers: StringMap = {\n            [HEADER_CONTENT_TYPE]: 'application/x-www-form-urlencoded; charset=UTF-8',\n            'X-File-Name': 'reachability_pseudofile.txt',\n            'X-File-Size': '1234',\n        };\n        const data = 'reachability_file=test_file_data';\n\n        try {\n            await axios.post(url, data, { headers });\n        } catch (error) {\n            return false;\n        }\n\n        return true;\n    }\n}\n\nexport default UploadsReachability;\n"]},"metadata":{},"sourceType":"module"}