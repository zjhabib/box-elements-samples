{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Helper for the plain Box Upload API\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport { digest } from '../../utils/webcrypto';\nimport { getFileLastModifiedAsISONoMSIfPossible } from '../../utils/uploads';\nimport BaseUpload from './BaseUpload';\nvar CONTENT_MD5_HEADER = 'Content-MD5';\nvar PlainUpload = /*#__PURE__*/\nfunction (_BaseUpload) {\n  _inherits(PlainUpload, _BaseUpload);\n  function PlainUpload() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, PlainUpload);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(PlainUpload)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"uploadSuccessHandler\", function (_ref) {\n      var data = _ref.data;\n      var entries = data.entries;\n      if (_this.isDestroyed()) {\n        return;\n      }\n      if (typeof _this.successCallback === 'function') {\n        // Response entries are the successfully created Box File objects\n        _this.successCallback(entries);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"uploadProgressHandler\", function (event) {\n      if (_this.isDestroyed()) {\n        return;\n      }\n      if (typeof _this.progressCallback === 'function') {\n        _this.progressCallback(event);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"preflightSuccessHandler\", /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(_ref3) {\n        var data, uploadUrl, attributes, options, sha1;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = _ref3.data;\n                if (!_this.isDestroyed()) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 3:\n                // Use provided upload URL if passed in, otherwise construct\n                uploadUrl = data.upload_url;\n                if (!uploadUrl) {\n                  uploadUrl = \"\".concat(_this.getBaseUploadUrl(), \"/files/content\");\n                  if (_this.fileId) {\n                    uploadUrl = uploadUrl.replace('content', \"\".concat(_this.fileId, \"/content\"));\n                  }\n                }\n                attributes = JSON.stringify({\n                  name: _this.fileName,\n                  parent: {\n                    id: _this.folderId\n                  },\n                  description: _this.fileDescription,\n                  content_modified_at: getFileLastModifiedAsISONoMSIfPossible(_this.file)\n                });\n                options = {\n                  url: uploadUrl,\n                  data: {\n                    attributes: attributes,\n                    file: _this.file\n                  },\n                  headers: {},\n                  successHandler: _this.uploadSuccessHandler,\n                  errorHandler: _this.preflightErrorHandler,\n                  progressHandler: _this.uploadProgressHandler\n                }; // Calculate SHA1 for file consistency check\n\n                _context.next = 9;\n                return _this.computeSHA1(_this.file);\n              case 9:\n                sha1 = _context.sent;\n                if (sha1) {\n                  options.headers = _defineProperty({}, CONTENT_MD5_HEADER, sha1);\n                }\n                _this.xhr.uploadFile(options);\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    return _this;\n  }\n  _createClass(PlainUpload, [{\n    key: \"upload\",\n    /**\n     * Uploads a file. If there is a conflict and overwrite is true, replace the file.\n     * Otherwise, re-upload with a different name.\n     *\n     * @param {Object} options - Upload options\n     * @param {string} options.folderId - untyped folder id\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {File} options.file - File blob object\n     * @param {Function} [options.successCallback] - Function to call with response\n     * @param {Function} [options.errorCallback] - Function to call with errors\n     * @param {Function} [options.progressCallback] - Function to call with progress\n     * @param {Function} [options.conflictCallback] - Function to call on conflicting file names\n     * @param {boolean} [overwrite] - Should upload overwrite file with same name\n     * @return {void}\n     */\n    value: function upload(_ref4) {\n      var folderId = _ref4.folderId,\n        fileId = _ref4.fileId,\n        file = _ref4.file,\n        fileDescription = _ref4.fileDescription,\n        _ref4$successCallback = _ref4.successCallback,\n        successCallback = _ref4$successCallback === void 0 ? noop : _ref4$successCallback,\n        _ref4$errorCallback = _ref4.errorCallback,\n        errorCallback = _ref4$errorCallback === void 0 ? noop : _ref4$errorCallback,\n        _ref4$progressCallbac = _ref4.progressCallback,\n        progressCallback = _ref4$progressCallbac === void 0 ? noop : _ref4$progressCallbac,\n        conflictCallback = _ref4.conflictCallback,\n        _ref4$overwrite = _ref4.overwrite,\n        overwrite = _ref4$overwrite === void 0 ? true : _ref4$overwrite;\n      if (this.isDestroyed()) {\n        return;\n      } // Save references\n\n      this.folderId = folderId;\n      this.fileId = fileId;\n      this.file = file;\n      this.fileDescription = fileDescription;\n      this.fileName = this.file.name;\n      this.successCallback = successCallback;\n      this.errorCallback = errorCallback;\n      this.progressCallback = progressCallback;\n      this.overwrite = overwrite;\n      this.conflictCallback = conflictCallback;\n      this.makePreflightRequest();\n    }\n    /**\n     * Cancels upload of a file.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.isDestroyed()) {\n        return;\n      }\n      clearTimeout(this.retryTimeout);\n      this.destroy();\n    }\n    /**\n     * Calculates SHA1 of a file\n     *\n     * @param {File} file\n     * @return {Promise} Promise that resolves with SHA1 digest\n     */\n  }, {\n    key: \"computeSHA1\",\n    value: function () {\n      var _computeSHA = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(file) {\n        var sha1, reader, _ref5, buffer, hashBuffer, hashArray;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                sha1 = '';\n                _context2.prev = 1;\n                // Adapted from https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n                reader = new window.FileReader();\n                _context2.next = 5;\n                return this.readFile(reader, file);\n              case 5:\n                _ref5 = _context2.sent;\n                buffer = _ref5.buffer;\n                _context2.next = 9;\n                return digest('SHA-1', buffer);\n              case 9:\n                hashBuffer = _context2.sent;\n                hashArray = Array.from(new Uint8Array(hashBuffer));\n                sha1 = hashArray.map(function (b) {\n                  return \"00\".concat(b.toString(16)).slice(-2);\n                }).join('');\n                _context2.next = 16;\n                break;\n              case 14:\n                _context2.prev = 14;\n                _context2.t0 = _context2[\"catch\"](1);\n              case 16:\n                return _context2.abrupt(\"return\", sha1);\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 14]]);\n      }));\n      function computeSHA1(_x2) {\n        return _computeSHA.apply(this, arguments);\n      }\n      return computeSHA1;\n    }()\n  }]);\n  return PlainUpload;\n}(BaseUpload);\nexport default PlainUpload;","map":{"version":3,"sources":["../../../src/api/uploads/PlainUpload.js"],"names":["noop","digest","getFileLastModifiedAsISONoMSIfPossible","BaseUpload","CONTENT_MD5_HEADER","PlainUpload","data","entries","isDestroyed","successCallback","event","progressCallback","uploadUrl","upload_url","getBaseUploadUrl","fileId","replace","attributes","stringify","name","fileName","parent","id","folderId","description","fileDescription","content_modified_at","file","options","url","headers","successHandler","uploadSuccessHandler","errorHandler","preflightErrorHandler","progressHandler","uploadProgressHandler","sha1","computeSHA1","xhr","uploadFile","errorCallback","conflictCallback","overwrite","makePreflightRequest","clearTimeout","retryTimeout","destroy","reader","window","FileReader","buffer","readFile","hashBuffer","hashArray","Array","from","Uint8Array","map","b","toString","slice","join"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the plain Box Upload API\n * @author Box\n */\n\nimport noop from 'lodash/noop';\nimport { digest } from '../../utils/webcrypto';\nimport { getFileLastModifiedAsISONoMSIfPossible } from '../../utils/uploads';\nimport BaseUpload from './BaseUpload';\nimport type { BoxItem } from '../../common/types/core';\n\nconst CONTENT_MD5_HEADER = 'Content-MD5';\n\nclass PlainUpload extends BaseUpload {\n    successCallback: Function;\n\n    progressCallback: Function;\n\n    /**\n     * Handles an upload success response\n     *\n     * @param {Object} data - Upload success data\n     * @return {void}\n     */\n    uploadSuccessHandler = ({ data }: Object): void => {\n        const { entries }: { entries: BoxItem[] } = data;\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        if (typeof this.successCallback === 'function') {\n            // Response entries are the successfully created Box File objects\n            this.successCallback(entries);\n        }\n    };\n\n    /**\n     * Handles an upload progress event\n     *\n     * @param {Object} event - Progress event\n     * @return {void}\n     */\n    uploadProgressHandler = (event: ProgressEvent): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        if (typeof this.progressCallback === 'function') {\n            this.progressCallback(event);\n        }\n    };\n\n    /**\n     * Uploads a file. If a file ID is supplied, use the Upload File\n     * Version API to replace the file.\n     *\n     * @param {Object} - Request options\n     * @param {boolean} [options.url] - Upload URL to use\n     * @return {Promise} Async function promise\n     */\n    preflightSuccessHandler = async ({ data }: { data: { upload_url?: string } }): Promise<any> => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Use provided upload URL if passed in, otherwise construct\n        let uploadUrl = data.upload_url;\n        if (!uploadUrl) {\n            uploadUrl = `${this.getBaseUploadUrl()}/files/content`;\n\n            if (this.fileId) {\n                uploadUrl = uploadUrl.replace('content', `${this.fileId}/content`);\n            }\n        }\n\n        const attributes = JSON.stringify({\n            name: this.fileName,\n            parent: { id: this.folderId },\n            description: this.fileDescription,\n            content_modified_at: getFileLastModifiedAsISONoMSIfPossible(this.file),\n        });\n\n        const options = {\n            url: uploadUrl,\n            data: {\n                attributes,\n                file: this.file,\n            },\n            headers: {},\n            successHandler: this.uploadSuccessHandler,\n            errorHandler: this.preflightErrorHandler,\n            progressHandler: this.uploadProgressHandler,\n        };\n\n        // Calculate SHA1 for file consistency check\n        const sha1 = await this.computeSHA1(this.file);\n        if (sha1) {\n            options.headers = {\n                [CONTENT_MD5_HEADER]: sha1,\n            };\n        }\n\n        this.xhr.uploadFile(options);\n    };\n\n    /**\n     * Uploads a file. If there is a conflict and overwrite is true, replace the file.\n     * Otherwise, re-upload with a different name.\n     *\n     * @param {Object} options - Upload options\n     * @param {string} options.folderId - untyped folder id\n     * @param {string} [options.fileId] - Untyped file id (e.g. no \"file_\" prefix)\n     * @param {File} options.file - File blob object\n     * @param {Function} [options.successCallback] - Function to call with response\n     * @param {Function} [options.errorCallback] - Function to call with errors\n     * @param {Function} [options.progressCallback] - Function to call with progress\n     * @param {Function} [options.conflictCallback] - Function to call on conflicting file names\n     * @param {boolean} [overwrite] - Should upload overwrite file with same name\n     * @return {void}\n     */\n    upload({\n        folderId,\n        fileId,\n        file,\n        fileDescription,\n        successCallback = noop,\n        errorCallback = noop,\n        progressCallback = noop,\n        conflictCallback,\n        overwrite = true,\n    }: {\n        conflictCallback?: Function,\n        errorCallback: Function,\n        file: File,\n        fileDescription: ?string,\n        fileId: ?string,\n        folderId: string,\n        overwrite: boolean,\n        progressCallback: Function,\n        successCallback: Function,\n    }): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Save references\n        this.folderId = folderId;\n        this.fileId = fileId;\n        this.file = file;\n        this.fileDescription = fileDescription;\n        this.fileName = this.file.name;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n        this.progressCallback = progressCallback;\n        this.overwrite = overwrite;\n        this.conflictCallback = conflictCallback;\n\n        this.makePreflightRequest();\n    }\n\n    /**\n     * Cancels upload of a file.\n     *\n     * @return {void}\n     */\n    cancel() {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        clearTimeout(this.retryTimeout);\n        this.destroy();\n    }\n\n    /**\n     * Calculates SHA1 of a file\n     *\n     * @param {File} file\n     * @return {Promise} Promise that resolves with SHA1 digest\n     */\n    async computeSHA1(file: File): Promise<any> {\n        let sha1 = '';\n\n        try {\n            // Adapted from https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\n            const reader = new window.FileReader();\n            const { buffer } = await this.readFile(reader, file);\n            const hashBuffer: ArrayBuffer = await digest('SHA-1', buffer);\n            const hashArray = Array.from(new Uint8Array(hashBuffer));\n            sha1 = hashArray.map(b => `00${b.toString(16)}`.slice(-2)).join('');\n        } catch (e) {\n            // Return empty sha1 if hashing fails\n        }\n\n        return sha1;\n    }\n}\n\nexport default PlainUpload;\n"]},"metadata":{},"sourceType":"module"}