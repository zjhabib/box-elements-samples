{"ast":null,"code":"/**\n * Helper method that determines when to recalculate row or column metadata.\n */\nexport default function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n    cellSize = _ref.cellSize,\n    computeMetadataCallback = _ref.computeMetadataCallback,\n    computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n    nextCellsCount = _ref.nextCellsCount,\n    nextCellSize = _ref.nextCellSize,\n    nextScrollToIndex = _ref.nextScrollToIndex,\n    scrollToIndex = _ref.scrollToIndex,\n    updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\n\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps); // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}","map":{"version":3,"names":["calculateSizeAndPositionDataAndUpdateScrollOffset","_ref","cellCount","cellSize","computeMetadataCallback","computeMetadataCallbackProps","nextCellsCount","nextCellSize","nextScrollToIndex","scrollToIndex","updateScrollOffsetForScrollToIndex"],"sources":["/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/react-virtualized/dist/es/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js"],"sourcesContent":["/**\n * Helper method that determines when to recalculate row or column metadata.\n */\nexport default function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {\n  var cellCount = _ref.cellCount,\n      cellSize = _ref.cellSize,\n      computeMetadataCallback = _ref.computeMetadataCallback,\n      computeMetadataCallbackProps = _ref.computeMetadataCallbackProps,\n      nextCellsCount = _ref.nextCellsCount,\n      nextCellSize = _ref.nextCellSize,\n      nextScrollToIndex = _ref.nextScrollToIndex,\n      scrollToIndex = _ref.scrollToIndex,\n      updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;\n\n  // Don't compare cell sizes if they are functions because inline functions would cause infinite loops.\n  // In that event users should use the manual recompute methods to inform of changes.\n  if (cellCount !== nextCellsCount || (typeof cellSize === 'number' || typeof nextCellSize === 'number') && cellSize !== nextCellSize) {\n    computeMetadataCallback(computeMetadataCallbackProps); // Updated cell metadata may have hidden the previous scrolled-to item.\n    // In this case we should also update the scrollTop to ensure it stays visible.\n\n    if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {\n      updateScrollOffsetForScrollToIndex();\n    }\n  }\n}"],"mappings":"AAAA;AACA;AACA;AACA,eAAe,SAASA,iDAAiDA,CAACC,IAAI,EAAE;EAC9E,IAAIC,SAAS,GAAGD,IAAI,CAACC,SAAS;IAC1BC,QAAQ,GAAGF,IAAI,CAACE,QAAQ;IACxBC,uBAAuB,GAAGH,IAAI,CAACG,uBAAuB;IACtDC,4BAA4B,GAAGJ,IAAI,CAACI,4BAA4B;IAChEC,cAAc,GAAGL,IAAI,CAACK,cAAc;IACpCC,YAAY,GAAGN,IAAI,CAACM,YAAY;IAChCC,iBAAiB,GAAGP,IAAI,CAACO,iBAAiB;IAC1CC,aAAa,GAAGR,IAAI,CAACQ,aAAa;IAClCC,kCAAkC,GAAGT,IAAI,CAACS,kCAAkC;;EAEhF;EACA;EACA,IAAIR,SAAS,KAAKI,cAAc,IAAI,CAAC,OAAOH,QAAQ,KAAK,QAAQ,IAAI,OAAOI,YAAY,KAAK,QAAQ,KAAKJ,QAAQ,KAAKI,YAAY,EAAE;IACnIH,uBAAuB,CAACC,4BAA4B,CAAC,CAAC,CAAC;IACvD;;IAEA,IAAII,aAAa,IAAI,CAAC,IAAIA,aAAa,KAAKD,iBAAiB,EAAE;MAC7DE,kCAAkC,CAAC,CAAC;IACtC;EACF;AACF"},"metadata":{},"sourceType":"module"}