{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Helper for the box search api\n * @author Box\n */\nimport flatten from '../utils/flatten';\nimport { FOLDER_FIELDS_TO_FETCH } from '../utils/fields';\nimport { getBadItemError } from '../utils/error';\nimport Base from './Base';\nimport FileAPI from './File';\nimport FolderAPI from './Folder';\nimport WebLinkAPI from './WebLink';\nimport { CACHE_PREFIX_SEARCH, FIELD_RELEVANCE, FIELD_REPRESENTATIONS, X_REP_HINT_HEADER_DIMENSIONS_DEFAULT, SORT_DESC, ERROR_CODE_SEARCH } from '../constants';\nvar Search = /*#__PURE__*/\nfunction (_Base) {\n  _inherits(Search, _Base);\n  function Search() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, Search);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Search)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"searchSuccessHandler\", function (_ref) {\n      var data = _ref.data;\n      if (_this.isDestroyed()) {\n        return;\n      }\n      var entries = data.entries,\n        total_count = data.total_count,\n        limit = data.limit,\n        offset = data.offset;\n      if (!Array.isArray(entries) || typeof total_count !== 'number' || typeof limit !== 'number' || typeof offset !== 'number') {\n        throw getBadItemError();\n      }\n      var flattened = flatten(entries, new FolderAPI(_this.options), new FileAPI(_this.options), new WebLinkAPI(_this.options));\n      _this.itemCache = (_this.itemCache || []).concat(flattened);\n      _this.getCache().set(_this.key, {\n        item_collection: _objectSpread({}, data, {\n          entries: _this.itemCache\n        })\n      });\n      _this.finish();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"searchErrorHandler\", function (error) {\n      if (_this.isDestroyed()) {\n        return;\n      }\n      _this.errorCallback(error, _this.errorCode);\n    });\n    return _this;\n  }\n  _createClass(Search, [{\n    key: \"getEncodedQuery\",\n    /**\n     * @property {number}\n     */\n\n    /**\n     * @property {number}\n     */\n\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {Function}\n     */\n\n    /**\n     * @property {Function}\n     */\n\n    /**\n     * @property {Array}\n     */\n\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id folder id\n     * @param {string} query search string\n     * @return {string} key\n     */\n    value: function getEncodedQuery(query) {\n      return encodeURIComponent(query);\n    }\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id folder id\n     * @param {string} query search string\n     * @return {string} key\n     */\n  }, {\n    key: \"getCacheKey\",\n    value: function getCacheKey(id, query) {\n      return \"\".concat(CACHE_PREFIX_SEARCH).concat(id, \"|\").concat(query);\n    }\n    /**\n     * URL for search api\n     *\n     * @param {string} [id] optional file id\n     * @return {string} base url for files\n     */\n  }, {\n    key: \"getUrl\",\n    value: function getUrl() {\n      return \"\".concat(this.getBaseApiUrl(), \"/search\");\n    }\n    /**\n     * Tells if a search results has its items all loaded\n     *\n     * @return {boolean} if items are loaded\n     */\n  }, {\n    key: \"isLoaded\",\n    value: function isLoaded() {\n      var cache = this.getCache();\n      return cache.has(this.key);\n    }\n    /**\n     * Returns the results\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      if (this.isDestroyed()) {\n        return;\n      }\n      var cache = this.getCache();\n      var search = cache.get(this.key);\n      var item_collection = search.item_collection;\n      if (!item_collection) {\n        throw getBadItemError();\n      }\n      var entries = item_collection.entries,\n        total_count = item_collection.total_count;\n      if (!Array.isArray(entries) || typeof total_count !== 'number') {\n        throw getBadItemError();\n      }\n      var collection = {\n        id: this.id,\n        items: entries.map(function (key) {\n          return cache.get(key);\n        }),\n        offset: this.offset,\n        percentLoaded: 100,\n        sortBy: FIELD_RELEVANCE,\n        // Results are always sorted by relevance\n        sortDirection: SORT_DESC,\n        // Results are always sorted descending\n        totalCount: total_count\n      };\n      this.successCallback(collection);\n    }\n    /**\n     * Handles the folder search response\n     *\n     * @param {Object} response\n     * @return {void}\n     */\n  }, {\n    key: \"searchRequest\",\n    /**\n     * Does the network request\n     *\n     * @param {RequestOptions} options - options for request\n     * @return {void}\n     */\n    value: function searchRequest() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (this.isDestroyed()) {\n        return Promise.reject();\n      }\n      var fields = options.fields;\n      var requestFields = fields || FOLDER_FIELDS_TO_FETCH;\n      this.errorCode = ERROR_CODE_SEARCH;\n      return this.xhr.get({\n        url: this.getUrl(),\n        params: {\n          offset: this.offset,\n          query: this.query,\n          ancestor_folder_ids: this.id,\n          limit: this.limit,\n          fields: requestFields.toString()\n        },\n        headers: requestFields.includes(FIELD_REPRESENTATIONS) ? {\n          'X-Rep-Hints': X_REP_HINT_HEADER_DIMENSIONS_DEFAULT\n        } : {}\n      }).then(this.searchSuccessHandler).catch(this.searchErrorHandler);\n    }\n    /**\n     * Gets search results\n     *\n     * @param {string} id - folder id\n     * @param {string} query - search string\n     * @param {number} limit - maximum number of items to retrieve\n     * @param {number} offset - starting index from which to retrieve items\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.forceFetch] - Bypasses the cache\n     * @return {void}\n     */\n  }, {\n    key: \"search\",\n    value: function search(id, query, limit, offset, successCallback, errorCallback) {\n      var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n      if (this.isDestroyed()) {\n        return;\n      } // Save references\n\n      this.limit = limit;\n      this.offset = offset;\n      this.query = query;\n      this.id = id;\n      this.key = this.getCacheKey(id, this.getEncodedQuery(this.query));\n      this.successCallback = successCallback;\n      this.errorCallback = errorCallback; // Clear the cache if needed\n\n      if (options.forceFetch) {\n        this.getCache().unset(this.key);\n      } // Return the Cache value if it exists\n\n      if (this.isLoaded()) {\n        this.finish();\n        return;\n      } // Make the XHR request\n\n      this.searchRequest(options);\n    }\n  }]);\n  return Search;\n}(Base);\nexport default Search;","map":{"version":3,"sources":["../../src/api/Search.js"],"names":["flatten","FOLDER_FIELDS_TO_FETCH","getBadItemError","Base","FileAPI","FolderAPI","WebLinkAPI","CACHE_PREFIX_SEARCH","FIELD_RELEVANCE","FIELD_REPRESENTATIONS","X_REP_HINT_HEADER_DIMENSIONS_DEFAULT","SORT_DESC","ERROR_CODE_SEARCH","Search","query","encodeURIComponent","id","getBaseApiUrl","cache","getCache","has","key","isDestroyed","search","get","item_collection","entries","total_count","Array","isArray","collection","items","map","offset","percentLoaded","sortBy","sortDirection","totalCount","successCallback","data","limit","flattened","options","itemCache","concat","set","finish","error","errorCallback","errorCode","Promise","reject","fields","requestFields","xhr","url","getUrl","params","ancestor_folder_ids","toString","headers","includes","then","searchSuccessHandler","catch","searchErrorHandler","getCacheKey","getEncodedQuery","forceFetch","unset","isLoaded","searchRequest"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the box search api\n * @author Box\n */\n\nimport flatten from '../utils/flatten';\nimport { FOLDER_FIELDS_TO_FETCH } from '../utils/fields';\nimport { getBadItemError } from '../utils/error';\nimport Base from './Base';\nimport FileAPI from './File';\nimport FolderAPI from './Folder';\nimport WebLinkAPI from './WebLink';\nimport {\n    CACHE_PREFIX_SEARCH,\n    FIELD_RELEVANCE,\n    FIELD_REPRESENTATIONS,\n    X_REP_HINT_HEADER_DIMENSIONS_DEFAULT,\n    SORT_DESC,\n    ERROR_CODE_SEARCH,\n} from '../constants';\nimport type { RequestOptions, ElementsErrorCallback } from '../common/types/api';\nimport type { FlattenedBoxItem, FlattenedBoxItemCollection, Collection, BoxItemCollection } from '../common/types/core';\nimport type APICache from '../utils/Cache';\n\nclass Search extends Base {\n    /**\n     * @property {number}\n     */\n    limit: number;\n\n    /**\n     * @property {number}\n     */\n    offset: number;\n\n    /**\n     * @property {string}\n     */\n    id: string;\n\n    /**\n     * @property {string}\n     */\n    key: string;\n\n    /**\n     * @property {string}\n     */\n    query: string;\n\n    /**\n     * @property {Function}\n     */\n    successCallback: Function;\n\n    /**\n     * @property {Function}\n     */\n    errorCallback: ElementsErrorCallback;\n\n    /**\n     * @property {Array}\n     */\n    itemCache: string[];\n\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id folder id\n     * @param {string} query search string\n     * @return {string} key\n     */\n    getEncodedQuery(query: string): string {\n        return encodeURIComponent(query);\n    }\n\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id folder id\n     * @param {string} query search string\n     * @return {string} key\n     */\n    getCacheKey(id: string, query: string): string {\n        return `${CACHE_PREFIX_SEARCH}${id}|${query}`;\n    }\n\n    /**\n     * URL for search api\n     *\n     * @param {string} [id] optional file id\n     * @return {string} base url for files\n     */\n    getUrl(): string {\n        return `${this.getBaseApiUrl()}/search`;\n    }\n\n    /**\n     * Tells if a search results has its items all loaded\n     *\n     * @return {boolean} if items are loaded\n     */\n    isLoaded(): boolean {\n        const cache: APICache = this.getCache();\n        return cache.has(this.key);\n    }\n\n    /**\n     * Returns the results\n     *\n     * @return {void}\n     */\n    finish(): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const search: FlattenedBoxItem = cache.get(this.key);\n        const { item_collection }: FlattenedBoxItem = search;\n        if (!item_collection) {\n            throw getBadItemError();\n        }\n\n        const { entries, total_count }: FlattenedBoxItemCollection = item_collection;\n        if (!Array.isArray(entries) || typeof total_count !== 'number') {\n            throw getBadItemError();\n        }\n\n        const collection: Collection = {\n            id: this.id,\n            items: entries.map((key: string) => cache.get(key)),\n            offset: this.offset,\n            percentLoaded: 100,\n            sortBy: FIELD_RELEVANCE, // Results are always sorted by relevance\n            sortDirection: SORT_DESC, // Results are always sorted descending\n            totalCount: total_count,\n        };\n        this.successCallback(collection);\n    }\n\n    /**\n     * Handles the folder search response\n     *\n     * @param {Object} response\n     * @return {void}\n     */\n    searchSuccessHandler = ({ data }: { data: BoxItemCollection }): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { entries, total_count, limit, offset }: BoxItemCollection = data;\n        if (\n            !Array.isArray(entries) ||\n            typeof total_count !== 'number' ||\n            typeof limit !== 'number' ||\n            typeof offset !== 'number'\n        ) {\n            throw getBadItemError();\n        }\n\n        const flattened: string[] = flatten(\n            entries,\n            new FolderAPI(this.options),\n            new FileAPI(this.options),\n            new WebLinkAPI(this.options),\n        );\n        this.itemCache = (this.itemCache || []).concat(flattened);\n\n        this.getCache().set(this.key, {\n            item_collection: { ...data, entries: this.itemCache },\n        });\n\n        this.finish();\n    };\n\n    /**\n     * Handles the search error\n     *\n     * @param {Error} error fetch error\n     * @return {void}\n     */\n    searchErrorHandler = (error: Error): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.errorCallback(error, this.errorCode);\n    };\n\n    /**\n     * Does the network request\n     *\n     * @param {RequestOptions} options - options for request\n     * @return {void}\n     */\n    searchRequest(options: RequestOptions = {}): Promise<void> {\n        if (this.isDestroyed()) {\n            return Promise.reject();\n        }\n\n        const { fields } = options;\n        const requestFields = fields || FOLDER_FIELDS_TO_FETCH;\n\n        this.errorCode = ERROR_CODE_SEARCH;\n        return this.xhr\n            .get({\n                url: this.getUrl(),\n                params: {\n                    offset: this.offset,\n                    query: this.query,\n                    ancestor_folder_ids: this.id,\n                    limit: this.limit,\n                    fields: requestFields.toString(),\n                },\n                headers: requestFields.includes(FIELD_REPRESENTATIONS)\n                    ? {\n                          'X-Rep-Hints': X_REP_HINT_HEADER_DIMENSIONS_DEFAULT,\n                      }\n                    : {},\n            })\n            .then(this.searchSuccessHandler)\n            .catch(this.searchErrorHandler);\n    }\n\n    /**\n     * Gets search results\n     *\n     * @param {string} id - folder id\n     * @param {string} query - search string\n     * @param {number} limit - maximum number of items to retrieve\n     * @param {number} offset - starting index from which to retrieve items\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.forceFetch] - Bypasses the cache\n     * @return {void}\n     */\n    search(\n        id: string,\n        query: string,\n        limit: number,\n        offset: number,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        options: Object = {},\n    ): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Save references\n        this.limit = limit;\n        this.offset = offset;\n        this.query = query;\n        this.id = id;\n        this.key = this.getCacheKey(id, this.getEncodedQuery(this.query));\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Clear the cache if needed\n        if (options.forceFetch) {\n            this.getCache().unset(this.key);\n        }\n\n        // Return the Cache value if it exists\n        if (this.isLoaded()) {\n            this.finish();\n            return;\n        }\n\n        // Make the XHR request\n        this.searchRequest(options);\n    }\n}\n\nexport default Search;\n"]},"metadata":{},"sourceType":"module"}