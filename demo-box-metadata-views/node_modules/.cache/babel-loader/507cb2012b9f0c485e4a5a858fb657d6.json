{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * \n * @file A simple in-memory cache\n * @author Box\n */\nimport _merge from 'lodash/merge';\nvar Cache = /*#__PURE__*/\nfunction () {\n  /**\n   * @property {*}\n   */\n\n  /**\n   * [constructor]\n   *\n   * @return {Cache} Cache instance\n   */\n  function Cache() {\n    _classCallCheck(this, Cache);\n    this.cache = {};\n  }\n  /**\n   * Caches a simple object in memory.\n   *\n   * @param {string} key The cache key\n   * @param {*} value The cache value\n   * @return {void}\n   */\n\n  _createClass(Cache, [{\n    key: \"set\",\n    value: function set(key, value) {\n      this.cache[key] = value;\n    }\n    /**\n     * Merges cached values for objects.\n     *\n     * @param {string} key The cache key\n     * @param {*} value The cache value\n     * @return {void}\n     */\n  }, {\n    key: \"merge\",\n    value: function merge(key, value) {\n      if (this.has(key)) {\n        this.set(key, _merge({}, this.get(key), value));\n      } else {\n        throw new Error(\"Key \".concat(key, \" not in cache!\"));\n      }\n    }\n    /**\n     * Deletes object from in-memory cache.\n     *\n     * @param {string} key The cache key\n     * @return {void}\n     */\n  }, {\n    key: \"unset\",\n    value: function unset(key) {\n      delete this.cache[key];\n    }\n    /**\n     * Deletes all object from in-memory cache\n     * that match the key as prefix.\n     *\n     * @param {string} prefix The cache key prefix\n     * @return {void}\n     */\n  }, {\n    key: \"unsetAll\",\n    value: function unsetAll(prefix) {\n      var _this = this;\n      Object.keys(this.cache).forEach(function (key) {\n        if (key.startsWith(prefix)) {\n          delete _this.cache[key];\n        }\n      });\n    }\n    /**\n     * Checks if cache has provided key.\n     *\n     * @param {string} key The cache key\n     * @return {boolean} Whether the cache has key\n     */\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return {}.hasOwnProperty.call(this.cache, key);\n    }\n    /**\n     * Fetches a cached object from in-memory cache if available.\n     *\n     * @param {string} key Key of cached object\n     * @return {*} Cached object\n     */\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      if (this.has(key)) {\n        return this.cache[key];\n      }\n      return undefined;\n    }\n  }]);\n  return Cache;\n}();\nexport default Cache;","map":{"version":3,"sources":["../../src/utils/Cache.js"],"names":["merge","Cache","cache","key","value","has","set","get","Error","prefix","Object","keys","forEach","startsWith","hasOwnProperty","call","undefined"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAMA,OAAOA,MAAP,MAAkB,cAAlB;IAGMC,K;;EACF;;;;EAKA;;;;;EAKA,SAAA,KAAA,CAAA,EAAc;IAAA,eAAA,CAAA,IAAA,EAAA,KAAA,CAAA;IACV,IAAA,CAAKC,KAAL,GAAa,CAAA,CAAb;EACH;EAED;;;;;;;;;;wBAOIC,G,EAAaC,K,EAAkB;MAC/B,IAAA,CAAKF,KAAL,CAAWC,GAAX,CAAA,GAAkBC,KAAlB;IACH;IAED;;;;;;;;;0BAOMD,G,EAAaC,K,EAAkB;MACjC,IAAI,IAAA,CAAKC,GAAL,CAASF,GAAT,CAAJ,EAAmB;QACf,IAAA,CAAKG,GAAL,CAASH,GAAT,EAAcH,MAAK,CAAC,CAAA,CAAD,EAAK,IAAA,CAAKO,GAAL,CAASJ,GAAT,CAAL,EAAoBC,KAApB,CAAnB,CAAA;MACH,CAFD,MAEO;QACH,MAAM,IAAII,KAAJ,CAAA,MAAA,CAAA,MAAA,CAAiBL,GAAjB,EAAA,gBAAA,CAAA,CAAN;MACH;IACJ;IAED;;;;;;;;0BAMMA,G,EAAmB;MACrB,OAAO,IAAA,CAAKD,KAAL,CAAWC,GAAX,CAAP;IACH;IAED;;;;;;;;;6BAOSM,M,EAAsB;MAAA,IAAA,KAAA,GAAA,IAAA;MAC3BC,MAAM,CAACC,IAAPD,CAAY,IAAA,CAAKR,KAAjBQ,CAAAA,CAAwBE,OAAxBF,CAAgC,UAACP,GAAD,EAAiB;QAC7C,IAAIA,GAAG,CAACU,UAAJV,CAAeM,MAAfN,CAAJ,EAA4B;UACxB,OAAO,KAAI,CAACD,KAAL,CAAWC,GAAX,CAAP;QACH;MACJ,CAJDO,CAAAA;IAKH;IAED;;;;;;;;wBAMIP,G,EAAsB;MACtB,OAAO,CAAA,CAAA,CAAGW,cAAH,CAAkBC,IAAlB,CAAuB,IAAA,CAAKb,KAA5B,EAAmCC,GAAnC,CAAP;IACH;IAED;;;;;;;;wBAMIA,G,EAAkB;MAClB,IAAI,IAAA,CAAKE,GAAL,CAASF,GAAT,CAAJ,EAAmB;QACf,OAAO,IAAA,CAAKD,KAAL,CAAWC,GAAX,CAAP;MACH;MAED,OAAOa,SAAP;IACH;;;;AAGL,eAAef,KAAf","sourcesContent":["/**\n * @flow\n * @file A simple in-memory cache\n * @author Box\n */\n\nimport merge from 'lodash/merge';\nimport type { StringAnyMap } from '../common/types/core';\n\nclass Cache {\n    /**\n     * @property {*}\n     */\n    cache: StringAnyMap;\n\n    /**\n     * [constructor]\n     *\n     * @return {Cache} Cache instance\n     */\n    constructor() {\n        this.cache = {};\n    }\n\n    /**\n     * Caches a simple object in memory.\n     *\n     * @param {string} key The cache key\n     * @param {*} value The cache value\n     * @return {void}\n     */\n    set(key: string, value: any): void {\n        this.cache[key] = value;\n    }\n\n    /**\n     * Merges cached values for objects.\n     *\n     * @param {string} key The cache key\n     * @param {*} value The cache value\n     * @return {void}\n     */\n    merge(key: string, value: any): void {\n        if (this.has(key)) {\n            this.set(key, merge({}, this.get(key), value));\n        } else {\n            throw new Error(`Key ${key} not in cache!`);\n        }\n    }\n\n    /**\n     * Deletes object from in-memory cache.\n     *\n     * @param {string} key The cache key\n     * @return {void}\n     */\n    unset(key: string): void {\n        delete this.cache[key];\n    }\n\n    /**\n     * Deletes all object from in-memory cache\n     * that match the key as prefix.\n     *\n     * @param {string} prefix The cache key prefix\n     * @return {void}\n     */\n    unsetAll(prefix: string): void {\n        Object.keys(this.cache).forEach((key: string) => {\n            if (key.startsWith(prefix)) {\n                delete this.cache[key];\n            }\n        });\n    }\n\n    /**\n     * Checks if cache has provided key.\n     *\n     * @param {string} key The cache key\n     * @return {boolean} Whether the cache has key\n     */\n    has(key: string): boolean {\n        return {}.hasOwnProperty.call(this.cache, key);\n    }\n\n    /**\n     * Fetches a cached object from in-memory cache if available.\n     *\n     * @param {string} key Key of cached object\n     * @return {*} Cached object\n     */\n    get(key: string): any {\n        if (this.has(key)) {\n            return this.cache[key];\n        }\n\n        return undefined;\n    }\n}\n\nexport default Cache;\n"]},"metadata":{},"sourceType":"module"}