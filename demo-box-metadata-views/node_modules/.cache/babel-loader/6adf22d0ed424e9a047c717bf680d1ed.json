{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Helper for the box metadata query API\n * @author Box\n */\nimport Base from './Base';\nimport { CACHE_PREFIX_METADATA_QUERY, ERROR_CODE_METADATA_QUERY } from '../constants';\nvar MetadataQuery = /*#__PURE__*/\nfunction (_Base) {\n  _inherits(MetadataQuery, _Base);\n  function MetadataQuery() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, MetadataQuery);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MetadataQuery)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"queryMetadataSuccessHandler\", function (_ref) {\n      var data = _ref.data;\n      var cache = _this.getCache();\n      cache.set(_this.key, data);\n      _this.finish();\n    });\n    return _this;\n  }\n  _createClass(MetadataQuery, [{\n    key: \"getCacheKey\",\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {Function}\n     */\n\n    /**\n     * @property {Function}\n     */\n\n    /**\n     * Creates a key for the metadata cache\n     *\n     * @param {string} id - metadata template\n     * @return {string} key\n     */\n    value: function getCacheKey(id) {\n      return \"\".concat(CACHE_PREFIX_METADATA_QUERY).concat(id);\n    }\n    /**\n     * API URL for metadata query\n     * @return {string} base url for files\n     */\n  }, {\n    key: \"getUrl\",\n    value: function getUrl() {\n      return \"\".concat(this.getBaseApiUrl(), \"/metadata_queries/execute_read\");\n    }\n    /**\n     * Returns true for cache hit for metadata query results\n     *\n     * @return {boolean} if query results are loaded\n     */\n  }, {\n    key: \"isLoaded\",\n    value: function isLoaded() {\n      var cache = this.getCache();\n      return cache.has(this.key);\n    }\n    /**\n     * Returns the results using successCallback\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      if (this.isDestroyed()) {\n        return;\n      }\n      var cache = this.getCache();\n      var metadataQueryData = cache.get(this.key);\n      this.successCallback(metadataQueryData);\n    }\n    /**\n     * @param {Object} response\n     */\n  }, {\n    key: \"queryMetadataRequest\",\n    /**\n     * Does the network request to metadata query API\n     * @param {Object} query query object with SQL Clauses like properties\n     * @return {void}\n     */\n    value: function queryMetadataRequest(query) {\n      if (this.isDestroyed()) {\n        return;\n      }\n      this.errorCode = ERROR_CODE_METADATA_QUERY;\n      this.xhr.post({\n        url: this.getUrl(),\n        data: query\n      }).then(this.queryMetadataSuccessHandler).catch(this.errorHandler);\n    }\n    /**\n     * API for querying enterprise metadata\n     * @param {Object} query - metadata query object\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.forceFetch] - Bypasses the cache\n     * @return {void}\n     */\n  }, {\n    key: \"queryMetadata\",\n    value: function queryMetadata(query, successCallback, errorCallback) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (this.isDestroyed()) {\n        return;\n      }\n      var _options$context = options.context,\n        context = _options$context === void 0 ? {} : _options$context;\n      this.key = this.getCacheKey(context.id);\n      this.successCallback = successCallback;\n      this.errorCallback = errorCallback; // Clear the cache if needed\n\n      if (options.forceFetch) {\n        this.getCache().unset(this.key);\n      } // Return the Cache value if it exists\n\n      if (this.isLoaded()) {\n        this.finish();\n        return;\n      } // Make the XHR request\n\n      this.queryMetadataRequest(query);\n    }\n  }]);\n  return MetadataQuery;\n}(Base);\nexport default MetadataQuery;","map":{"version":3,"sources":["../../src/api/MetadataQuery.js"],"names":["Base","CACHE_PREFIX_METADATA_QUERY","ERROR_CODE_METADATA_QUERY","MetadataQuery","id","getBaseApiUrl","cache","getCache","has","key","isDestroyed","metadataQueryData","get","successCallback","data","set","finish","query","errorCode","xhr","post","url","getUrl","then","queryMetadataSuccessHandler","catch","errorHandler","errorCallback","options","context","getCacheKey","forceFetch","unset","isLoaded","queryMetadataRequest"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the box metadata query API\n * @author Box\n */\n\nimport Base from './Base';\nimport { CACHE_PREFIX_METADATA_QUERY, ERROR_CODE_METADATA_QUERY } from '../constants';\nimport type { ElementsErrorCallback } from '../common/types/api';\nimport type { MetadataQuery as MetadataQueryType, MetadataQueryResponseData } from '../common/types/metadataQueries';\nimport type APICache from '../utils/Cache';\n\nclass MetadataQuery extends Base {\n    /**\n     * @property {string}\n     */\n    key: string;\n\n    /**\n     * @property {Function}\n     */\n    successCallback: Function;\n\n    /**\n     * @property {Function}\n     */\n    errorCallback: ElementsErrorCallback;\n\n    /**\n     * Creates a key for the metadata cache\n     *\n     * @param {string} id - metadata template\n     * @return {string} key\n     */\n    getCacheKey(id: string): string {\n        return `${CACHE_PREFIX_METADATA_QUERY}${id}`;\n    }\n\n    /**\n     * API URL for metadata query\n     * @return {string} base url for files\n     */\n    getUrl(): string {\n        return `${this.getBaseApiUrl()}/metadata_queries/execute_read`;\n    }\n\n    /**\n     * Returns true for cache hit for metadata query results\n     *\n     * @return {boolean} if query results are loaded\n     */\n    isLoaded(): boolean {\n        const cache: APICache = this.getCache();\n        return cache.has(this.key);\n    }\n\n    /**\n     * Returns the results using successCallback\n     *\n     * @return {void}\n     */\n    finish(): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const metadataQueryData = cache.get(this.key);\n        this.successCallback(metadataQueryData);\n    }\n\n    /**\n     * @param {Object} response\n     */\n    queryMetadataSuccessHandler = ({ data }: { data: MetadataQueryResponseData }): void => {\n        const cache: APICache = this.getCache();\n        cache.set(this.key, data);\n        this.finish();\n    };\n\n    /**\n     * Does the network request to metadata query API\n     * @param {Object} query query object with SQL Clauses like properties\n     * @return {void}\n     */\n    queryMetadataRequest(query: MetadataQueryType): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.errorCode = ERROR_CODE_METADATA_QUERY;\n        this.xhr\n            .post({\n                url: this.getUrl(),\n                data: query,\n            })\n            .then(this.queryMetadataSuccessHandler)\n            .catch(this.errorHandler);\n    }\n\n    /**\n     * API for querying enterprise metadata\n     * @param {Object} query - metadata query object\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.forceFetch] - Bypasses the cache\n     * @return {void}\n     */\n    queryMetadata(\n        query: MetadataQueryType,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        options: Object = {},\n    ): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { context = {} } = options;\n        this.key = this.getCacheKey(context.id);\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Clear the cache if needed\n        if (options.forceFetch) {\n            this.getCache().unset(this.key);\n        }\n\n        // Return the Cache value if it exists\n        if (this.isLoaded()) {\n            this.finish();\n            return;\n        }\n\n        // Make the XHR request\n        this.queryMetadataRequest(query);\n    }\n}\n\nexport default MetadataQuery;\n"]},"metadata":{},"sourceType":"module"}