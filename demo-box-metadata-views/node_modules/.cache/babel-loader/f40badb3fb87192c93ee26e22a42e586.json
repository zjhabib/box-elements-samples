{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Folder upload bootstrapping\n * @author Box\n */\nimport { getEntryFromDataTransferItem, getFile, getFileAPIOptions, getDataTransferItem, getDataTransferItemAPIOptions } from '../../utils/uploads';\nimport FolderUploadNode from './FolderUploadNode';\nvar PATH_DELIMITER = '/';\nvar FolderUpload = /*#__PURE__*/\nfunction () {\n  /**\n   * [constructor]\n   *\n   * @param {Function} addFilesToUploadQueue\n   * @param {string} destinationFolderId\n   * @param {Function} addFolderToUploadQueue\n   * @param {Object} baseAPIOptions\n   * @return {void}\n   */\n  function FolderUpload(addFilesToUploadQueue, destinationFolderId, addFolderToUploadQueue, baseAPIOptions) {\n    _classCallCheck(this, FolderUpload);\n    _defineProperty(this, \"files\", []);\n    this.addFilesToUploadQueue = addFilesToUploadQueue;\n    this.destinationFolderId = destinationFolderId;\n    this.addFolderToUploadQueue = addFolderToUploadQueue;\n    this.baseAPIOptions = baseAPIOptions;\n  }\n  /**\n   * Create a folder tree from fileList wekbkitRelativePath\n   *\n   * @public\n   * @param  {Array} Array<UploadFileWithAPIOptions | UploadFile> | FileList\n   * @returns {void}\n   */\n\n  _createClass(FolderUpload, [{\n    key: \"buildFolderTreeFromWebkitRelativePath\",\n    value: function buildFolderTreeFromWebkitRelativePath(fileList) {\n      var _this = this;\n      Array.from(fileList).forEach(function (fileData) {\n        var file = getFile(fileData);\n        var webkitRelativePath = file.webkitRelativePath;\n        if (!webkitRelativePath) {\n          return;\n        }\n        var fileAPIOptions = getFileAPIOptions(fileData);\n        var pathArray = webkitRelativePath.split(PATH_DELIMITER).slice(0, -1);\n        if (pathArray.length <= 0) {\n          return;\n        } // Since only 1 folder tree can be uploaded a time with using webkitRelativePath, the root folder name\n        // of all the files should be the same.\n\n        if (!_this.folder) {\n          var rootFolderName = pathArray[0];\n          _this.folder = _this.createFolderUploadNode(rootFolderName, fileAPIOptions);\n        } // Add file to the root folder\n\n        if (pathArray.length === 1) {\n          _this.folder.files.push(file);\n        }\n        var subTree = _this.folder.folders; // Walk the path after the root folder\n\n        var pathArryAfterRoot = pathArray.slice(1);\n        pathArryAfterRoot.forEach(function (folderName, index) {\n          // Create new child folder\n          if (!subTree[folderName]) {\n            subTree[folderName] = _this.createFolderUploadNode(folderName, fileAPIOptions);\n          }\n          if (index === pathArryAfterRoot.length - 1) {\n            // end of path, push the file\n            subTree[folderName].files.push(file);\n          } else {\n            // walk the tree\n            subTree = subTree[folderName].folders;\n          }\n        });\n      });\n    }\n    /**\n     * Build folder tree from dataTransferItem, which can only represent 1 folder tree\n     *\n     * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} dataTransferItem\n     * @returns {Promise<any>}\n     */\n  }, {\n    key: \"buildFolderTreeFromDataTransferItem\",\n    value: function () {\n      var _buildFolderTreeFromDataTransferItem = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(dataTransferItem) {\n        var item, apiOptions, entry, name;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                item = getDataTransferItem(dataTransferItem);\n                apiOptions = getDataTransferItemAPIOptions(dataTransferItem);\n                entry = getEntryFromDataTransferItem(item);\n                name = entry.name;\n                this.folder = this.createFolderUploadNode(name, apiOptions, entry);\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function buildFolderTreeFromDataTransferItem(_x) {\n        return _buildFolderTreeFromDataTransferItem.apply(this, arguments);\n      }\n      return buildFolderTreeFromDataTransferItem;\n    }()\n    /**\n     * Create a FolderUploadNode instance\n     *\n     * @param {string} name\n     * @param {Object} apiOptions\n     * @param {FileSystemFileEntry} [entry]\n     * @returns {FolderUploadNode}\n     */\n  }, {\n    key: \"createFolderUploadNode\",\n    value: function createFolderUploadNode(name, apiOptions, entry) {\n      return new FolderUploadNode(name, this.addFilesToUploadQueue, this.addFolderToUploadQueue, apiOptions, _objectSpread({}, this.baseAPIOptions, {}, apiOptions), entry);\n    }\n    /**\n     * Upload folders\n     *\n     * @public\n     * @param {Object} Options\n     * @param {Function} options.errorCallback\n     * @returns {Promise<any>}\n     */\n  }, {\n    key: \"upload\",\n    value: function () {\n      var _upload = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(_ref) {\n        var errorCallback, successCallback, newFolderId;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                errorCallback = _ref.errorCallback, successCallback = _ref.successCallback;\n                _context2.next = 3;\n                return this.folder.upload(this.destinationFolderId, errorCallback, true);\n              case 3:\n                // If the folder upload failed then a folderID will not be set\n                newFolderId = this.folder.getFolderId();\n                if (newFolderId) {\n                  successCallback([{\n                    id: newFolderId\n                  }]);\n                }\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function upload(_x2) {\n        return _upload.apply(this, arguments);\n      }\n      return upload;\n    }()\n    /**\n     * Noop cancel\n     *\n     * @public\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {}\n  }]);\n  return FolderUpload;\n}();\nexport default FolderUpload;","map":{"version":3,"sources":["../../../src/api/uploads/FolderUpload.js"],"names":["getEntryFromDataTransferItem","getFile","getFileAPIOptions","getDataTransferItem","getDataTransferItemAPIOptions","FolderUploadNode","PATH_DELIMITER","FolderUpload","addFilesToUploadQueue","destinationFolderId","addFolderToUploadQueue","baseAPIOptions","fileList","Array","from","forEach","file","fileData","webkitRelativePath","fileAPIOptions","pathArray","split","slice","length","folder","rootFolderName","createFolderUploadNode","files","push","subTree","folders","pathArryAfterRoot","folderName","index","dataTransferItem","item","apiOptions","entry","name","errorCallback","successCallback","upload","newFolderId","getFolderId","id"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Folder upload bootstrapping\n * @author Box\n */\n\nimport {\n    getEntryFromDataTransferItem,\n    getFile,\n    getFileAPIOptions,\n    getDataTransferItem,\n    getDataTransferItemAPIOptions,\n} from '../../utils/uploads';\nimport FolderUploadNode from './FolderUploadNode';\nimport type {\n    UploadDataTransferItemWithAPIOptions,\n    UploadFileWithAPIOptions,\n    UploadFile,\n    FileSystemFileEntry,\n} from '../../common/types/upload';\n\nconst PATH_DELIMITER = '/';\n\nclass FolderUpload {\n    folder: FolderUploadNode;\n\n    files: Array<UploadFile> = [];\n\n    destinationFolderId: string;\n\n    addFilesToUploadQueue: Function;\n\n    addFolderToUploadQueue: Function;\n\n    baseAPIOptions: Object;\n\n    /**\n     * [constructor]\n     *\n     * @param {Function} addFilesToUploadQueue\n     * @param {string} destinationFolderId\n     * @param {Function} addFolderToUploadQueue\n     * @param {Object} baseAPIOptions\n     * @return {void}\n     */\n    constructor(\n        addFilesToUploadQueue: Function,\n        destinationFolderId: string,\n        addFolderToUploadQueue: Function,\n        baseAPIOptions: Object,\n    ): void {\n        this.addFilesToUploadQueue = addFilesToUploadQueue;\n        this.destinationFolderId = destinationFolderId;\n        this.addFolderToUploadQueue = addFolderToUploadQueue;\n        this.baseAPIOptions = baseAPIOptions;\n    }\n\n    /**\n     * Create a folder tree from fileList wekbkitRelativePath\n     *\n     * @public\n     * @param  {Array} Array<UploadFileWithAPIOptions | UploadFile> | FileList\n     * @returns {void}\n     */\n    buildFolderTreeFromWebkitRelativePath(fileList: Array<UploadFileWithAPIOptions | UploadFile> | FileList): void {\n        Array.from(fileList).forEach(fileData => {\n            const file = getFile(fileData);\n            const { webkitRelativePath } = file;\n\n            if (!webkitRelativePath) {\n                return;\n            }\n\n            const fileAPIOptions = getFileAPIOptions(fileData);\n            const pathArray = webkitRelativePath.split(PATH_DELIMITER).slice(0, -1);\n            if (pathArray.length <= 0) {\n                return;\n            }\n\n            // Since only 1 folder tree can be uploaded a time with using webkitRelativePath, the root folder name\n            // of all the files should be the same.\n            if (!this.folder) {\n                const rootFolderName = pathArray[0];\n                this.folder = this.createFolderUploadNode(rootFolderName, fileAPIOptions);\n            }\n\n            // Add file to the root folder\n            if (pathArray.length === 1) {\n                this.folder.files.push(file);\n            }\n\n            let subTree = this.folder.folders;\n            // Walk the path after the root folder\n            const pathArryAfterRoot = pathArray.slice(1);\n            pathArryAfterRoot.forEach((folderName, index) => {\n                // Create new child folder\n                if (!subTree[folderName]) {\n                    subTree[folderName] = this.createFolderUploadNode(folderName, fileAPIOptions);\n                }\n\n                if (index === pathArryAfterRoot.length - 1) {\n                    // end of path, push the file\n                    subTree[folderName].files.push(file);\n                } else {\n                    // walk the tree\n                    subTree = subTree[folderName].folders;\n                }\n            });\n        });\n    }\n\n    /**\n     * Build folder tree from dataTransferItem, which can only represent 1 folder tree\n     *\n     * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} dataTransferItem\n     * @returns {Promise<any>}\n     */\n    async buildFolderTreeFromDataTransferItem(\n        dataTransferItem: DataTransferItem | UploadDataTransferItemWithAPIOptions,\n    ) {\n        const item = getDataTransferItem(dataTransferItem);\n        const apiOptions = getDataTransferItemAPIOptions(dataTransferItem);\n        const entry = getEntryFromDataTransferItem(item);\n        const { name } = entry;\n\n        this.folder = this.createFolderUploadNode(name, apiOptions, entry);\n    }\n\n    /**\n     * Create a FolderUploadNode instance\n     *\n     * @param {string} name\n     * @param {Object} apiOptions\n     * @param {FileSystemFileEntry} [entry]\n     * @returns {FolderUploadNode}\n     */\n    createFolderUploadNode(name: string, apiOptions: Object, entry?: FileSystemFileEntry): FolderUploadNode {\n        return new FolderUploadNode(\n            name,\n            this.addFilesToUploadQueue,\n            this.addFolderToUploadQueue,\n            apiOptions,\n            {\n                ...this.baseAPIOptions,\n                ...apiOptions,\n            },\n            entry,\n        );\n    }\n\n    /**\n     * Upload folders\n     *\n     * @public\n     * @param {Object} Options\n     * @param {Function} options.errorCallback\n     * @returns {Promise<any>}\n     */\n    async upload({\n        errorCallback,\n        successCallback,\n    }: {\n        errorCallback: Function,\n        successCallback: Function,\n    }): Promise<any> {\n        await this.folder.upload(this.destinationFolderId, errorCallback, true);\n        // If the folder upload failed then a folderID will not be set\n        const newFolderId = this.folder.getFolderId();\n        if (newFolderId) {\n            successCallback([\n                {\n                    id: newFolderId,\n                },\n            ]);\n        }\n    }\n\n    /**\n     * Noop cancel\n     *\n     * @public\n     */\n    cancel() {}\n}\n\nexport default FolderUpload;\n"]},"metadata":{},"sourceType":"module"}