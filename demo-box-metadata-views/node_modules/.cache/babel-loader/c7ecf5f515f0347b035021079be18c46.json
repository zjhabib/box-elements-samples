{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Skills sidebar component\n * @author Box\n */\nimport * as React from 'react';\nimport flow from 'lodash/flow';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport { FormattedMessage } from 'react-intl';\nimport API from '../../api';\nimport LoadingIndicator from '../../components/loading-indicator/LoadingIndicator';\nimport messages from '../common/messages';\nimport SidebarContent from './SidebarContent';\nimport SidebarSkills from './skills/SidebarSkills';\nimport { EVENT_JS_READY } from '../common/logger/constants';\nimport { mark } from '../../utils/performance';\nimport { withAPIContext } from '../common/api-context';\nimport { withErrorBoundary } from '../common/error-boundary';\nimport { withLogger } from '../common/logger';\nimport { FIELD_PERMISSIONS_CAN_UPLOAD, SKILLS_TRANSCRIPT, ORIGIN_SKILLS_SIDEBAR, SIDEBAR_VIEW_SKILLS } from '../../constants';\nimport './SkillsSidebar.scss';\nvar MARK_NAME_JS_READY = \"\".concat(ORIGIN_SKILLS_SIDEBAR, \"_\").concat(EVENT_JS_READY);\nmark(MARK_NAME_JS_READY);\nvar SkillsSidebar = /*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(SkillsSidebar, _React$PureComponent);\n  function SkillsSidebar(props) {\n    var _this;\n    _classCallCheck(this, SkillsSidebar);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SkillsSidebar).call(this, props));\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      errors: {}\n    });\n    _defineProperty(_assertThisInitialized(_this), \"fetchSkillsSuccessCallback\", function (cards) {\n      _this.updatePreviewTranscript(cards);\n      _this.setState({\n        cards: cards\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"updatePreviewTranscript\", function (cards) {\n      var _this$props = _this.props,\n        getPreview = _this$props.getPreview,\n        getViewer = _this$props.getViewer;\n      var preview = getPreview ? getPreview() : null;\n      var viewer = getViewer ? getViewer() : null;\n      var transcriptCard = cards.find(function (card) {\n        return card.skill_card_type === SKILLS_TRANSCRIPT;\n      });\n      if (!transcriptCard || !preview) {\n        return;\n      }\n      if (!viewer) {\n        preview.addListener('load', function (_ref) {\n          var loadedViewer = _ref.viewer;\n          if (typeof loadedViewer.loadAutoGeneratedCaptions === 'function') {\n            loadedViewer.loadAutoGeneratedCaptions(transcriptCard);\n          }\n        });\n      } else if (typeof viewer.loadAutoGeneratedCaptions === 'function') {\n        viewer.loadAutoGeneratedCaptions(transcriptCard);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onSaveSuccessHandler\", function (index, updatedCards) {\n      var errors = _this.state.errors;\n      var clone = _objectSpread({}, errors);\n      delete clone[index];\n      _this.updatePreviewTranscript(updatedCards);\n      _this.setState({\n        cards: updatedCards,\n        errors: clone\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onSaveErrorHandler\", function (index) {\n      var errors = _this.state.errors;\n      var clone = _objectSpread({}, errors);\n      clone[index] = true;\n      _this.setState({\n        errors: clone\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onSave\", function (index) {\n      var removes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var adds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var replaces = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var _this$props2 = _this.props,\n        api = _this$props2.api,\n        file = _this$props2.file;\n      var _this$state$cards = _this.state.cards,\n        cards = _this$state$cards === void 0 ? [] : _this$state$cards;\n      var card = cards[index];\n      var path = \"/cards/\".concat(index);\n      var ops = [];\n      var canEdit = getProp(file, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n      if (!canEdit || !card) {\n        return;\n      }\n      if (Array.isArray(replaces)) {\n        replaces.forEach(function (_ref2) {\n          var replaced = _ref2.replaced,\n            replacement = _ref2.replacement;\n          var idx = card.entries.findIndex(function (entry) {\n            return entry === replaced;\n          });\n          if (idx > -1) {\n            ops.push({\n              op: 'replace',\n              path: \"\".concat(path, \"/entries/\").concat(idx),\n              value: replacement\n            });\n          }\n        });\n      }\n      if (Array.isArray(removes)) {\n        var deletes = [];\n        removes.forEach(function (removed) {\n          var idx = card.entries.findIndex(function (entry) {\n            return entry === removed;\n          });\n          if (idx > -1) {\n            deletes.push(idx);\n          }\n        }); // To maintain metadata index positions, removes should be\n        // done is reverse order with largest index being removed first.\n        // Remove operations are atomic and don't happen in batch.\n\n        deletes.sort(function (a, b) {\n          return b - a;\n        }) // number sort in descending order\n        .forEach(function (idx) {\n          ops.push({\n            op: 'remove',\n            path: \"\".concat(path, \"/entries/\").concat(idx)\n          });\n        });\n      }\n      if (Array.isArray(adds)) {\n        adds.forEach(function (added) {\n          ops.push({\n            op: 'add',\n            path: \"\".concat(path, \"/entries/-\"),\n            value: added\n          });\n        });\n      } // If no ops, don't proceed\n\n      if (ops.length === 0) {\n        return;\n      } // Add test ops before any other ops\n\n      ops.splice(0, 0, {\n        op: 'test',\n        path: path,\n        value: card\n      });\n      api.getMetadataAPI(false).updateSkills(file, ops, function (updatedCards) {\n        _this.onSaveSuccessHandler(index, updatedCards);\n      }, function () {\n        _this.onSaveErrorHandler(index);\n      });\n    });\n    var logger = _this.props.logger;\n    logger.onReadyMetric({\n      endMarkName: MARK_NAME_JS_READY\n    });\n    return _this;\n  }\n  _createClass(SkillsSidebar, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props3 = this.props,\n        api = _this$props3.api,\n        file = _this$props3.file;\n      api.getMetadataAPI(false).getSkills(file, this.fetchSkillsSuccessCallback, noop);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(_ref3) {\n      var prevRefreshIdentity = _ref3.refreshIdentity;\n      var _this$props4 = this.props,\n        api = _this$props4.api,\n        file = _this$props4.file,\n        refreshIdentity = _this$props4.refreshIdentity;\n      if (refreshIdentity !== prevRefreshIdentity) {\n        api.getMetadataAPI(false).getSkills(file, this.fetchSkillsSuccessCallback, noop);\n      }\n    }\n    /**\n     * Handles skills fetch success\n     *\n     * @private\n     * @param {Array<SkillCard>} cards - Skills cards\n     * @return {void}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props5 = this.props,\n        file = _this$props5.file,\n        getViewer = _this$props5.getViewer,\n        elementId = _this$props5.elementId;\n      var _this$state = this.state,\n        cards = _this$state.cards,\n        errors = _this$state.errors;\n      return React.createElement(SidebarContent, {\n        className: \"bcs-skills\",\n        elementId: elementId,\n        sidebarView: SIDEBAR_VIEW_SKILLS,\n        title: React.createElement(FormattedMessage, messages.sidebarSkillsTitle)\n      }, cards ? React.createElement(SidebarSkills, {\n        cards: cards,\n        errors: errors,\n        file: file,\n        getViewer: getViewer,\n        onSkillChange: this.onSave\n      }) : React.createElement(LoadingIndicator, null));\n    }\n  }]);\n  return SkillsSidebar;\n}(React.PureComponent);\nexport { SkillsSidebar as SkillsSidebarComponent };\nexport default flow([withLogger(ORIGIN_SKILLS_SIDEBAR), withErrorBoundary(ORIGIN_SKILLS_SIDEBAR), withAPIContext])(SkillsSidebar);","map":{"version":3,"sources":["../../../src/elements/content-sidebar/SkillsSidebar.js"],"names":["React","flow","getProp","noop","FormattedMessage","API","LoadingIndicator","messages","SidebarContent","SidebarSkills","EVENT_JS_READY","mark","withAPIContext","withErrorBoundary","withLogger","FIELD_PERMISSIONS_CAN_UPLOAD","SKILLS_TRANSCRIPT","ORIGIN_SKILLS_SIDEBAR","SIDEBAR_VIEW_SKILLS","MARK_NAME_JS_READY","SkillsSidebar","PureComponent","errors","props","logger","onReadyMetric","endMarkName","api","file","getMetadataAPI","getSkills","fetchSkillsSuccessCallback","refreshIdentity","prevRefreshIdentity","cards","updatePreviewTranscript","setState","getPreview","getViewer","preview","viewer","transcriptCard","find","card","skill_card_type","addListener","loadedViewer","loadAutoGeneratedCaptions","index","updatedCards","state","clone","removes","adds","replaces","path","ops","canEdit","Array","isArray","forEach","replaced","replacement","idx","entries","findIndex","entry","push","op","value","deletes","removed","sort","a","b","added","length","splice","updateSkills","onSaveSuccessHandler","onSaveErrorHandler","elementId","sidebarSkillsTitle","onSave","SkillsSidebarComponent"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Skills sidebar component\n * @author Box\n */\n\nimport * as React from 'react';\nimport flow from 'lodash/flow';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport { FormattedMessage } from 'react-intl';\nimport API from '../../api';\nimport LoadingIndicator from '../../components/loading-indicator/LoadingIndicator';\nimport messages from '../common/messages';\nimport SidebarContent from './SidebarContent';\nimport SidebarSkills from './skills/SidebarSkills';\nimport { EVENT_JS_READY } from '../common/logger/constants';\nimport { mark } from '../../utils/performance';\nimport { withAPIContext } from '../common/api-context';\nimport { withErrorBoundary } from '../common/error-boundary';\nimport { withLogger } from '../common/logger';\nimport {\n    FIELD_PERMISSIONS_CAN_UPLOAD,\n    SKILLS_TRANSCRIPT,\n    ORIGIN_SKILLS_SIDEBAR,\n    SIDEBAR_VIEW_SKILLS,\n} from '../../constants';\nimport type { WithLoggerProps } from '../../common/types/logging';\nimport type { SkillCardEntry, SkillCard } from '../../common/types/skills';\nimport type { NumberBooleanMap, BoxItem } from '../../common/types/core';\nimport type { JSONPatchOperations } from '../../common/types/api';\nimport './SkillsSidebar.scss';\n\ntype PropsWithoutContext = {\n    elementId: string,\n    file: BoxItem,\n    getPreview: Function,\n    getViewer: Function,\n    hasSidebarInitialized?: boolean,\n    refreshIdentity?: boolean,\n};\n\ntype Props = {\n    api: API,\n} & PropsWithoutContext &\n    WithLoggerProps;\n\ntype State = {\n    cards?: Array<SkillCard>,\n    errors: NumberBooleanMap,\n};\n\nconst MARK_NAME_JS_READY = `${ORIGIN_SKILLS_SIDEBAR}_${EVENT_JS_READY}`;\n\nmark(MARK_NAME_JS_READY);\n\nclass SkillsSidebar extends React.PureComponent<Props, State> {\n    state: State = {\n        errors: {},\n    };\n\n    constructor(props: Props) {\n        super(props);\n        const { logger } = this.props;\n        logger.onReadyMetric({\n            endMarkName: MARK_NAME_JS_READY,\n        });\n    }\n\n    componentDidMount() {\n        const { api, file }: Props = this.props;\n        api.getMetadataAPI(false).getSkills(file, this.fetchSkillsSuccessCallback, noop);\n    }\n\n    componentDidUpdate({ refreshIdentity: prevRefreshIdentity }: Props) {\n        const { api, file, refreshIdentity }: Props = this.props;\n\n        if (refreshIdentity !== prevRefreshIdentity) {\n            api.getMetadataAPI(false).getSkills(file, this.fetchSkillsSuccessCallback, noop);\n        }\n    }\n\n    /**\n     * Handles skills fetch success\n     *\n     * @private\n     * @param {Array<SkillCard>} cards - Skills cards\n     * @return {void}\n     */\n    fetchSkillsSuccessCallback = (cards: Array<SkillCard>) => {\n        this.updatePreviewTranscript(cards);\n        this.setState({ cards });\n    };\n\n    /**\n     * Updates Preview with transcript data\n     *\n     * @private\n     * @param {Array<SkillCard>} cards - Skills cards\n     * @return {void}\n     */\n    updatePreviewTranscript = (cards: Array<SkillCard>): void => {\n        const { getPreview, getViewer } = this.props;\n        const preview = getPreview ? getPreview() : null;\n        const viewer = getViewer ? getViewer() : null;\n        const transcriptCard = cards.find(card => card.skill_card_type === SKILLS_TRANSCRIPT);\n        if (!transcriptCard || !preview) {\n            return;\n        }\n\n        if (!viewer) {\n            preview.addListener('load', ({ viewer: loadedViewer }) => {\n                if (typeof loadedViewer.loadAutoGeneratedCaptions === 'function') {\n                    loadedViewer.loadAutoGeneratedCaptions(transcriptCard);\n                }\n            });\n        } else if (typeof viewer.loadAutoGeneratedCaptions === 'function') {\n            viewer.loadAutoGeneratedCaptions(transcriptCard);\n        }\n    };\n\n    /**\n     * Success handler for save\n     *\n     * @private\n     * @param {Array} updatedCards - updated skill cards\n     * @param {number} index - index of the card being edited\n     * @return {void}\n     */\n    onSaveSuccessHandler = (index: number, updatedCards: Array<SkillCard>): void => {\n        const { errors }: State = this.state;\n        const clone = { ...errors };\n        delete clone[index];\n        this.updatePreviewTranscript(updatedCards);\n        this.setState({ cards: updatedCards, errors: clone });\n    };\n\n    /**\n     * Error handler for save\n     *\n     * @private\n     * @param {number} index - index of the card being edited\n     * @return {void}\n     */\n    onSaveErrorHandler = (index: number): void => {\n        const { errors }: State = this.state;\n        const clone = { ...errors };\n        clone[index] = true;\n        this.setState({ errors: clone });\n    };\n\n    /**\n     * Updates skill metadata\n     *\n     * @private\n     * @param {number} index - index of the card being edited\n     * @param {Array} removes - entries to remove\n     * @param {Array} adds - entries to add\n     * @param {Array} replaces - entries to replace\n     * @return {void}\n     */\n    onSave = (\n        index: number,\n        removes: Array<SkillCardEntry> = [],\n        adds: Array<SkillCardEntry> = [],\n        replaces: Array<{\n            replaced: SkillCardEntry,\n            replacement: SkillCardEntry,\n        }> = [],\n    ): void => {\n        const { api, file }: Props = this.props;\n        const { cards = [] }: State = this.state;\n        const card = cards[index];\n        const path = `/cards/${index}`;\n        const ops: JSONPatchOperations = [];\n        const canEdit = getProp(file, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n\n        if (!canEdit || !card) {\n            return;\n        }\n\n        if (Array.isArray(replaces)) {\n            replaces.forEach(({ replaced, replacement }) => {\n                const idx = card.entries.findIndex(entry => entry === replaced);\n                if (idx > -1) {\n                    ops.push({\n                        op: 'replace',\n                        path: `${path}/entries/${idx}`,\n                        value: replacement,\n                    });\n                }\n            });\n        }\n\n        if (Array.isArray(removes)) {\n            const deletes = [];\n            removes.forEach(removed => {\n                const idx = card.entries.findIndex(entry => entry === removed);\n                if (idx > -1) {\n                    deletes.push(idx);\n                }\n            });\n            // To maintain metadata index positions, removes should be\n            // done is reverse order with largest index being removed first.\n            // Remove operations are atomic and don't happen in batch.\n            deletes\n                .sort((a, b) => b - a) // number sort in descending order\n                .forEach(idx => {\n                    ops.push({\n                        op: 'remove',\n                        path: `${path}/entries/${idx}`,\n                    });\n                });\n        }\n\n        if (Array.isArray(adds)) {\n            adds.forEach(added => {\n                ops.push({\n                    op: 'add',\n                    path: `${path}/entries/-`,\n                    value: added,\n                });\n            });\n        }\n\n        // If no ops, don't proceed\n        if (ops.length === 0) {\n            return;\n        }\n\n        // Add test ops before any other ops\n        ops.splice(0, 0, {\n            op: 'test',\n            path,\n            value: card,\n        });\n\n        api.getMetadataAPI(false).updateSkills(\n            file,\n            ops,\n            (updatedCards: Array<SkillCard>) => {\n                this.onSaveSuccessHandler(index, updatedCards);\n            },\n            () => {\n                this.onSaveErrorHandler(index);\n            },\n        );\n    };\n\n    render() {\n        const { file, getViewer, elementId }: Props = this.props;\n        const { cards, errors }: State = this.state;\n\n        return (\n            <SidebarContent\n                className=\"bcs-skills\"\n                elementId={elementId}\n                sidebarView={SIDEBAR_VIEW_SKILLS}\n                title={<FormattedMessage {...messages.sidebarSkillsTitle} />}\n            >\n                {cards ? (\n                    <SidebarSkills\n                        cards={cards}\n                        errors={errors}\n                        file={file}\n                        getViewer={getViewer}\n                        onSkillChange={this.onSave}\n                    />\n                ) : (\n                    <LoadingIndicator />\n                )}\n            </SidebarContent>\n        );\n    }\n}\n\nexport { SkillsSidebar as SkillsSidebarComponent };\nexport default flow([withLogger(ORIGIN_SKILLS_SIDEBAR), withErrorBoundary(ORIGIN_SKILLS_SIDEBAR), withAPIContext])(\n    SkillsSidebar,\n);\n"]},"metadata":{},"sourceType":"module"}