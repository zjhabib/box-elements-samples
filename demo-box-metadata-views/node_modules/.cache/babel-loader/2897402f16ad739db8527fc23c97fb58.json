{"ast":null,"code":"function ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * \n * @file Utility for sidebar\n * @author Box\n */\nimport * as React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport AsyncLoad from '../common/async-load';\nimport messages from '../common/messages';\nimport SidebarLoading from './SidebarLoading';\nimport SidebarLoadingError from './SidebarLoadingError';\nimport { hasSkills as hasSkillsData } from './skills/skillUtils';\nimport { mark } from '../../utils/performance';\nimport { SIDEBAR_VIEW_SKILLS, SIDEBAR_VIEW_ACTIVITY, SIDEBAR_VIEW_METADATA, SIDEBAR_VIEW_DETAILS, SIDEBAR_VIEW_VERSIONS } from '../../constants';\nvar SidebarUtils = /*#__PURE__*/\nfunction () {\n  function SidebarUtils() {\n    _classCallCheck(this, SidebarUtils);\n  }\n  _createClass(SidebarUtils, null, [{\n    key: \"canHaveDetailsSidebar\",\n    /**\n     * Determines if we can render the details sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should render\n     */\n    value: function canHaveDetailsSidebar(_ref) {\n      var _ref$detailsSidebarPr = _ref.detailsSidebarProps,\n        detailsSidebarProps = _ref$detailsSidebarPr === void 0 ? {} : _ref$detailsSidebarPr;\n      var hasProperties = detailsSidebarProps.hasProperties,\n        hasAccessStats = detailsSidebarProps.hasAccessStats,\n        hasClassification = detailsSidebarProps.hasClassification,\n        hasVersions = detailsSidebarProps.hasVersions,\n        hasNotices = detailsSidebarProps.hasNotices;\n      return !!hasProperties || !!hasAccessStats || !!hasClassification || !!hasVersions || !!hasNotices;\n    }\n    /**\n     * Determines if we can render the metadata sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should render\n     */\n  }, {\n    key: \"canHaveMetadataSidebar\",\n    value: function canHaveMetadataSidebar(props) {\n      return !!props.hasMetadata;\n    }\n    /**\n     * Determines if we can render the activity sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should render\n     */\n  }, {\n    key: \"canHaveActivitySidebar\",\n    value: function canHaveActivitySidebar(props) {\n      return !!props.hasActivityFeed;\n    }\n    /**\n     * Determines if we can render the skills sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should render\n     */\n  }, {\n    key: \"canHaveSkillsSidebar\",\n    value: function canHaveSkillsSidebar(props) {\n      return !!props.hasSkills;\n    }\n    /**\n     * Determines if we can render the sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should have a sidebar\n     */\n  }, {\n    key: \"canHaveSidebar\",\n    value: function canHaveSidebar(props) {\n      return SidebarUtils.canHaveDetailsSidebar(props) || SidebarUtils.canHaveActivitySidebar(props) || SidebarUtils.canHaveSkillsSidebar(props) || SidebarUtils.canHaveMetadataSidebar(props);\n    }\n    /**\n     * Determines if we should bother rendering the skills sidebar.\n     * Relies on props and file data.\n     *\n     * @private\n     * @param {ContentSidebarProps} props - User passed in props\n     * @param {BoxItem} file - box file\n     * @return {Boolean} true if we should render\n     */\n  }, {\n    key: \"shouldRenderSkillsSidebar\",\n    value: function shouldRenderSkillsSidebar(props, file) {\n      return !!file && SidebarUtils.canHaveSkillsSidebar(props) && hasSkillsData(file);\n    }\n    /**\n     * Determines if we should bother rendering the metadata sidebar.\n     * Relies on props and metadata data and feature enabled or not.\n     *\n     * @private\n     * @param {ContentSidebarProps} props - User passed in props\n     * @param {Array<MetadataEditor>} editors - metadata editors\n     * @return {Boolean} true if we should render\n     */\n  }, {\n    key: \"shouldRenderMetadataSidebar\",\n    value: function shouldRenderMetadataSidebar(props, editors) {\n      var _props$metadataSideba = props.metadataSidebarProps,\n        metadataSidebarProps = _props$metadataSideba === void 0 ? {} : _props$metadataSideba;\n      var _metadataSidebarProps = metadataSidebarProps.isFeatureEnabled,\n        isFeatureEnabled = _metadataSidebarProps === void 0 ? true : _metadataSidebarProps;\n      return SidebarUtils.canHaveMetadataSidebar(props) && (isFeatureEnabled || Array.isArray(editors) && editors.length > 0);\n    }\n    /**\n     * Determines if we should bother rendering the sidebar.\n     * Relies on props and file data.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @param {BoxItem} file - box file\n     * @param {Array<MetadataEditor>} editors - metadata editors\n     * @return {Boolean} true if we should fetch or render\n     */\n  }, {\n    key: \"shouldRenderSidebar\",\n    value: function shouldRenderSidebar(props, file, editors) {\n      return !!file && (SidebarUtils.canHaveDetailsSidebar(props) || SidebarUtils.shouldRenderSkillsSidebar(props, file) || SidebarUtils.canHaveActivitySidebar(props) || SidebarUtils.shouldRenderMetadataSidebar(props, editors));\n    }\n    /**\n     * Gets the title for a given sidebar view\n     *\n     * @param {string} view - the view name\n     * @return {React.Node} - the node to render\n     */\n  }, {\n    key: \"getTitleForView\",\n    value: function getTitleForView(view) {\n      switch (view) {\n        case SIDEBAR_VIEW_SKILLS:\n          return React.createElement(FormattedMessage, messages.sidebarSkillsTitle);\n        case SIDEBAR_VIEW_DETAILS:\n          return React.createElement(FormattedMessage, messages.sidebarDetailsTitle);\n        case SIDEBAR_VIEW_METADATA:\n          return React.createElement(FormattedMessage, messages.sidebarMetadataTitle);\n        case SIDEBAR_VIEW_ACTIVITY:\n          return React.createElement(FormattedMessage, messages.sidebarActivityTitle);\n        default:\n          return null;\n      }\n    }\n    /**\n     * Marks and gets the loader for a given sidebar view\n     *\n     * @param {String} view - the view name\n     * @param {String} markName -  the name to be used by performance.mark\n     * @return {Function} - a function which will resolve the module to load\n     */\n  }, {\n    key: \"getLoaderForView\",\n    value: function getLoaderForView(view, markName) {\n      mark(markName);\n      var importFn;\n      switch (view) {\n        case SIDEBAR_VIEW_SKILLS:\n          importFn = import( /* webpackMode: \"lazy\", webpackChunkName: \"skills-sidebar\" */\n          './SkillsSidebar');\n          break;\n        case SIDEBAR_VIEW_DETAILS:\n          importFn = import( /* webpackMode: \"lazy\", webpackChunkName: \"details-sidebar\" */\n          './DetailsSidebar');\n          break;\n        case SIDEBAR_VIEW_METADATA:\n          importFn = import( /* webpackMode: \"lazy\", webpackChunkName: \"metadata-sidebar\" */\n          './MetadataSidebar');\n          break;\n        case SIDEBAR_VIEW_ACTIVITY:\n          importFn = import( /* webpackMode: \"lazy\", webpackChunkName: \"activity-sidebar\" */\n          './ActivitySidebar');\n          break;\n        case SIDEBAR_VIEW_VERSIONS:\n          importFn = import( /* webpackMode: \"lazy\", webpackChunkName: \"versions-sidebar\" */\n          './versions');\n          break;\n        default:\n          return Promise.resolve(null);\n      }\n      return importFn;\n    }\n    /**\n     * Gets the component which async loads a given sidebar view\n     *\n     * @param {String} view - the view name\n     * @param {String} markName -  the name to be used by performance.mark\n     * @param {Object} props - additional props\n     * @return {React.Node} - the node to render\n     */\n  }, {\n    key: \"getAsyncSidebarContent\",\n    value: function getAsyncSidebarContent(view, markName) {\n      var _this = this;\n      var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return AsyncLoad(_objectSpread({\n        errorComponent: SidebarLoadingError,\n        fallback: React.createElement(SidebarLoading, {\n          title: this.getTitleForView(view)\n        }),\n        loader: function loader() {\n          return _this.getLoaderForView(view, markName);\n        }\n      }, props));\n    }\n  }]);\n  return SidebarUtils;\n}();\nexport default SidebarUtils;","map":{"version":3,"sources":["../../../src/elements/content-sidebar/SidebarUtils.js"],"names":["React","FormattedMessage","AsyncLoad","messages","SidebarLoading","SidebarLoadingError","hasSkills","hasSkillsData","mark","SIDEBAR_VIEW_SKILLS","SIDEBAR_VIEW_ACTIVITY","SIDEBAR_VIEW_METADATA","SIDEBAR_VIEW_DETAILS","SIDEBAR_VIEW_VERSIONS","SidebarUtils","detailsSidebarProps","hasProperties","hasAccessStats","hasClassification","hasVersions","hasNotices","props","hasMetadata","hasActivityFeed","canHaveDetailsSidebar","canHaveActivitySidebar","canHaveSkillsSidebar","canHaveMetadataSidebar","file","editors","metadataSidebarProps","isFeatureEnabled","Array","isArray","length","shouldRenderSkillsSidebar","shouldRenderMetadataSidebar","view","sidebarSkillsTitle","sidebarDetailsTitle","sidebarMetadataTitle","sidebarActivityTitle","markName","importFn","Promise","resolve","errorComponent","fallback","getTitleForView","loader","getLoaderForView"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Utility for sidebar\n * @author Box\n */\nimport * as React from 'react';\nimport { FormattedMessage } from 'react-intl';\nimport AsyncLoad from '../common/async-load';\nimport messages from '../common/messages';\nimport SidebarLoading from './SidebarLoading';\nimport SidebarLoadingError from './SidebarLoadingError';\nimport { hasSkills as hasSkillsData } from './skills/skillUtils';\nimport { mark } from '../../utils/performance';\nimport {\n    SIDEBAR_VIEW_SKILLS,\n    SIDEBAR_VIEW_ACTIVITY,\n    SIDEBAR_VIEW_METADATA,\n    SIDEBAR_VIEW_DETAILS,\n    SIDEBAR_VIEW_VERSIONS,\n} from '../../constants';\nimport type { MetadataSidebarProps } from './MetadataSidebar';\nimport type { MetadataEditor } from '../../common/types/metadata';\nimport type { BoxItem } from '../../common/types/core';\n\nclass SidebarUtils {\n    /**\n     * Determines if we can render the details sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should render\n     */\n    static canHaveDetailsSidebar({ detailsSidebarProps = {} }: ContentSidebarProps): boolean {\n        const { hasProperties, hasAccessStats, hasClassification, hasVersions, hasNotices } = detailsSidebarProps;\n        return !!hasProperties || !!hasAccessStats || !!hasClassification || !!hasVersions || !!hasNotices;\n    }\n\n    /**\n     * Determines if we can render the metadata sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should render\n     */\n    static canHaveMetadataSidebar(props: ContentSidebarProps): boolean {\n        return !!props.hasMetadata;\n    }\n\n    /**\n     * Determines if we can render the activity sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should render\n     */\n    static canHaveActivitySidebar(props: ContentSidebarProps): boolean {\n        return !!props.hasActivityFeed;\n    }\n\n    /**\n     * Determines if we can render the skills sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should render\n     */\n    static canHaveSkillsSidebar(props: ContentSidebarProps): boolean {\n        return !!props.hasSkills;\n    }\n\n    /**\n     * Determines if we can render the sidebar.\n     * Only relies on props.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @return {Boolean} true if we should have a sidebar\n     */\n    static canHaveSidebar(props: ContentSidebarProps): boolean {\n        return (\n            SidebarUtils.canHaveDetailsSidebar(props) ||\n            SidebarUtils.canHaveActivitySidebar(props) ||\n            SidebarUtils.canHaveSkillsSidebar(props) ||\n            SidebarUtils.canHaveMetadataSidebar(props)\n        );\n    }\n\n    /**\n     * Determines if we should bother rendering the skills sidebar.\n     * Relies on props and file data.\n     *\n     * @private\n     * @param {ContentSidebarProps} props - User passed in props\n     * @param {BoxItem} file - box file\n     * @return {Boolean} true if we should render\n     */\n    static shouldRenderSkillsSidebar(props: ContentSidebarProps, file?: BoxItem): boolean {\n        return !!file && SidebarUtils.canHaveSkillsSidebar(props) && hasSkillsData(file);\n    }\n\n    /**\n     * Determines if we should bother rendering the metadata sidebar.\n     * Relies on props and metadata data and feature enabled or not.\n     *\n     * @private\n     * @param {ContentSidebarProps} props - User passed in props\n     * @param {Array<MetadataEditor>} editors - metadata editors\n     * @return {Boolean} true if we should render\n     */\n    static shouldRenderMetadataSidebar(props: ContentSidebarProps, editors?: Array<MetadataEditor>): boolean {\n        const { metadataSidebarProps = {} }: ContentSidebarProps = props;\n        const { isFeatureEnabled = true }: MetadataSidebarProps = metadataSidebarProps;\n\n        return (\n            SidebarUtils.canHaveMetadataSidebar(props) &&\n            (isFeatureEnabled || (Array.isArray(editors) && editors.length > 0))\n        );\n    }\n\n    /**\n     * Determines if we should bother rendering the sidebar.\n     * Relies on props and file data.\n     *\n     * @param {ContentSidebarProps} props - User passed in props\n     * @param {BoxItem} file - box file\n     * @param {Array<MetadataEditor>} editors - metadata editors\n     * @return {Boolean} true if we should fetch or render\n     */\n    static shouldRenderSidebar(props: ContentSidebarProps, file?: BoxItem, editors?: Array<MetadataEditor>): boolean {\n        return (\n            !!file &&\n            (SidebarUtils.canHaveDetailsSidebar(props) ||\n                SidebarUtils.shouldRenderSkillsSidebar(props, file) ||\n                SidebarUtils.canHaveActivitySidebar(props) ||\n                SidebarUtils.shouldRenderMetadataSidebar(props, editors))\n        );\n    }\n\n    /**\n     * Gets the title for a given sidebar view\n     *\n     * @param {string} view - the view name\n     * @return {React.Node} - the node to render\n     */\n    static getTitleForView(view: string): React.Node {\n        switch (view) {\n            case SIDEBAR_VIEW_SKILLS:\n                return <FormattedMessage {...messages.sidebarSkillsTitle} />;\n            case SIDEBAR_VIEW_DETAILS:\n                return <FormattedMessage {...messages.sidebarDetailsTitle} />;\n            case SIDEBAR_VIEW_METADATA:\n                return <FormattedMessage {...messages.sidebarMetadataTitle} />;\n            case SIDEBAR_VIEW_ACTIVITY:\n                return <FormattedMessage {...messages.sidebarActivityTitle} />;\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Marks and gets the loader for a given sidebar view\n     *\n     * @param {String} view - the view name\n     * @param {String} markName -  the name to be used by performance.mark\n     * @return {Function} - a function which will resolve the module to load\n     */\n    static getLoaderForView(view: string, markName: string): Promise<any> {\n        mark(markName);\n        let importFn;\n        switch (view) {\n            case SIDEBAR_VIEW_SKILLS:\n                importFn = import(/* webpackMode: \"lazy\", webpackChunkName: \"skills-sidebar\" */ './SkillsSidebar');\n                break;\n            case SIDEBAR_VIEW_DETAILS:\n                importFn = import(/* webpackMode: \"lazy\", webpackChunkName: \"details-sidebar\" */ './DetailsSidebar');\n                break;\n            case SIDEBAR_VIEW_METADATA:\n                importFn = import(/* webpackMode: \"lazy\", webpackChunkName: \"metadata-sidebar\" */ './MetadataSidebar');\n                break;\n            case SIDEBAR_VIEW_ACTIVITY:\n                importFn = import(/* webpackMode: \"lazy\", webpackChunkName: \"activity-sidebar\" */ './ActivitySidebar');\n                break;\n            case SIDEBAR_VIEW_VERSIONS:\n                importFn = import(/* webpackMode: \"lazy\", webpackChunkName: \"versions-sidebar\" */ './versions');\n                break;\n            default:\n                return Promise.resolve(null);\n        }\n\n        return importFn;\n    }\n\n    /**\n     * Gets the component which async loads a given sidebar view\n     *\n     * @param {String} view - the view name\n     * @param {String} markName -  the name to be used by performance.mark\n     * @param {Object} props - additional props\n     * @return {React.Node} - the node to render\n     */\n    static getAsyncSidebarContent(view: string, markName: string, props: Object = {}) {\n        return AsyncLoad({\n            errorComponent: SidebarLoadingError,\n            fallback: <SidebarLoading title={this.getTitleForView(view)} />,\n            loader: () => this.getLoaderForView(view, markName),\n            ...props,\n        });\n    }\n}\n\nexport default SidebarUtils;\n"]},"metadata":{},"sourceType":"module"}