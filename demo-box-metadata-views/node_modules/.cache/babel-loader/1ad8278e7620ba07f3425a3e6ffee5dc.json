{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport tabbable from 'tabbable';\nimport omit from 'lodash/omit';\nimport FocusTrap from '../focus-trap';\nimport LoadingIndicator from '../loading-indicator';\nimport Portal from '../portal';\nimport ModalDialog from './ModalDialog';\nimport './Modal.scss';\nvar Modal = /*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Modal, _React$Component);\n  function Modal() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, Modal);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Modal)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"onKeyDown\", function (event) {\n      var _this$props = _this.props,\n        isOpen = _this$props.isOpen,\n        onRequestClose = _this$props.onRequestClose;\n      if (isOpen && onRequestClose && event.key === 'Escape') {\n        event.stopPropagation();\n        onRequestClose(event);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onBackdropClick\", function (event) {\n      var _this$props2 = _this.props,\n        onRequestClose = _this$props2.onRequestClose,\n        onBackdropClick = _this$props2.onBackdropClick;\n      if (onBackdropClick) {\n        onBackdropClick(event);\n      } else if (onRequestClose) {\n        onRequestClose(event);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onModalOpen\", function () {\n      setTimeout(function () {\n        var focusElementSelector = _this.props.focusElementSelector;\n        var focusElementSelectorTrimmed = focusElementSelector && focusElementSelector.trim();\n        if (focusElementSelectorTrimmed) {\n          _this.focusElement(focusElementSelectorTrimmed);\n        } else {\n          _this.focusFirstUsefulElement();\n        }\n      }, 0);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"focusFirstUsefulElement\", function () {\n      if (!_this.dialog) {\n        return;\n      }\n      var tabbableEls = tabbable(_this.dialog);\n      if (tabbableEls.length > 1) {\n        tabbableEls[1].focus();\n      } else if (tabbableEls.length > 0) {\n        tabbableEls[0].focus();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"focusElement\", function (elementSelector) {\n      if (!_this.dialog) {\n        return;\n      }\n      var el = _this.dialog.querySelector(elementSelector);\n      if (el) {\n        el.focus();\n      } else {\n        throw new Error(\"Could not find element matching selector \".concat(elementSelector, \" to focus on.\"));\n      }\n    });\n    return _this;\n  }\n  _createClass(Modal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var isOpen = this.props.isOpen;\n      if (isOpen) {\n        this.onModalOpen();\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props3 = this.props,\n        isLoading = _this$props3.isLoading,\n        isOpen = _this$props3.isOpen; // Set focus if modal is transitioning from closed -> open and/or loading -> not loading\n\n      if ((!prevProps.isOpen || prevProps.isLoading) && isOpen && !isLoading) {\n        this.onModalOpen();\n      }\n    }\n    /**\n     * Call props.onRequestClose when escape is pressed\n     * @param {SyntheticKeyboardEvent} event\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var _this$props4 = this.props,\n        className = _this$props4.className,\n        isLoading = _this$props4.isLoading,\n        isOpen = _this$props4.isOpen,\n        onRequestClose = _this$props4.onRequestClose,\n        shouldNotUsePortal = _this$props4.shouldNotUsePortal,\n        style = _this$props4.style,\n        rest = _objectWithoutProperties(_this$props4, [\"className\", \"isLoading\", \"isOpen\", \"onRequestClose\", \"shouldNotUsePortal\", \"style\"]);\n      if (!isOpen) {\n        return null;\n      }\n      var bodyOverrideStyle = \"\\n            body {\\n                overflow:hidden;\\n            }\\n        \"; // used `omit` here to prevent certain key/value pairs from going into the spread on `ModalDialog`\n\n      var modalProps = omit(rest, ['onBackdropClick', 'focusElementSelector']);\n      var WrapperComponent = shouldNotUsePortal ? 'div' : Portal; // Render a style tag to prevent body from scrolling as long as the Modal is open\n\n      return React.createElement(WrapperComponent, {\n        className: classNames('modal', className),\n        onKeyDown: this.onKeyDown,\n        tabIndex: \"-1\"\n      }, React.createElement(\"div\", {\n        className: \"modal-backdrop\",\n        onClick: this.onBackdropClick,\n        style: style.backdrop\n      }), React.createElement(FocusTrap, {\n        className: \"modal-dialog-container\"\n      }, isLoading ? React.createElement(LoadingIndicator, {\n        size: \"large\"\n      }) : React.createElement(ModalDialog, _extends({\n        modalRef: function modalRef(modalEl) {\n          // This callback gets passed through as a regular prop since\n          // ModalDialog is wrapped in a HOC\n          _this2.dialog = modalEl;\n        },\n        onRequestClose: onRequestClose,\n        style: style.dialog\n      }, modalProps))), React.createElement(\"style\", {\n        type: \"text/css\"\n      }, bodyOverrideStyle));\n    }\n  }]);\n  return Modal;\n}(React.Component);\n_defineProperty(Modal, \"defaultProps\", {\n  style: {\n    backdrop: {},\n    dialog: {}\n  }\n});\nexport default Modal;","map":{"version":3,"sources":["../../../src/components/modal/Modal.js"],"names":["React","classNames","tabbable","omit","FocusTrap","LoadingIndicator","Portal","ModalDialog","Modal","Component","style","backdrop","dialog","isOpen","props","onModalOpen","prevProps","isLoading","event","onRequestClose","key","stopPropagation","onBackdropClick","setTimeout","focusElementSelector","focusElementSelectorTrimmed","trim","focusElement","focusFirstUsefulElement","tabbableEls","length","focus","elementSelector","el","querySelector","Error","className","shouldNotUsePortal","rest","bodyOverrideStyle","modalProps","WrapperComponent","onKeyDown","modalEl"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport tabbable from 'tabbable';\nimport omit from 'lodash/omit';\n\nimport FocusTrap from '../focus-trap';\nimport LoadingIndicator from '../loading-indicator';\nimport Portal from '../portal';\nimport ModalDialog from './ModalDialog';\n\nimport './Modal.scss';\n\ntype Props = {\n    children: React.Node,\n    /** Additional CSS classname of the `.modal` element */\n    className?: string,\n    focusElementSelector?: string,\n    isLoading?: boolean,\n    isOpen?: boolean,\n    onBackdropClick?: Function,\n    /** `(event) => {}`. `event` can be of type `SyntheticKeyboardEvent|SyntheticMouseEvent`. */\n    onRequestClose?: Function,\n    /** modal usually use Portal as Portal stays if parent is removed, but it cannot retain DOM tree's resin props */\n    shouldNotUsePortal?: boolean,\n    style: {\n        backdrop?: Object,\n        dialog?: Object,\n    },\n    title?: React.Node,\n};\n\nclass Modal extends React.Component<Props> {\n    static defaultProps = {\n        style: {\n            backdrop: {},\n            dialog: {},\n        },\n    };\n\n    componentDidMount() {\n        const { isOpen } = this.props;\n\n        if (isOpen) {\n            this.onModalOpen();\n        }\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        const { isLoading, isOpen } = this.props;\n\n        // Set focus if modal is transitioning from closed -> open and/or loading -> not loading\n        if ((!prevProps.isOpen || prevProps.isLoading) && isOpen && !isLoading) {\n            this.onModalOpen();\n        }\n    }\n\n    /**\n     * Call props.onRequestClose when escape is pressed\n     * @param {SyntheticKeyboardEvent} event\n     */\n    onKeyDown = (event: SyntheticKeyboardEvent<>) => {\n        const { isOpen, onRequestClose } = this.props;\n        if (isOpen && onRequestClose && event.key === 'Escape') {\n            event.stopPropagation();\n            onRequestClose(event);\n        }\n    };\n\n    /**\n     * Call props.onRequestClose when backdrop is clicked\n     * @param {SyntheticMouseEvent} event\n     */\n    onBackdropClick = (event: SyntheticMouseEvent<HTMLDivElement>) => {\n        const { onRequestClose, onBackdropClick } = this.props;\n\n        if (onBackdropClick) {\n            onBackdropClick(event);\n        } else if (onRequestClose) {\n            onRequestClose(event);\n        }\n    };\n\n    /**\n     * Focuses on the correct element in the popup when it opens\n     */\n    onModalOpen = () => {\n        setTimeout(() => {\n            const { focusElementSelector } = this.props;\n            const focusElementSelectorTrimmed = focusElementSelector && focusElementSelector.trim();\n            if (focusElementSelectorTrimmed) {\n                this.focusElement(focusElementSelectorTrimmed);\n            } else {\n                this.focusFirstUsefulElement();\n            }\n        }, 0);\n    };\n\n    dialog: ?HTMLElement;\n\n    /**\n     * Focus the first useful element in the modal (i.e. not the close button, unless it's the only thing)\n     */\n    focusFirstUsefulElement = () => {\n        if (!this.dialog) {\n            return;\n        }\n        const tabbableEls = tabbable(this.dialog);\n        if (tabbableEls.length > 1) {\n            tabbableEls[1].focus();\n        } else if (tabbableEls.length > 0) {\n            tabbableEls[0].focus();\n        }\n    };\n\n    /**\n     * Focus the element that matches the selector in the modal\n     * @throws {Error} When the elementSelector does not match any element\n     */\n    focusElement = (elementSelector: string) => {\n        if (!this.dialog) {\n            return;\n        }\n        const el = this.dialog.querySelector(elementSelector);\n        if (el) {\n            el.focus();\n        } else {\n            throw new Error(`Could not find element matching selector ${elementSelector} to focus on.`);\n        }\n    };\n\n    render() {\n        const { className, isLoading, isOpen, onRequestClose, shouldNotUsePortal, style, ...rest } = this.props;\n\n        if (!isOpen) {\n            return null;\n        }\n\n        const bodyOverrideStyle = `\n            body {\n                overflow:hidden;\n            }\n        `;\n\n        // used `omit` here to prevent certain key/value pairs from going into the spread on `ModalDialog`\n        const modalProps = omit(rest, ['onBackdropClick', 'focusElementSelector']);\n\n        const WrapperComponent = shouldNotUsePortal ? 'div' : Portal;\n        // Render a style tag to prevent body from scrolling as long as the Modal is open\n        return (\n            <WrapperComponent className={classNames('modal', className)} onKeyDown={this.onKeyDown} tabIndex=\"-1\">\n                {/* eslint-disable-next-line jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events */}\n                <div className=\"modal-backdrop\" onClick={this.onBackdropClick} style={style.backdrop} />\n                <FocusTrap className=\"modal-dialog-container\">\n                    {isLoading ? (\n                        <LoadingIndicator size=\"large\" />\n                    ) : (\n                        <ModalDialog\n                            modalRef={modalEl => {\n                                // This callback gets passed through as a regular prop since\n                                // ModalDialog is wrapped in a HOC\n                                this.dialog = modalEl;\n                            }}\n                            onRequestClose={onRequestClose}\n                            style={style.dialog}\n                            {...modalProps}\n                        />\n                    )}\n                </FocusTrap>\n                <style type=\"text/css\">{bodyOverrideStyle}</style>\n            </WrapperComponent>\n        );\n    }\n}\n\nexport default Modal;\n"]},"metadata":{},"sourceType":"module"}