{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\n/**\n * \n * @file Helper for the box file API\n * @author Box\n */\nimport queryString from 'query-string';\nimport getProp from 'lodash/get';\nimport { findMissingProperties, fillMissingProperties } from '../utils/fields';\nimport { getTypedFileId } from '../utils/file';\nimport { getBadItemError, getBadPermissionsError } from '../utils/error';\nimport { CACHE_PREFIX_FILE, ERROR_CODE_FETCH_FILE, ERROR_CODE_GET_DOWNLOAD_URL, FIELD_AUTHENTICATED_DOWNLOAD_URL, FIELD_EXTENSION, FIELD_IS_DOWNLOAD_AVAILABLE, REPRESENTATIONS_RESPONSE_ERROR, REPRESENTATIONS_RESPONSE_SUCCESS, REPRESENTATIONS_RESPONSE_VIEWABLE, X_REP_HINTS } from '../constants';\nimport Item from './Item';\nimport { retryNumOfTimes } from '../utils/function';\nimport TokenService from '../utils/TokenService';\nvar File = /*#__PURE__*/\nfunction (_Item) {\n  _inherits(File, _Item);\n  function File() {\n    _classCallCheck(this, File);\n    return _possibleConstructorReturn(this, _getPrototypeOf(File).apply(this, arguments));\n  }\n  _createClass(File, [{\n    key: \"getCacheKey\",\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    value: function getCacheKey(id) {\n      return \"\".concat(CACHE_PREFIX_FILE).concat(id);\n    }\n    /**\n     * API URL for files\n     *\n     * @param {string} [id] - Optional file id\n     * @return {string} base url for files\n     */\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(id) {\n      var suffix = id ? \"/\".concat(id) : '';\n      return \"\".concat(this.getBaseApiUrl(), \"/files\").concat(suffix);\n    }\n    /**\n     * API for getting download URL for files and file versions\n     *\n     * @param {string} fileId - File id\n     * @param {BoxItem|BoxItemVersion} fileOrFileVersion - File or file version to download\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n  }, {\n    key: \"getDownloadUrl\",\n    value: function () {\n      var _getDownloadUrl = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(fileId, fileOrFileVersion, successCallback, errorCallback) {\n        var downloadAvailable, downloadUrl, token, _queryString$parseUrl, query, downloadBaseUrl, downloadUrlParams, downloadUrlQuery;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.errorCode = ERROR_CODE_GET_DOWNLOAD_URL;\n                this.errorCallback = errorCallback;\n                this.successCallback = successCallback;\n                downloadAvailable = fileOrFileVersion[FIELD_IS_DOWNLOAD_AVAILABLE];\n                downloadUrl = fileOrFileVersion[FIELD_AUTHENTICATED_DOWNLOAD_URL];\n                _context.next = 7;\n                return TokenService.getReadToken(getTypedFileId(fileId), this.options.token);\n              case 7:\n                token = _context.sent;\n                if (!(!downloadAvailable || !downloadUrl || !token)) {\n                  _context.next = 11;\n                  break;\n                }\n                this.errorHandler(new Error('Download is missing required fields or token.'));\n                return _context.abrupt(\"return\");\n              case 11:\n                _queryString$parseUrl = queryString.parseUrl(downloadUrl), query = _queryString$parseUrl.query, downloadBaseUrl = _queryString$parseUrl.url;\n                downloadUrlParams = _objectSpread({}, query, {\n                  access_token: token\n                });\n                downloadUrlQuery = queryString.stringify(downloadUrlParams);\n                this.successHandler(\"\".concat(downloadBaseUrl, \"?\").concat(downloadUrlQuery));\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getDownloadUrl(_x, _x2, _x3, _x4) {\n        return _getDownloadUrl.apply(this, arguments);\n      }\n      return getDownloadUrl;\n    }()\n    /**\n     * Determines whether the call to the file representations API has completed\n     *\n     * @param {data: { FileRepresentation }} response\n     * @return {boolean}\n     */\n  }, {\n    key: \"isRepresentationsCallComplete\",\n    value: function isRepresentationsCallComplete(response) {\n      var status = getProp(response, 'data.status.state');\n      return !status || status === REPRESENTATIONS_RESPONSE_ERROR || status === REPRESENTATIONS_RESPONSE_SUCCESS || status === REPRESENTATIONS_RESPONSE_VIEWABLE;\n    }\n    /**\n     * Polls a representation's infoUrl, attempting to generate a representation\n     *\n     * @param {FileRepresentation} representation - representation that should have its info.url polled\n     * @return {Promise<FileRepresentation>} - representation updated with most current status\n     */\n  }, {\n    key: \"generateRepresentation\",\n    value: function () {\n      var _generateRepresentation = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(representation) {\n        var _this = this;\n        var infoUrl;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                infoUrl = getProp(representation, 'info.url');\n                if (infoUrl) {\n                  _context2.next = 3;\n                  break;\n                }\n                return _context2.abrupt(\"return\", representation);\n              case 3:\n                return _context2.abrupt(\"return\", retryNumOfTimes(function (successCallback, errorCallback) {\n                  return _this.xhr.get({\n                    successCallback: successCallback,\n                    errorCallback: errorCallback,\n                    url: infoUrl\n                  }).then(function (response) {\n                    return _this.isRepresentationsCallComplete(response) ? successCallback(response.data) : errorCallback(response.data);\n                  }).catch(function (e) {\n                    errorCallback(e);\n                  });\n                }, 4, 2000, 2));\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function generateRepresentation(_x5) {\n        return _generateRepresentation.apply(this, arguments);\n      }\n      return generateRepresentation;\n    }()\n    /**\n     * API for getting a thumbnail URL for a BoxItem\n     *\n     * @param {BoxItem} item - BoxItem to get the thumbnail URL for\n     * @return {Promise<?string>} - the url for the item's thumbnail, or null\n     */\n  }, {\n    key: \"getThumbnailUrl\",\n    value: function () {\n      var _getThumbnailUrl = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(item) {\n        var entry, extension, template, token, thumbnailUrl, _queryString$parseUrl2, query, thumbnailBaseUrl, thumbnailUrlParams, thumbnailUrlQuery;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                entry = getProp(item, 'representations.entries[0]');\n                extension = getProp(entry, 'representation');\n                template = getProp(entry, 'content.url_template');\n                _context3.next = 5;\n                return TokenService.getReadToken(getTypedFileId(item.id), this.options.token);\n              case 5:\n                token = _context3.sent;\n                if (!(!extension || !template || !token)) {\n                  _context3.next = 8;\n                  break;\n                }\n                return _context3.abrupt(\"return\", null);\n              case 8:\n                thumbnailUrl = template.replace('{+asset_path}', extension === 'jpg' ? '' : '1.png');\n                _queryString$parseUrl2 = queryString.parseUrl(thumbnailUrl), query = _queryString$parseUrl2.query, thumbnailBaseUrl = _queryString$parseUrl2.url;\n                thumbnailUrlParams = _objectSpread({}, query, {\n                  access_token: token\n                });\n                thumbnailUrlQuery = queryString.stringify(thumbnailUrlParams);\n                return _context3.abrupt(\"return\", \"\".concat(thumbnailBaseUrl, \"?\").concat(thumbnailUrlQuery));\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n      function getThumbnailUrl(_x6) {\n        return _getThumbnailUrl.apply(this, arguments);\n      }\n      return getThumbnailUrl;\n    }()\n    /**\n     * API for setting the description of a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} description - New file description\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n  }, {\n    key: \"setFileDescription\",\n    value: function setFileDescription(file, description, successCallback, errorCallback) {\n      var _this2 = this;\n      var id = file.id,\n        permissions = file.permissions;\n      if (!id || !permissions) {\n        errorCallback(getBadItemError());\n        return Promise.reject();\n      }\n      if (!permissions.can_rename) {\n        errorCallback(getBadPermissionsError());\n        return Promise.reject();\n      }\n      return this.xhr.put({\n        id: getTypedFileId(id),\n        url: this.getUrl(id),\n        data: {\n          description: description\n        }\n      }).then(function (_ref) {\n        var data = _ref.data;\n        if (!_this2.isDestroyed()) {\n          var updatedFile = _this2.merge(_this2.getCacheKey(id), 'description', data.description);\n          successCallback(updatedFile);\n        }\n      }).catch(function () {\n        if (!_this2.isDestroyed()) {\n          var originalFile = _this2.merge(_this2.getCacheKey(id), 'description', file.description);\n          errorCallback(originalFile);\n        }\n      });\n    }\n    /**\n     * Gets a box file\n     *\n     * @param {string} id - File id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.fields] - Optionally include specific fields\n     * @param {boolean|void} [options.forceFetch] - Optionally Bypasses the cache\n     * @param {boolean|void} [options.refreshCache] - Optionally Updates the cache\n     * @return {Promise}\n     */\n  }, {\n    key: \"getFile\",\n    value: function () {\n      var _getFile = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(id, successCallback, errorCallback) {\n        var options,\n          cache,\n          key,\n          isCached,\n          file,\n          missingFields,\n          xhrOptions,\n          _ref2,\n          data,\n          dataWithMissingFields,\n          _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : {};\n                if (!this.isDestroyed()) {\n                  _context4.next = 3;\n                  break;\n                }\n                return _context4.abrupt(\"return\");\n              case 3:\n                cache = this.getCache();\n                key = this.getCacheKey(id);\n                isCached = !options.forceFetch && cache.has(key);\n                file = isCached ? cache.get(key) : {\n                  id: id\n                };\n                missingFields = findMissingProperties(file, options.fields);\n                xhrOptions = {\n                  id: getTypedFileId(id),\n                  url: this.getUrl(id),\n                  headers: {\n                    'X-Rep-Hints': X_REP_HINTS\n                  }\n                };\n                this.errorCode = ERROR_CODE_FETCH_FILE;\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback; // If the file was cached and there are no missing fields\n                // then just return the cached file and optionally refresh\n                // the cache with new data if required\n\n                if (!(isCached && missingFields.length === 0)) {\n                  _context4.next = 17;\n                  break;\n                }\n                successCallback(file);\n                missingFields = options.fields || [];\n                if (options.refreshCache) {\n                  _context4.next = 17;\n                  break;\n                }\n                return _context4.abrupt(\"return\");\n              case 17:\n                // If there are missing fields to fetch, add it to the params\n                if (missingFields.length > 0) {\n                  xhrOptions.params = {\n                    fields: missingFields.toString()\n                  };\n                }\n                _context4.prev = 18;\n                _context4.next = 21;\n                return this.xhr.get(xhrOptions);\n              case 21:\n                _ref2 = _context4.sent;\n                data = _ref2.data;\n                if (!this.isDestroyed()) {\n                  _context4.next = 25;\n                  break;\n                }\n                return _context4.abrupt(\"return\");\n              case 25:\n                // Merge fields that were requested but were actually not returned.\n                // This part is mostly useful for metadata.foo.bar fields since the API\n                // returns { metadata: null } instead of { metadata: { foo: { bar: null } } }\n                dataWithMissingFields = fillMissingProperties(data, missingFields); // Cache check is again done since this code is executed async\n\n                if (cache.has(key)) {\n                  cache.merge(key, dataWithMissingFields);\n                } else {\n                  // If there was nothing in the cache\n                  cache.set(key, dataWithMissingFields);\n                }\n                this.successHandler(cache.get(key));\n                _context4.next = 33;\n                break;\n              case 30:\n                _context4.prev = 30;\n                _context4.t0 = _context4[\"catch\"](18);\n                this.errorHandler(_context4.t0);\n              case 33:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[18, 30]]);\n      }));\n      function getFile(_x7, _x8, _x9) {\n        return _getFile.apply(this, arguments);\n      }\n      return getFile;\n    }()\n    /**\n     * Gets the extension of a box file.\n     *\n     * @param {string} id - File id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @return {Promise}\n     */\n  }, {\n    key: \"getFileExtension\",\n    value: function getFileExtension(id, successCallback, errorCallback) {\n      if (this.isDestroyed()) {\n        return;\n      }\n      this.getFile(id, successCallback, errorCallback, {\n        fields: [FIELD_EXTENSION]\n      });\n    }\n  }]);\n  return File;\n}(Item);\nexport default File;","map":{"version":3,"sources":["../../src/api/File.js"],"names":["queryString","getProp","findMissingProperties","fillMissingProperties","getTypedFileId","getBadItemError","getBadPermissionsError","CACHE_PREFIX_FILE","ERROR_CODE_FETCH_FILE","ERROR_CODE_GET_DOWNLOAD_URL","FIELD_AUTHENTICATED_DOWNLOAD_URL","FIELD_EXTENSION","FIELD_IS_DOWNLOAD_AVAILABLE","REPRESENTATIONS_RESPONSE_ERROR","REPRESENTATIONS_RESPONSE_SUCCESS","REPRESENTATIONS_RESPONSE_VIEWABLE","X_REP_HINTS","Item","retryNumOfTimes","TokenService","File","id","suffix","getBaseApiUrl","fileId","fileOrFileVersion","successCallback","errorCallback","errorCode","downloadAvailable","downloadUrl","token","getReadToken","options","errorHandler","Error","query","url","downloadBaseUrl","parseUrl","downloadUrlParams","access_token","downloadUrlQuery","stringify","successHandler","response","status","representation","infoUrl","xhr","get","then","isRepresentationsCallComplete","data","catch","e","item","entry","extension","template","thumbnailUrl","replace","thumbnailBaseUrl","thumbnailUrlParams","thumbnailUrlQuery","file","description","permissions","Promise","reject","can_rename","put","getUrl","isDestroyed","updatedFile","merge","getCacheKey","originalFile","cache","getCache","key","isCached","forceFetch","has","missingFields","fields","xhrOptions","headers","length","refreshCache","params","toString","dataWithMissingFields","set","getFile"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the box file API\n * @author Box\n */\n\nimport queryString from 'query-string';\nimport getProp from 'lodash/get';\nimport { findMissingProperties, fillMissingProperties } from '../utils/fields';\nimport { getTypedFileId } from '../utils/file';\nimport { getBadItemError, getBadPermissionsError } from '../utils/error';\nimport {\n    CACHE_PREFIX_FILE,\n    ERROR_CODE_FETCH_FILE,\n    ERROR_CODE_GET_DOWNLOAD_URL,\n    FIELD_AUTHENTICATED_DOWNLOAD_URL,\n    FIELD_EXTENSION,\n    FIELD_IS_DOWNLOAD_AVAILABLE,\n    REPRESENTATIONS_RESPONSE_ERROR,\n    REPRESENTATIONS_RESPONSE_SUCCESS,\n    REPRESENTATIONS_RESPONSE_VIEWABLE,\n    X_REP_HINTS,\n} from '../constants';\nimport Item from './Item';\nimport { retryNumOfTimes } from '../utils/function';\nimport TokenService from '../utils/TokenService';\nimport type { RequestOptions, ElementsErrorCallback } from '../common/types/api';\nimport type { BoxItem, BoxItemVersion, FileRepresentation } from '../common/types/core';\nimport type APICache from '../utils/Cache';\n\nclass File extends Item {\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id - Folder id\n     * @return {string} key\n     */\n    getCacheKey(id: string): string {\n        return `${CACHE_PREFIX_FILE}${id}`;\n    }\n\n    /**\n     * API URL for files\n     *\n     * @param {string} [id] - Optional file id\n     * @return {string} base url for files\n     */\n    getUrl(id: string): string {\n        const suffix: string = id ? `/${id}` : '';\n        return `${this.getBaseApiUrl()}/files${suffix}`;\n    }\n\n    /**\n     * API for getting download URL for files and file versions\n     *\n     * @param {string} fileId - File id\n     * @param {BoxItem|BoxItemVersion} fileOrFileVersion - File or file version to download\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    async getDownloadUrl(\n        fileId: string,\n        fileOrFileVersion: BoxItem | BoxItemVersion,\n        successCallback: string => void,\n        errorCallback: ElementsErrorCallback,\n    ): Promise<void> {\n        this.errorCode = ERROR_CODE_GET_DOWNLOAD_URL;\n        this.errorCallback = errorCallback;\n        this.successCallback = successCallback;\n\n        const downloadAvailable = fileOrFileVersion[FIELD_IS_DOWNLOAD_AVAILABLE];\n        const downloadUrl = fileOrFileVersion[FIELD_AUTHENTICATED_DOWNLOAD_URL];\n        const token = await TokenService.getReadToken(getTypedFileId(fileId), this.options.token);\n\n        if (!downloadAvailable || !downloadUrl || !token) {\n            this.errorHandler(new Error('Download is missing required fields or token.'));\n            return;\n        }\n\n        const { query, url: downloadBaseUrl } = queryString.parseUrl(downloadUrl);\n        const downloadUrlParams = { ...query, access_token: token };\n        const downloadUrlQuery = queryString.stringify(downloadUrlParams);\n\n        this.successHandler(`${downloadBaseUrl}?${downloadUrlQuery}`);\n    }\n\n    /**\n     * Determines whether the call to the file representations API has completed\n     *\n     * @param {data: { FileRepresentation }} response\n     * @return {boolean}\n     */\n    isRepresentationsCallComplete(response: { data: FileRepresentation }): boolean {\n        const status = getProp(response, 'data.status.state');\n        return (\n            !status ||\n            status === REPRESENTATIONS_RESPONSE_ERROR ||\n            status === REPRESENTATIONS_RESPONSE_SUCCESS ||\n            status === REPRESENTATIONS_RESPONSE_VIEWABLE\n        );\n    }\n\n    /**\n     * Polls a representation's infoUrl, attempting to generate a representation\n     *\n     * @param {FileRepresentation} representation - representation that should have its info.url polled\n     * @return {Promise<FileRepresentation>} - representation updated with most current status\n     */\n    async generateRepresentation(representation: FileRepresentation): Promise<FileRepresentation> {\n        const infoUrl = getProp(representation, 'info.url');\n\n        if (!infoUrl) {\n            return representation;\n        }\n\n        return retryNumOfTimes(\n            (successCallback, errorCallback) =>\n                this.xhr\n                    .get({ successCallback, errorCallback, url: infoUrl })\n                    .then(response =>\n                        this.isRepresentationsCallComplete(response)\n                            ? successCallback(response.data)\n                            : errorCallback(response.data),\n                    )\n                    .catch(e => {\n                        errorCallback(e);\n                    }),\n            4,\n            2000,\n            2,\n        );\n    }\n\n    /**\n     * API for getting a thumbnail URL for a BoxItem\n     *\n     * @param {BoxItem} item - BoxItem to get the thumbnail URL for\n     * @return {Promise<?string>} - the url for the item's thumbnail, or null\n     */\n    async getThumbnailUrl(item: BoxItem): Promise<?string> {\n        const entry = getProp(item, 'representations.entries[0]');\n        const extension = getProp(entry, 'representation');\n        const template = getProp(entry, 'content.url_template');\n        const token = await TokenService.getReadToken(getTypedFileId(item.id), this.options.token);\n\n        if (!extension || !template || !token) {\n            return null;\n        }\n\n        const thumbnailUrl = template.replace('{+asset_path}', extension === 'jpg' ? '' : '1.png');\n        const { query, url: thumbnailBaseUrl } = queryString.parseUrl(thumbnailUrl);\n        const thumbnailUrlParams = { ...query, access_token: token };\n        const thumbnailUrlQuery = queryString.stringify(thumbnailUrlParams);\n        return `${thumbnailBaseUrl}?${thumbnailUrlQuery}`;\n    }\n\n    /**\n     * API for setting the description of a file\n     *\n     * @param {BoxItem} file - File object for which we are changing the description\n     * @param {string} description - New file description\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {Promise}\n     */\n    setFileDescription(\n        file: BoxItem,\n        description: string,\n        successCallback: Function,\n        errorCallback: Function,\n    ): Promise<void> {\n        const { id, permissions } = file;\n\n        if (!id || !permissions) {\n            errorCallback(getBadItemError());\n            return Promise.reject();\n        }\n\n        if (!permissions.can_rename) {\n            errorCallback(getBadPermissionsError());\n            return Promise.reject();\n        }\n\n        return this.xhr\n            .put({\n                id: getTypedFileId(id),\n                url: this.getUrl(id),\n                data: { description },\n            })\n            .then(({ data }: { data: BoxItem }) => {\n                if (!this.isDestroyed()) {\n                    const updatedFile = this.merge(this.getCacheKey(id), 'description', data.description);\n                    successCallback(updatedFile);\n                }\n            })\n            .catch(() => {\n                if (!this.isDestroyed()) {\n                    const originalFile = this.merge(this.getCacheKey(id), 'description', file.description);\n                    errorCallback(originalFile);\n                }\n            });\n    }\n\n    /**\n     * Gets a box file\n     *\n     * @param {string} id - File id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.fields] - Optionally include specific fields\n     * @param {boolean|void} [options.forceFetch] - Optionally Bypasses the cache\n     * @param {boolean|void} [options.refreshCache] - Optionally Updates the cache\n     * @return {Promise}\n     */\n    async getFile(\n        id: string,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        options: RequestOptions = {},\n    ): Promise<void> {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const key: string = this.getCacheKey(id);\n        const isCached: boolean = !options.forceFetch && cache.has(key);\n        const file: BoxItem = isCached ? cache.get(key) : { id };\n        let missingFields: Array<string> = findMissingProperties(file, options.fields);\n        const xhrOptions: Object = {\n            id: getTypedFileId(id),\n            url: this.getUrl(id),\n            headers: { 'X-Rep-Hints': X_REP_HINTS },\n        };\n        this.errorCode = ERROR_CODE_FETCH_FILE;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // If the file was cached and there are no missing fields\n        // then just return the cached file and optionally refresh\n        // the cache with new data if required\n        if (isCached && missingFields.length === 0) {\n            successCallback(file);\n            missingFields = options.fields || [];\n            if (!options.refreshCache) {\n                return;\n            }\n        }\n\n        // If there are missing fields to fetch, add it to the params\n        if (missingFields.length > 0) {\n            xhrOptions.params = {\n                fields: missingFields.toString(),\n            };\n        }\n\n        try {\n            const { data } = await this.xhr.get(xhrOptions);\n            if (this.isDestroyed()) {\n                return;\n            }\n\n            // Merge fields that were requested but were actually not returned.\n            // This part is mostly useful for metadata.foo.bar fields since the API\n            // returns { metadata: null } instead of { metadata: { foo: { bar: null } } }\n            const dataWithMissingFields = fillMissingProperties(data, missingFields);\n\n            // Cache check is again done since this code is executed async\n            if (cache.has(key)) {\n                cache.merge(key, dataWithMissingFields);\n            } else {\n                // If there was nothing in the cache\n                cache.set(key, dataWithMissingFields);\n            }\n\n            this.successHandler(cache.get(key));\n        } catch (e) {\n            this.errorHandler(e);\n        }\n    }\n\n    /**\n     * Gets the extension of a box file.\n     *\n     * @param {string} id - File id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @return {Promise}\n     */\n    getFileExtension(id: string, successCallback: Function, errorCallback: ElementsErrorCallback): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.getFile(id, successCallback, errorCallback, {\n            fields: [FIELD_EXTENSION],\n        });\n    }\n}\n\nexport default File;\n"]},"metadata":{},"sourceType":"module"}