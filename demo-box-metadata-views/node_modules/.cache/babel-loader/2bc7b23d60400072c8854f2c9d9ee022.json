{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport noop from 'lodash/noop';\nimport throttle from 'lodash/throttle';\nimport './ScrollWrapper.scss';\nvar ScrollWrapper = /*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ScrollWrapper, _React$Component);\n  function ScrollWrapper(props) {\n    var _this;\n    _classCallCheck(this, ScrollWrapper);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScrollWrapper).call(this, props));\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      shouldShowTopScrollShadow: false,\n      shouldShowBottomScrollShadow: false\n    });\n    _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function () {\n      var newState = _this.getScrollShadowState();\n      _this.setState(newState);\n      if (_this.scrollRef) {\n        _this.scrollRef.addEventListener('transitionend', _this.throttledOnContentScroll); // Apparently, flow only allows for one truthy check per command, so I have to either:\n        // 1) duplicate this check per call, or\n        // 2) nest if checks (_slightly more performant_)\n\n        if (_this.scrollRef) {\n          _this.observer.observe(_this.scrollRef, {\n            attributes: true,\n            childlist: true,\n            subtree: true\n          });\n        }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onContentScroll\", function () {\n      var newState = _this.getScrollShadowState();\n      _this.setState(newState);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getScrollShadowState\", function () {\n      var _ref = _this.scrollRef || {},\n        scrollTop = _ref.scrollTop,\n        scrollHeight = _ref.scrollHeight,\n        clientHeight = _ref.clientHeight;\n      var newState = {};\n      if (scrollTop > 0 && scrollTop < scrollHeight - clientHeight) {\n        newState.shouldShowTopScrollShadow = true;\n        newState.shouldShowBottomScrollShadow = true;\n      }\n      if (scrollTop === 0) {\n        newState.shouldShowTopScrollShadow = false;\n      }\n      if (scrollTop < scrollHeight - clientHeight) {\n        newState.shouldShowBottomScrollShadow = true;\n      }\n      if (scrollTop === scrollHeight - clientHeight) {\n        newState.shouldShowBottomScrollShadow = false;\n      }\n      return newState;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"scrollRef\", null);\n    _defineProperty(_assertThisInitialized(_this), \"throttledOnContentScroll\", throttle(_this.onContentScroll, 100));\n    _this.observer = new MutationObserver(_this.throttledOnContentScroll);\n    return _this;\n  }\n  _createClass(ScrollWrapper, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.observer.disconnect();\n      if (this.scrollRef) {\n        this.scrollRef.removeEventListener('transitionend', this.throttledOnContentScroll);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var _this$props = this.props,\n        children = _this$props.children,\n        _this$props$className = _this$props.className,\n        className = _this$props$className === void 0 ? '' : _this$props$className,\n        scrollRefFn = _this$props.scrollRefFn,\n        shadowSize = _this$props.shadowSize,\n        rest = _objectWithoutProperties(_this$props, [\"children\", \"className\", \"scrollRefFn\", \"shadowSize\"]);\n      var _this$state = this.state,\n        shouldShowTopScrollShadow = _this$state.shouldShowTopScrollShadow,\n        shouldShowBottomScrollShadow = _this$state.shouldShowBottomScrollShadow;\n      var classes = classNames(\"scroll-container\", className, {\n        'is-showing-top-shadow': shouldShowTopScrollShadow,\n        'is-showing-bottom-shadow': shouldShowBottomScrollShadow\n      });\n      return React.createElement(\"div\", _extends({\n        className: classes\n      }, rest), React.createElement(\"div\", {\n        className: classNames('scroll-wrap-container', \"style--\".concat(shadowSize)),\n        onScroll: this.throttledOnContentScroll,\n        ref: function ref(el) {\n          _this2.scrollRef = el;\n          scrollRefFn(el);\n        }\n      }, children));\n    }\n  }]);\n  return ScrollWrapper;\n}(React.Component);\n_defineProperty(ScrollWrapper, \"defaultProps\", {\n  scrollRefFn: noop,\n  shadowSize: 'cover'\n});\nexport default ScrollWrapper;","map":{"version":3,"sources":["../../../src/components/scroll-wrapper/ScrollWrapper.js"],"names":["React","classNames","noop","throttle","ScrollWrapper","Component","scrollRefFn","shadowSize","shouldShowTopScrollShadow","shouldShowBottomScrollShadow","props","observer","MutationObserver","throttledOnContentScroll","newState","getScrollShadowState","setState","scrollRef","addEventListener","observe","attributes","childlist","subtree","disconnect","removeEventListener","scrollTop","scrollHeight","clientHeight","onContentScroll","children","className","rest","state","classes","el"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport classNames from 'classnames';\nimport noop from 'lodash/noop';\nimport throttle from 'lodash/throttle';\n\nimport './ScrollWrapper.scss';\n\ntype Props = {\n    /** Contents for this element */\n    children: React.Node,\n    /** Optional class name(s) to pass thru to the component */\n    className?: string,\n    /** Optional function to get the scrollRef in parent components */\n    scrollRefFn: (?HTMLElement) => void,\n    /** Optional prop to set the shadow size, like background-size ('cover' or 'contain') */\n    shadowSize: 'cover' | 'contain',\n};\n\ntype State = {\n    shouldShowBottomScrollShadow: boolean,\n    shouldShowTopScrollShadow: boolean,\n};\n\nclass ScrollWrapper extends React.Component<Props, State> {\n    static defaultProps = {\n        scrollRefFn: noop,\n        shadowSize: 'cover',\n    };\n\n    state = {\n        shouldShowTopScrollShadow: false,\n        shouldShowBottomScrollShadow: false,\n    };\n\n    constructor(props: Props) {\n        super(props);\n\n        this.observer = new MutationObserver(this.throttledOnContentScroll);\n    }\n\n    componentDidMount = () => {\n        const newState = this.getScrollShadowState();\n        this.setState(newState);\n\n        if (this.scrollRef) {\n            this.scrollRef.addEventListener('transitionend', this.throttledOnContentScroll);\n\n            // Apparently, flow only allows for one truthy check per command, so I have to either:\n            // 1) duplicate this check per call, or\n            // 2) nest if checks (_slightly more performant_)\n            if (this.scrollRef) {\n                this.observer.observe(this.scrollRef, {\n                    attributes: true,\n                    childlist: true,\n                    subtree: true,\n                });\n            }\n        }\n    };\n\n    componentWillUnmount() {\n        this.observer.disconnect();\n\n        if (this.scrollRef) {\n            this.scrollRef.removeEventListener('transitionend', this.throttledOnContentScroll);\n        }\n    }\n\n    onContentScroll = (): void => {\n        const newState = this.getScrollShadowState();\n        this.setState(newState);\n    };\n\n    getScrollShadowState = () => {\n        const { scrollTop, scrollHeight, clientHeight } = this.scrollRef || {};\n        const newState = {};\n\n        if (scrollTop > 0 && scrollTop < scrollHeight - clientHeight) {\n            newState.shouldShowTopScrollShadow = true;\n            newState.shouldShowBottomScrollShadow = true;\n        }\n\n        if (scrollTop === 0) {\n            newState.shouldShowTopScrollShadow = false;\n        }\n\n        if (scrollTop < scrollHeight - clientHeight) {\n            newState.shouldShowBottomScrollShadow = true;\n        }\n\n        if (scrollTop === scrollHeight - clientHeight) {\n            newState.shouldShowBottomScrollShadow = false;\n        }\n\n        return newState;\n    };\n\n    observer: MutationObserver;\n\n    scrollRef: ?HTMLDivElement = null;\n\n    // Throttle to 10 fps\n    throttledOnContentScroll = throttle(this.onContentScroll, 100);\n\n    render() {\n        const { children, className = '', scrollRefFn, shadowSize, ...rest } = this.props;\n        const { shouldShowTopScrollShadow, shouldShowBottomScrollShadow } = this.state;\n\n        const classes = classNames(`scroll-container`, className, {\n            'is-showing-top-shadow': shouldShowTopScrollShadow,\n            'is-showing-bottom-shadow': shouldShowBottomScrollShadow,\n        });\n\n        return (\n            <div className={classes} {...rest}>\n                <div\n                    className={classNames('scroll-wrap-container', `style--${shadowSize}`)}\n                    onScroll={this.throttledOnContentScroll}\n                    ref={el => {\n                        this.scrollRef = el;\n                        scrollRefFn(el);\n                    }}\n                >\n                    {children}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default ScrollWrapper;\n"]},"metadata":{},"sourceType":"module"}