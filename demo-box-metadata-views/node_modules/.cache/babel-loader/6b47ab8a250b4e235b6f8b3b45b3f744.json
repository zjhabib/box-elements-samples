{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Multiput upload part\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport getProp from 'lodash/get';\nimport { updateQueryParameters } from '../../utils/url';\nimport { getBoundedExpBackoffRetryDelay } from '../../utils/uploads';\nimport { retryNumOfTimes } from '../../utils/function';\nimport BaseMultiput from './BaseMultiput';\nimport { HTTP_PUT } from '../../constants';\nvar PART_STATE_NOT_STARTED = 0;\nvar PART_STATE_DIGEST_READY = 1;\nvar PART_STATE_UPLOADING = 2;\nvar PART_STATE_UPLOADED = 3;\nvar MultiputPart = /*#__PURE__*/\nfunction (_BaseMultiput) {\n  _inherits(MultiputPart, _BaseMultiput);\n\n  // For resumable uploads.  When an error happens, all parts for an upload get paused.  This\n  // is not a separate state because a paused upload transitions to the DIGEST_READY state immediately\n  // so MultiputUpload can upload the part again.\n\n  /**\n   * [constructor]\n   *\n   * @param {Options} options\n   * @param {number} index - 0-based index of this part in array of all parts\n   * @param {number} offset - Starting byte offset of this part's range\n   * @param {number} partSize - Size of this part in bytes\n   * @param {number} sessionId\n   * @param {Object} sessionEndpoints\n   * @param {MultiputConfig} config\n   * @param {Function} getNumPartsUploading\n   * @param {Function} [onSuccess]\n   * @param {Function} [onProgress]\n   * @param {Function} [onError]\n   * @return {void}\n   */\n  function MultiputPart(options, index, offset, partSize, fileSize, sessionId, sessionEndpoints, config, getNumPartsUploading, onSuccess, onProgress, onError) {\n    var _this;\n    _classCallCheck(this, MultiputPart);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MultiputPart).call(this, options, sessionEndpoints, config));\n    _defineProperty(_assertThisInitialized(_this), \"toJSON\", function () {\n      return JSON.stringify({\n        index: _this.index,\n        offset: _this.offset,\n        partSize: _this.partSize,\n        state: _this.state,\n        uploadedBytes: _this.uploadedBytes,\n        numUploadRetriesPerformed: _this.numUploadRetriesPerformed,\n        numDigestRetriesPerformed: _this.numDigestRetriesPerformed,\n        sha256: _this.sha256,\n        timing: _this.timing\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getPart\", function () {\n      return _this.data.part || {};\n    });\n    _defineProperty(_assertThisInitialized(_this), \"upload\", function () {\n      if (_this.isDestroyedOrPaused()) {\n        return;\n      }\n      if (!_this.sha256) {\n        throw new Error('Part SHA-256 unavailable');\n      }\n      if (!_this.blob) {\n        throw new Error('Part blob unavailable');\n      }\n      var clientEventInfo = {\n        documentHidden: document.hidden,\n        digest_retries: _this.numDigestRetriesPerformed,\n        timing: _this.timing,\n        parts_uploading: _this.getNumPartsUploading()\n      };\n      var headers = {\n        'Content-Type': 'application/octet-stream',\n        Digest: \"sha-256=\".concat(_this.sha256),\n        'Content-Range': \"bytes \".concat(_this.offset, \"-\").concat(_this.rangeEnd, \"/\").concat(_this.fileSize),\n        'X-Box-Client-Event-Info': JSON.stringify(clientEventInfo)\n      };\n      _this.state = PART_STATE_UPLOADING;\n      _this.startTimestamp = Date.now();\n      _this.xhr.uploadFile({\n        url: _this.sessionEndpoints.uploadPart,\n        data: _this.blob,\n        headers: headers,\n        method: HTTP_PUT,\n        successHandler: _this.uploadSuccessHandler,\n        errorHandler: _this.uploadErrorHandler,\n        progressHandler: _this.uploadProgressHandler,\n        withIdleTimeout: true,\n        idleTimeoutDuration: _this.config.requestTimeoutMs\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"uploadSuccessHandler\", function (_ref) {\n      var data = _ref.data;\n      if (_this.isDestroyedOrPaused()) {\n        return;\n      }\n      _this.state = PART_STATE_UPLOADED;\n      _this.consoleLog(\"Upload completed: \".concat(_this.toJSON(), \".\"));\n      _this.data = data;\n      _this.blob = null;\n      _this.timing.uploadTime = Date.now() - _this.startTimestamp;\n      _this.onSuccess(_assertThisInitialized(_this));\n      _this.uploadedBytes = _this.partSize;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"uploadProgressHandler\", function (event) {\n      if (_this.isDestroyedOrPaused()) {\n        return;\n      }\n      var newUploadedBytes = parseInt(event.loaded, 10);\n      var prevUploadedBytes = _this.uploadedBytes;\n      _this.uploadedBytes = newUploadedBytes;\n      _this.onProgress(prevUploadedBytes, newUploadedBytes);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"uploadErrorHandler\", /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(error) {\n        var xhr_ready_state, xhr_status_text, eventInfo, eventInfoString, retryDelayMs;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!_this.isDestroyedOrPaused()) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 2:\n                xhr_ready_state = getProp(_this.xhr, 'xhr.readyState', null);\n                xhr_status_text = getProp(_this.xhr, 'xhr.statusText', '');\n                _this.consoleLog(\"Upload failure \".concat(error.message, \" for part \").concat(_this.toJSON(), \". XHR state: \").concat(xhr_ready_state, \".\"));\n                eventInfo = {\n                  message: error.message,\n                  part: {\n                    uploadedBytes: _this.uploadedBytes,\n                    id: _this.id,\n                    index: _this.index,\n                    offset: _this.offset\n                  },\n                  xhr_ready_state: xhr_ready_state,\n                  xhr_status_text: xhr_status_text\n                };\n                eventInfoString = JSON.stringify(eventInfo);\n                if (_this.sessionEndpoints.logEvent) {\n                  retryNumOfTimes(function (resolve, reject) {\n                    _this.logEvent('part_failure', eventInfoString).then(resolve).catch(reject);\n                  }, _this.config.retries, _this.config.initialRetryDelayMs).catch(function (e) {\n                    return _this.consoleLog(\"Failure in logEvent: \".concat(e.message));\n                  });\n                } else {\n                  _this.consoleLog('logEvent endpoint not found');\n                }\n                if (!(_this.numUploadRetriesPerformed >= _this.config.retries)) {\n                  _context.next = 11;\n                  break;\n                }\n                _this.onError(error, eventInfoString);\n                return _context.abrupt(\"return\");\n              case 11:\n                retryDelayMs = getBoundedExpBackoffRetryDelay(_this.config.initialRetryDelayMs, _this.config.maxRetryDelayMs, _this.numUploadRetriesPerformed);\n                _this.numUploadRetriesPerformed += 1;\n                _this.consoleLog(\"Retrying uploading part \".concat(_this.toJSON(), \" in \").concat(retryDelayMs, \" ms\"));\n                _this.retryTimeout = setTimeout(_this.retryUpload, retryDelayMs);\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    _defineProperty(_assertThisInitialized(_this), \"retryUpload\", /*#__PURE__*/\n    _asyncToGenerator( /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      var parts, response;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!_this.isDestroyedOrPaused()) {\n                _context2.next = 2;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 2:\n              _context2.prev = 2;\n              _context2.next = 5;\n              return _this.listParts(_this.index, 1);\n            case 5:\n              parts = _context2.sent;\n              if (!(parts && parts.length === 1 && parts[0].offset === _this.offset && parts[0].part_id)) {\n                _context2.next = 11;\n                break;\n              }\n              _this.consoleLog(\"Part \".concat(_this.toJSON(), \" is available on server. Not re-uploading.\"));\n              _this.id = parts[0].part_id;\n              _this.uploadSuccessHandler({\n                data: {\n                  part: parts[0]\n                }\n              });\n              return _context2.abrupt(\"return\");\n            case 11:\n              _this.consoleLog(\"Part \".concat(_this.toJSON(), \" is not available on server. Re-uploading.\"));\n              throw new Error('Part not found on the server');\n            case 15:\n              _context2.prev = 15;\n              _context2.t0 = _context2[\"catch\"](2);\n              response = _context2.t0.response;\n              if (response && response.status) {\n                _this.consoleLog(\"Error \".concat(response.status, \" while listing part \").concat(_this.toJSON(), \". Re-uploading.\"));\n              }\n              _this.numUploadRetriesPerformed += 1;\n              _this.upload();\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[2, 15]]);\n    })));\n    _defineProperty(_assertThisInitialized(_this), \"listParts\", /*#__PURE__*/\n    function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(partIndex, limit) {\n        var params, endpoint, response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                params = {\n                  offset: partIndex,\n                  limit: limit\n                };\n                endpoint = updateQueryParameters(_this.sessionEndpoints.listParts, params);\n                _context3.next = 4;\n                return _this.xhr.get({\n                  url: endpoint\n                });\n              case 4:\n                response = _context3.sent;\n                return _context3.abrupt(\"return\", response.data.entries);\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      return function (_x2, _x3) {\n        return _ref4.apply(this, arguments);\n      };\n    }());\n    _this.index = index;\n    _this.numDigestRetriesPerformed = 0;\n    _this.numUploadRetriesPerformed = 0;\n    _this.offset = offset;\n    _this.partSize = partSize;\n    _this.fileSize = fileSize;\n    _this.state = PART_STATE_NOT_STARTED;\n    _this.timing = {};\n    _this.uploadedBytes = 0;\n    _this.data = {};\n    _this.config = config;\n    _this.rangeEnd = offset + partSize - 1;\n    if (_this.rangeEnd > fileSize - 1) {\n      _this.rangeEnd = fileSize - 1;\n    }\n    _this.isPaused = false;\n    _this.onSuccess = onSuccess || noop;\n    _this.onError = onError || noop;\n    _this.onProgress = onProgress || noop;\n    _this.getNumPartsUploading = getNumPartsUploading;\n    return _this;\n  }\n  _createClass(MultiputPart, [{\n    key: \"cancel\",\n    /**\n     * Cancels upload for this Part.\n     *\n     * @return {void}\n     */\n    value: function cancel() {\n      clearTimeout(this.retryTimeout);\n      this.blob = null;\n      this.data = {};\n      this.destroy();\n    }\n    /**\n     * Pauses upload for this Part.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      clearTimeout(this.retryTimeout); // Cancel timeout so that we don't keep retrying while paused\n\n      this.isPaused = true;\n      this.state = PART_STATE_DIGEST_READY;\n      this.xhr.abort(); //  This calls the error handler.\n    }\n    /**\n     * Unpauses upload for this Part.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"unpause\",\n    value: function unpause() {\n      this.isPaused = false;\n      this.state = PART_STATE_UPLOADING;\n      this.retryUpload();\n    }\n    /**\n     * Resets upload for this Part.\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.numUploadRetriesPerformed = 0;\n      this.timing = {};\n      this.uploadedBytes = 0;\n    }\n    /**\n     * Checks if this Part is destroyed or paused\n     *\n     * @return {boolean}\n     */\n  }, {\n    key: \"isDestroyedOrPaused\",\n    value: function isDestroyedOrPaused() {\n      return this.isDestroyed() || this.isPaused;\n    }\n    /**\n     * List specified parts\n     *\n     * @param {number} partIndex - Index of starting part. Optional.\n     * @param {number} limit - Number of parts to be listed. Optional.\n     * @return {Promise<Array<Object>>} Array of parts\n     */\n  }]);\n\n  return MultiputPart;\n}(BaseMultiput);\nexport default MultiputPart;\nexport { PART_STATE_NOT_STARTED, PART_STATE_DIGEST_READY, PART_STATE_UPLOADING, PART_STATE_UPLOADED };","map":{"version":3,"sources":["../../../src/api/uploads/MultiputPart.js"],"names":["noop","getProp","updateQueryParameters","getBoundedExpBackoffRetryDelay","retryNumOfTimes","BaseMultiput","HTTP_PUT","PART_STATE_NOT_STARTED","PART_STATE_DIGEST_READY","PART_STATE_UPLOADING","PART_STATE_UPLOADED","MultiputPart","options","index","offset","partSize","fileSize","sessionId","sessionEndpoints","config","getNumPartsUploading","onSuccess","onProgress","onError","numDigestRetriesPerformed","numUploadRetriesPerformed","state","timing","uploadedBytes","data","rangeEnd","isPaused","stringify","sha256","part","isDestroyedOrPaused","Error","blob","clientEventInfo","documentHidden","document","hidden","digest_retries","parts_uploading","headers","Digest","JSON","startTimestamp","Date","now","xhr","uploadFile","url","uploadPart","method","successHandler","uploadSuccessHandler","errorHandler","uploadErrorHandler","progressHandler","uploadProgressHandler","withIdleTimeout","idleTimeoutDuration","requestTimeoutMs","consoleLog","toJSON","uploadTime","event","newUploadedBytes","parseInt","loaded","prevUploadedBytes","error","xhr_ready_state","xhr_status_text","message","eventInfo","id","eventInfoString","logEvent","resolve","reject","then","catch","retries","initialRetryDelayMs","e","retryDelayMs","maxRetryDelayMs","retryTimeout","setTimeout","retryUpload","parts","listParts","length","part_id","response","status","upload","clearTimeout","destroy","abort","isDestroyed","partIndex","limit","params","endpoint","get","entries"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Multiput upload part\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport getProp from 'lodash/get';\nimport { updateQueryParameters } from '../../utils/url';\nimport { getBoundedExpBackoffRetryDelay } from '../../utils/uploads';\nimport { retryNumOfTimes } from '../../utils/function';\n\nimport BaseMultiput from './BaseMultiput';\n\nimport { HTTP_PUT } from '../../constants';\n\nimport type { MultiputConfig, MultiputData } from '../../common/types/upload';\nimport type { APIOptions } from '../../common/types/api';\n\nconst PART_STATE_NOT_STARTED: 0 = 0;\nconst PART_STATE_DIGEST_READY: 1 = 1;\nconst PART_STATE_UPLOADING: 2 = 2;\nconst PART_STATE_UPLOADED: 3 = 3;\n\nclass MultiputPart extends BaseMultiput {\n    index: number;\n\n    numDigestRetriesPerformed: number;\n\n    numUploadRetriesPerformed: number;\n\n    offset: number;\n\n    sha256: string;\n\n    partSize: number;\n\n    state:\n        | typeof PART_STATE_NOT_STARTED\n        | typeof PART_STATE_DIGEST_READY\n        | typeof PART_STATE_UPLOADING\n        | typeof PART_STATE_UPLOADED;\n\n    timing: Object;\n\n    uploadedBytes: number;\n\n    onProgress: Function;\n\n    onSuccess: Function;\n\n    onError: Function;\n\n    data: MultiputData;\n\n    config: MultiputConfig;\n\n    id: string;\n\n    retryTimeout: TimeoutID;\n\n    blob: ?Blob;\n\n    rangeEnd: number;\n\n    startTimestamp: number;\n\n    getNumPartsUploading: Function;\n\n    fileSize: number;\n\n    isPaused: boolean; // For resumable uploads.  When an error happens, all parts for an upload get paused.  This\n    // is not a separate state because a paused upload transitions to the DIGEST_READY state immediately\n    // so MultiputUpload can upload the part again.\n\n    /**\n     * [constructor]\n     *\n     * @param {Options} options\n     * @param {number} index - 0-based index of this part in array of all parts\n     * @param {number} offset - Starting byte offset of this part's range\n     * @param {number} partSize - Size of this part in bytes\n     * @param {number} sessionId\n     * @param {Object} sessionEndpoints\n     * @param {MultiputConfig} config\n     * @param {Function} getNumPartsUploading\n     * @param {Function} [onSuccess]\n     * @param {Function} [onProgress]\n     * @param {Function} [onError]\n     * @return {void}\n     */\n    constructor(\n        options: APIOptions,\n        index: number,\n        offset: number,\n        partSize: number,\n        fileSize: number,\n        sessionId: string,\n        sessionEndpoints: Object,\n        config: MultiputConfig,\n        getNumPartsUploading: Function,\n        onSuccess?: Function,\n        onProgress?: Function,\n        onError?: Function,\n    ): void {\n        super(options, sessionEndpoints, config);\n\n        this.index = index;\n        this.numDigestRetriesPerformed = 0;\n        this.numUploadRetriesPerformed = 0;\n        this.offset = offset;\n        this.partSize = partSize;\n        this.fileSize = fileSize;\n        this.state = PART_STATE_NOT_STARTED;\n        this.timing = {};\n        this.uploadedBytes = 0;\n        this.data = {};\n        this.config = config;\n        this.rangeEnd = offset + partSize - 1;\n        if (this.rangeEnd > fileSize - 1) {\n            this.rangeEnd = fileSize - 1;\n        }\n        this.isPaused = false;\n\n        this.onSuccess = onSuccess || noop;\n        this.onError = onError || noop;\n        this.onProgress = onProgress || noop;\n        this.getNumPartsUploading = getNumPartsUploading;\n    }\n\n    toJSON = () =>\n        JSON.stringify({\n            index: this.index,\n            offset: this.offset,\n            partSize: this.partSize,\n            state: this.state,\n            uploadedBytes: this.uploadedBytes,\n            numUploadRetriesPerformed: this.numUploadRetriesPerformed,\n            numDigestRetriesPerformed: this.numDigestRetriesPerformed,\n            sha256: this.sha256,\n            timing: this.timing,\n        });\n\n    /**\n     * Returns file part information from the server after part upload is successful\n     *\n     * @return {Object}\n     */\n    getPart = (): Object => this.data.part || {};\n\n    /**\n     * Uploads this Part via the API. Will retry on network failures.\n     *\n     * @return {void}\n     */\n    upload = (): void => {\n        if (this.isDestroyedOrPaused()) {\n            return;\n        }\n\n        if (!this.sha256) {\n            throw new Error('Part SHA-256 unavailable');\n        }\n\n        if (!this.blob) {\n            throw new Error('Part blob unavailable');\n        }\n\n        const clientEventInfo = {\n            documentHidden: document.hidden,\n            digest_retries: this.numDigestRetriesPerformed,\n            timing: this.timing,\n            parts_uploading: this.getNumPartsUploading(),\n        };\n\n        const headers = {\n            'Content-Type': 'application/octet-stream',\n            Digest: `sha-256=${this.sha256}`,\n            'Content-Range': `bytes ${this.offset}-${this.rangeEnd}/${this.fileSize}`,\n            'X-Box-Client-Event-Info': JSON.stringify(clientEventInfo),\n        };\n\n        this.state = PART_STATE_UPLOADING;\n\n        this.startTimestamp = Date.now();\n        this.xhr.uploadFile({\n            url: this.sessionEndpoints.uploadPart,\n            data: this.blob,\n            headers,\n            method: HTTP_PUT,\n            successHandler: this.uploadSuccessHandler,\n            errorHandler: this.uploadErrorHandler,\n            progressHandler: this.uploadProgressHandler,\n            withIdleTimeout: true,\n            idleTimeoutDuration: this.config.requestTimeoutMs,\n        });\n    };\n\n    /**\n     * Handler for upload part success\n     *\n     * @param {Object} data\n     * @return {void}\n     */\n    uploadSuccessHandler = ({ data }: { data: Object }) => {\n        if (this.isDestroyedOrPaused()) {\n            return;\n        }\n\n        this.state = PART_STATE_UPLOADED;\n        this.consoleLog(`Upload completed: ${this.toJSON()}.`);\n        this.data = data;\n        this.blob = null;\n        this.timing.uploadTime = Date.now() - this.startTimestamp;\n\n        this.onSuccess(this);\n\n        this.uploadedBytes = this.partSize;\n    };\n\n    /**\n     * Handler for upload part progress event\n     *\n     * @param {ProgressEvent} data\n     * @return {void}\n     */\n    uploadProgressHandler = (event: ProgressEvent) => {\n        if (this.isDestroyedOrPaused()) {\n            return;\n        }\n\n        const newUploadedBytes = parseInt(event.loaded, 10);\n        const prevUploadedBytes = this.uploadedBytes;\n        this.uploadedBytes = newUploadedBytes;\n\n        this.onProgress(prevUploadedBytes, newUploadedBytes);\n    };\n\n    /**\n     * Handler for upload part error\n     *\n     * @param {Error} error\n     * @return {void}\n     */\n    uploadErrorHandler = async (error: Error) => {\n        if (this.isDestroyedOrPaused()) {\n            // Ignore abort() error by checking this.isPaused\n            return;\n        }\n\n        const xhr_ready_state = getProp(this.xhr, 'xhr.readyState', null);\n        const xhr_status_text = getProp(this.xhr, 'xhr.statusText', '');\n\n        this.consoleLog(`Upload failure ${error.message} for part ${this.toJSON()}. XHR state: ${xhr_ready_state}.`);\n\n        const eventInfo = {\n            message: error.message,\n            part: {\n                uploadedBytes: this.uploadedBytes,\n                id: this.id,\n                index: this.index,\n                offset: this.offset,\n            },\n            xhr_ready_state,\n            xhr_status_text,\n        };\n\n        const eventInfoString = JSON.stringify(eventInfo);\n\n        if (this.sessionEndpoints.logEvent) {\n            retryNumOfTimes(\n                (resolve: Function, reject: Function): void => {\n                    this.logEvent('part_failure', eventInfoString)\n                        .then(resolve)\n                        .catch(reject);\n                },\n                this.config.retries,\n                this.config.initialRetryDelayMs,\n            ).catch(e => this.consoleLog(`Failure in logEvent: ${e.message}`));\n        } else {\n            this.consoleLog('logEvent endpoint not found');\n        }\n\n        if (this.numUploadRetriesPerformed >= this.config.retries) {\n            this.onError(error, eventInfoString);\n            return;\n        }\n\n        const retryDelayMs = getBoundedExpBackoffRetryDelay(\n            this.config.initialRetryDelayMs,\n            this.config.maxRetryDelayMs,\n            this.numUploadRetriesPerformed,\n        );\n\n        this.numUploadRetriesPerformed += 1;\n        this.consoleLog(`Retrying uploading part ${this.toJSON()} in ${retryDelayMs} ms`);\n        this.retryTimeout = setTimeout(this.retryUpload, retryDelayMs);\n    };\n\n    /**\n     * Retry uploading part\n     *\n     * @return {Promise}\n     */\n    retryUpload = async (): Promise<any> => {\n        if (this.isDestroyedOrPaused()) {\n            return;\n        }\n\n        try {\n            const parts = await this.listParts(this.index, 1);\n\n            if (parts && parts.length === 1 && parts[0].offset === this.offset && parts[0].part_id) {\n                this.consoleLog(`Part ${this.toJSON()} is available on server. Not re-uploading.`);\n                this.id = parts[0].part_id;\n                this.uploadSuccessHandler({\n                    data: {\n                        part: parts[0],\n                    },\n                });\n                return;\n            }\n\n            this.consoleLog(`Part ${this.toJSON()} is not available on server. Re-uploading.`);\n            throw new Error('Part not found on the server');\n        } catch (error) {\n            const { response } = error;\n            if (response && response.status) {\n                this.consoleLog(`Error ${response.status} while listing part ${this.toJSON()}. Re-uploading.`);\n            }\n\n            this.numUploadRetriesPerformed += 1;\n            this.upload();\n        }\n    };\n\n    /**\n     * Cancels upload for this Part.\n     *\n     * @return {void}\n     */\n    cancel(): void {\n        clearTimeout(this.retryTimeout);\n        this.blob = null;\n        this.data = {};\n        this.destroy();\n    }\n\n    /**\n     * Pauses upload for this Part.\n     *\n     * @return {void}\n     */\n    pause(): void {\n        clearTimeout(this.retryTimeout); // Cancel timeout so that we don't keep retrying while paused\n        this.isPaused = true;\n        this.state = PART_STATE_DIGEST_READY;\n        this.xhr.abort(); //  This calls the error handler.\n    }\n\n    /**\n     * Unpauses upload for this Part.\n     *\n     * @return {void}\n     */\n    unpause(): void {\n        this.isPaused = false;\n        this.state = PART_STATE_UPLOADING;\n        this.retryUpload();\n    }\n\n    /**\n     * Resets upload for this Part.\n     *\n     * @return {void}\n     */\n    reset(): void {\n        this.numUploadRetriesPerformed = 0;\n        this.timing = {};\n        this.uploadedBytes = 0;\n    }\n\n    /**\n     * Checks if this Part is destroyed or paused\n     *\n     * @return {boolean}\n     */\n    isDestroyedOrPaused(): boolean {\n        return this.isDestroyed() || this.isPaused;\n    }\n\n    /**\n     * List specified parts\n     *\n     * @param {number} partIndex - Index of starting part. Optional.\n     * @param {number} limit - Number of parts to be listed. Optional.\n     * @return {Promise<Array<Object>>} Array of parts\n     */\n    listParts = async (partIndex: number, limit: number): Promise<Array<Object>> => {\n        const params = {\n            offset: partIndex,\n            limit,\n        };\n\n        const endpoint = updateQueryParameters(this.sessionEndpoints.listParts, params);\n        const response = await this.xhr.get({\n            url: endpoint,\n        });\n\n        return response.data.entries;\n    };\n}\n\nexport default MultiputPart;\nexport { PART_STATE_NOT_STARTED, PART_STATE_DIGEST_READY, PART_STATE_UPLOADING, PART_STATE_UPLOADED };\n"]},"metadata":{},"sourceType":"module"}