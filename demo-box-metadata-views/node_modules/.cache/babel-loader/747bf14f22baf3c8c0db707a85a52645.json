{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get(target, property, receiver || target);\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Helper for activity feed API's\n * @author Box\n */\nimport uniqueId from 'lodash/uniqueId';\nimport noop from 'lodash/noop';\nimport { getBadItemError, getBadUserError, isUserCorrectableError } from '../utils/error';\nimport commonMessages from '../elements/common/messages';\nimport messages from './messages';\nimport { sortFeedItems } from '../utils/sorter';\nimport Base from './Base';\nimport AnnotationsAPI from './Annotations';\nimport CommentsAPI from './Comments';\nimport VersionsAPI from './Versions';\nimport TasksNewAPI from './tasks/TasksNew';\nimport GroupsAPI from './Groups';\nimport TaskCollaboratorsAPI from './tasks/TaskCollaborators';\nimport TaskLinksAPI from './tasks/TaskLinks';\nimport AppActivityAPI from './AppActivity';\nimport { ERROR_CODE_CREATE_TASK, ERROR_CODE_UPDATE_TASK, ERROR_CODE_GROUP_EXCEEDS_LIMIT, HTTP_STATUS_CODE_CONFLICT, IS_ERROR_DISPLAYED, TASK_NEW_APPROVED, TASK_NEW_COMPLETED, TASK_NEW_REJECTED, TASK_NEW_NOT_STARTED, TYPED_ID_FEED_PREFIX, TASK_MAX_GROUP_ASSIGNEES } from '../constants';\nvar TASK_NEW_INITIAL_STATUS = TASK_NEW_NOT_STARTED;\nvar TASK = 'task';\nvar Feed = /*#__PURE__*/\nfunction (_Base) {\n  _inherits(Feed, _Base);\n\n  /**\n   * @property {AnnotationsAPI}\n   */\n\n  /**\n   * @property {VersionsAPI}\n   */\n\n  /**\n   * @property {CommentsAPI}\n   */\n\n  /**\n   * @property {AppActivityAPI}\n   */\n\n  /**\n   * @property {TasksNewAPI}\n   */\n\n  /**\n   * @property {TaskCollaboratorsAPI}\n   */\n\n  /**\n   * @property {TaskLinksAPI}\n   */\n\n  /**\n   * @property {BoxItem}\n   */\n\n  /**\n   * @property {ElementsXhrError}\n   */\n  function Feed(options) {\n    var _this;\n    _classCallCheck(this, Feed);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Feed).call(this, options));\n    _defineProperty(_assertThisInitialized(_this), \"deleteAnnotation\", function (file, annotationId, permissions, successCallBack, errorCallback) {\n      _this.annotationsAPI = new AnnotationsAPI(_this.options);\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      _this.file = file;\n      _this.errorCallback = errorCallback;\n      _this.updateFeedItem({\n        isPending: true\n      }, annotationId);\n      _this.annotationsAPI.deleteAnnotation(_this.file.id, annotationId, permissions, _this.deleteFeedItem.bind(_assertThisInitialized(_this), annotationId, successCallBack), function (error, code) {\n        // Reusing comment error handler since annotations are treated as comments to user\n        _this.deleteCommentErrorCallback(error, code, annotationId);\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"updateTaskCollaborator\", function (file, taskId, taskCollaboratorId, taskCollaboratorStatus, _successCallback, errorCallback) {\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      _this.file = file;\n      _this.errorCallback = errorCallback;\n      _this.updateFeedItem({\n        isPending: true\n      }, taskId);\n      var collaboratorsApi = new TaskCollaboratorsAPI(_this.options);\n      _this.taskCollaboratorsAPI.push(collaboratorsApi);\n      var taskCollaboratorPayload = {\n        id: taskCollaboratorId,\n        status: taskCollaboratorStatus\n      };\n      var handleError = function handleError(e, code) {\n        var errorMessage;\n        switch (taskCollaboratorStatus) {\n          case TASK_NEW_APPROVED:\n            errorMessage = messages.taskApproveErrorMessage;\n            break;\n          case TASK_NEW_COMPLETED:\n            errorMessage = messages.taskCompleteErrorMessage;\n            break;\n          case TASK_NEW_REJECTED:\n            errorMessage = messages.taskRejectErrorMessage;\n            break;\n          default:\n            errorMessage = messages.taskCompleteErrorMessage;\n        }\n        _this.updateFeedItem(_this.createFeedError(errorMessage, messages.taskActionErrorTitle), taskId);\n        _this.feedErrorCallback(true, e, code);\n      };\n      collaboratorsApi.updateTaskCollaborator({\n        file: file,\n        taskCollaborator: taskCollaboratorPayload,\n        successCallback: function successCallback(taskCollab) {\n          _this.updateTaskCollaboratorSuccessCallback(taskId, file, taskCollab, _successCallback, handleError);\n        },\n        errorCallback: handleError\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"updateTaskCollaboratorSuccessCallback\", function (taskId, file, updatedCollaborator, _successCallback2, errorCallback) {\n      _this.tasksNewAPI = new TasksNewAPI(_this.options);\n      _this.tasksNewAPI.getTask({\n        id: taskId,\n        file: file,\n        successCallback: function successCallback(task) {\n          _this.updateFeedItem(_objectSpread({}, task, {\n            isPending: false\n          }), taskId);\n          _successCallback2(updatedCollaborator);\n        },\n        errorCallback: errorCallback\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"updateTaskNew\", /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(file, task) {\n        var successCallback,\n          errorCallback,\n          groupInfoPromises,\n          groupCounts,\n          hasAnyGroupCountExceeded,\n          warning,\n          _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                successCallback = _args.length > 2 && _args[2] !== undefined ? _args[2] : noop;\n                errorCallback = _args.length > 3 && _args[3] !== undefined ? _args[3] : noop;\n                if (file.id) {\n                  _context.next = 4;\n                  break;\n                }\n                throw getBadItemError();\n              case 4:\n                _this.file = file;\n                _this.errorCallback = errorCallback;\n                _this.tasksNewAPI = new TasksNewAPI(_this.options);\n                _this.updateFeedItem({\n                  isPending: true\n                }, task.id);\n                _context.prev = 8;\n                // create request for the size of each group by ID\n                // TODO: use async/await for both creating and editing tasks\n                groupInfoPromises = task.addedAssignees.filter(function (assignee) {\n                  return assignee.item && assignee.item.type === 'group';\n                }).map(function (assignee) {\n                  return assignee.id;\n                }).map(function (groupId) {\n                  return new GroupsAPI(_this.options).getGroupCount({\n                    file: file,\n                    group: {\n                      id: groupId\n                    }\n                  });\n                });\n                _context.next = 12;\n                return Promise.all(groupInfoPromises);\n              case 12:\n                groupCounts = _context.sent;\n                hasAnyGroupCountExceeded = groupCounts.some(function (groupInfo) {\n                  return groupInfo.total_count > TASK_MAX_GROUP_ASSIGNEES;\n                });\n                warning = {\n                  code: ERROR_CODE_GROUP_EXCEEDS_LIMIT,\n                  type: 'warning'\n                };\n                if (!hasAnyGroupCountExceeded) {\n                  _context.next = 18;\n                  break;\n                }\n                _this.feedErrorCallback(false, warning, ERROR_CODE_GROUP_EXCEEDS_LIMIT);\n                return _context.abrupt(\"return\");\n              case 18:\n                _context.next = 20;\n                return new Promise(function (resolve, reject) {\n                  _this.tasksNewAPI.updateTaskWithDeps({\n                    file: file,\n                    task: task,\n                    successCallback: resolve,\n                    errorCallback: reject\n                  });\n                });\n              case 20:\n                _context.next = 22;\n                return new Promise(function (resolve, reject) {\n                  _this.tasksNewAPI.getTask({\n                    file: file,\n                    id: task.id,\n                    successCallback: function successCallback(taskData) {\n                      _this.updateFeedItem(_objectSpread({}, taskData, {\n                        isPending: false\n                      }), task.id);\n                      resolve();\n                    },\n                    errorCallback: function errorCallback(e) {\n                      _this.updateFeedItem({\n                        isPending: false\n                      }, task.id);\n                      _this.feedErrorCallback(false, e, ERROR_CODE_UPDATE_TASK);\n                      reject();\n                    }\n                  });\n                });\n              case 22:\n                // everything succeeded, so call the passed in success callback\n                if (!_this.isDestroyed()) {\n                  successCallback();\n                }\n                _context.next = 29;\n                break;\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](8);\n                _this.updateFeedItem({\n                  isPending: false\n                }, task.id);\n                _this.feedErrorCallback(false, _context.t0, ERROR_CODE_UPDATE_TASK);\n              case 29:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[8, 25]]);\n      }));\n      return function (_x6, _x7) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    _defineProperty(_assertThisInitialized(_this), \"deleteComment\", function (file, commentId, permissions, successCallback, errorCallback) {\n      _this.commentsAPI = new CommentsAPI(_this.options);\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      _this.file = file;\n      _this.errorCallback = errorCallback;\n      _this.updateFeedItem({\n        isPending: true\n      }, commentId);\n      _this.commentsAPI.deleteComment({\n        file: file,\n        commentId: commentId,\n        permissions: permissions,\n        successCallback: _this.deleteFeedItem.bind(_assertThisInitialized(_this), commentId, successCallback),\n        errorCallback: function errorCallback(e, code) {\n          _this.deleteCommentErrorCallback(e, code, commentId);\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"deleteCommentErrorCallback\", function (e, code, commentId) {\n      _this.updateFeedItem(_this.createFeedError(messages.commentDeleteErrorMessage), commentId);\n      _this.feedErrorCallback(true, e, code);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"createTaskNew\", function (file, currentUser, message, assignees, taskType, dueAt, completionRule, _successCallback3, errorCallback) {\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      _this.file = file;\n      _this.errorCallback = errorCallback;\n      var uuid = uniqueId('task_');\n      var dueAtString;\n      if (dueAt) {\n        var dueAtDate = new Date(dueAt);\n        dueAtString = dueAtDate.toISOString();\n      } // TODO: make pending task generator a function\n\n      var pendingTask = {\n        created_by: {\n          type: 'task_collaborator',\n          target: currentUser,\n          id: uniqueId(),\n          role: 'CREATOR',\n          status: TASK_NEW_INITIAL_STATUS\n        },\n        completion_rule: completionRule,\n        created_at: new Date().toISOString(),\n        due_at: dueAtString,\n        id: uuid,\n        description: message,\n        type: TASK,\n        assigned_to: {\n          entries: assignees.map(function (assignee) {\n            return {\n              id: uniqueId(),\n              target: _objectSpread({}, assignee, {\n                avatar_url: '',\n                type: 'user'\n              }),\n              status: TASK_NEW_INITIAL_STATUS,\n              permissions: {\n                can_delete: false,\n                can_update: false\n              },\n              role: 'ASSIGNEE',\n              type: 'task_collaborator'\n            };\n          }),\n          limit: 10,\n          next_marker: null\n        },\n        permissions: {\n          can_update: false,\n          can_delete: false,\n          can_create_task_collaborator: false,\n          can_create_task_link: false\n        },\n        task_links: {\n          entries: [{\n            id: uniqueId(),\n            type: 'task_link',\n            target: _objectSpread({\n              type: 'file'\n            }, file),\n            permissions: {\n              can_delete: false,\n              can_update: false\n            }\n          }],\n          limit: 1,\n          next_marker: null\n        },\n        task_type: taskType,\n        status: TASK_NEW_NOT_STARTED\n      };\n      var taskPayload = {\n        description: message,\n        due_at: dueAtString,\n        task_type: taskType,\n        completion_rule: completionRule\n      }; // create request for the size of each group by ID\n\n      var groupInfoPromises = assignees.filter(function (assignee) {\n        return (assignee.item && assignee.item.type) === 'group';\n      }).map(function (assignee) {\n        return assignee.id;\n      }).map(function (groupId) {\n        return new GroupsAPI(_this.options).getGroupCount({\n          file: file,\n          group: {\n            id: groupId\n          }\n        });\n      }); // Fetch each group size in parallel --> return an array of group sizes\n\n      Promise.all(groupInfoPromises).then(function (groupCounts) {\n        var hasAnyGroupCountExceeded = groupCounts.some(function (groupInfo) {\n          return groupInfo.total_count > TASK_MAX_GROUP_ASSIGNEES;\n        });\n        var warning = {\n          code: ERROR_CODE_GROUP_EXCEEDS_LIMIT,\n          type: 'warning'\n        };\n        if (hasAnyGroupCountExceeded) {\n          _this.feedErrorCallback(false, warning, ERROR_CODE_GROUP_EXCEEDS_LIMIT);\n          return;\n        }\n        _this.tasksNewAPI = new TasksNewAPI(_this.options);\n        _this.tasksNewAPI.createTaskWithDeps({\n          file: file,\n          task: taskPayload,\n          assignees: assignees,\n          successCallback: function successCallback(taskWithDepsData) {\n            _this.addPendingItem(_this.file.id, currentUser, pendingTask);\n            _this.updateFeedItem(_objectSpread({}, taskWithDepsData, {\n              task_links: {\n                entries: taskWithDepsData.task_links,\n                next_marker: null,\n                limit: 1\n              },\n              assigned_to: {\n                entries: taskWithDepsData.assigned_to,\n                next_marker: null,\n                limit: taskWithDepsData.assigned_to.length\n              },\n              isPending: false\n            }), uuid);\n            _successCallback3(taskWithDepsData);\n          },\n          errorCallback: function errorCallback(e, code) {\n            _this.feedErrorCallback(false, e, code);\n          }\n        });\n      }).catch(function (error) {\n        _this.feedErrorCallback(false, error, ERROR_CODE_CREATE_TASK);\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"deleteTaskNew\", function (file, task) {\n      var successCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n      var errorCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      _this.file = file;\n      _this.errorCallback = errorCallback;\n      _this.tasksNewAPI = new TasksNewAPI(_this.options);\n      _this.updateFeedItem({\n        isPending: true\n      }, task.id);\n      _this.tasksNewAPI.deleteTask({\n        file: file,\n        task: task,\n        successCallback: _this.deleteFeedItem.bind(_assertThisInitialized(_this), task.id, successCallback),\n        errorCallback: function errorCallback(e, code) {\n          _this.updateFeedItem(_this.createFeedError(messages.taskDeleteErrorMessage), task.id);\n          _this.feedErrorCallback(true, e, code);\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"deleteFeedItem\", function (id) {\n      var successCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n      var cachedItems = _this.getCachedItems(_this.file.id);\n      if (cachedItems) {\n        var _feedItems2 = cachedItems.items.filter(function (feedItem) {\n          return feedItem.id !== id;\n        });\n        _this.setCachedItems(_this.file.id, _feedItems2);\n        if (!_this.isDestroyed()) {\n          successCallback(id);\n        }\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"feedErrorCallback\", function () {\n      var hasError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var e = arguments.length > 1 ? arguments[1] : undefined;\n      var code = arguments.length > 2 ? arguments[2] : undefined;\n      if (hasError) {\n        _this.errors.push(_objectSpread({}, e, {\n          code: code\n        }));\n      }\n      if (!_this.isDestroyed() && _this.errorCallback) {\n        _this.errorCallback(e, code, _defineProperty({\n          error: e\n        }, IS_ERROR_DISPLAYED, hasError));\n      }\n      console.error(e); // eslint-disable-line no-console\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"addPendingItem\", function (id, currentUser, itemBase) {\n      if (!currentUser) {\n        throw getBadUserError();\n      }\n      var date = new Date().toISOString();\n      var pendingFeedItem = _objectSpread({\n        created_at: date,\n        created_by: currentUser,\n        modified_at: date,\n        isPending: true\n      }, itemBase);\n      var cachedItems = _this.getCachedItems(_this.file.id);\n      var feedItems = cachedItems ? cachedItems.items : [];\n      var feedItemsWithPendingItem = [].concat(_toConsumableArray(feedItems), [pendingFeedItem]);\n      _this.setCachedItems(id, feedItemsWithPendingItem);\n      return pendingFeedItem;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"createCommentSuccessCallback\", function (commentData, id, successCallback) {\n      var _commentData$message = commentData.message,\n        message = _commentData$message === void 0 ? '' : _commentData$message,\n        _commentData$tagged_m = commentData.tagged_message,\n        tagged_message = _commentData$tagged_m === void 0 ? '' : _commentData$tagged_m; // Comment component uses tagged_message only\n\n      commentData.tagged_message = tagged_message || message;\n      _this.updateFeedItem(_objectSpread({}, commentData, {\n        isPending: false\n      }), id);\n      if (!_this.isDestroyed()) {\n        successCallback(commentData);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"createCommentErrorCallback\", function (e, code, id) {\n      var errorMessage = e.status === HTTP_STATUS_CODE_CONFLICT ? messages.commentCreateConflictMessage : messages.commentCreateErrorMessage;\n      _this.updateFeedItem(_this.createFeedError(errorMessage), id);\n      _this.feedErrorCallback(false, e, code);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"updateFeedItem\", function (updates, id) {\n      if (!_this.file.id) {\n        throw getBadItemError();\n      }\n      var cachedItems = _this.getCachedItems(_this.file.id);\n      if (cachedItems) {\n        var updatedFeedItems = cachedItems.items.map(function (item) {\n          if (item.id === id) {\n            return _objectSpread({}, item, {}, updates);\n          }\n          return item;\n        });\n        _this.setCachedItems(_this.file.id, updatedFeedItems);\n        return updatedFeedItems;\n      }\n      return null;\n    });\n    _defineProperty(_assertThisInitialized(_this), \"createComment\", function (file, currentUser, text, hasMention, _successCallback4, errorCallback) {\n      var uuid = uniqueId('comment_');\n      var commentData = {\n        id: uuid,\n        tagged_message: text,\n        type: 'comment'\n      };\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      _this.file = file;\n      _this.errorCallback = errorCallback;\n      _this.addPendingItem(_this.file.id, currentUser, commentData);\n      var message = {};\n      if (hasMention) {\n        message.taggedMessage = text;\n      } else {\n        message.message = text;\n      }\n      _this.commentsAPI = new CommentsAPI(_this.options);\n      _this.commentsAPI.createComment(_objectSpread({\n        file: file\n      }, message, {\n        successCallback: function successCallback(comment) {\n          _this.createCommentSuccessCallback(comment, uuid, _successCallback4);\n        },\n        errorCallback: function errorCallback(e, code) {\n          _this.createCommentErrorCallback(e, code, uuid);\n        }\n      }));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"updateComment\", function (file, commentId, text, hasMention, permissions, _successCallback5, errorCallback) {\n      var commentData = {\n        tagged_message: text\n      };\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      _this.file = file;\n      _this.errorCallback = errorCallback;\n      _this.updateFeedItem(_objectSpread({}, commentData, {\n        isPending: true\n      }), commentId);\n      var message = {};\n      if (hasMention) {\n        message.tagged_message = text;\n      } else {\n        message.message = text;\n      }\n      _this.commentsAPI = new CommentsAPI(_this.options);\n      _this.commentsAPI.updateComment(_objectSpread({\n        file: file,\n        commentId: commentId,\n        permissions: permissions\n      }, message, {\n        successCallback: function successCallback(comment) {\n          // use the request payload instead of response in the\n          // feed item update because response may not contain\n          // the tagged version of the message\n          _this.updateFeedItem(_objectSpread({}, message, {\n            isPending: false\n          }), commentId);\n          if (!_this.isDestroyed()) {\n            _successCallback5(comment);\n          }\n        },\n        errorCallback: function errorCallback(e, code) {\n          _this.feedErrorCallback(true, e, code);\n        }\n      }));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"deleteAppActivity\", function (file, appActivityId, successCallback, errorCallback) {\n      var id = file.id;\n      if (!id) {\n        throw getBadItemError();\n      }\n      _this.appActivityAPI = new AppActivityAPI(_this.options);\n      _this.file = file;\n      _this.errorCallback = errorCallback;\n      _this.updateFeedItem({\n        isPending: true\n      }, appActivityId);\n      _this.appActivityAPI.deleteAppActivity({\n        id: id,\n        appActivityId: appActivityId,\n        successCallback: _this.deleteFeedItem.bind(_assertThisInitialized(_this), appActivityId, successCallback),\n        errorCallback: function errorCallback(e, code) {\n          _this.deleteAppActivityErrorCallback(e, code, appActivityId);\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"deleteAppActivityErrorCallback\", function (e, code, id) {\n      _this.updateFeedItem(_this.createFeedError(messages.appActivityDeleteErrorMessage), id);\n      _this.feedErrorCallback(true, e, code);\n    });\n    _this.taskCollaboratorsAPI = [];\n    _this.taskLinksAPI = [];\n    _this.errors = [];\n    return _this;\n  }\n  /**\n   * Creates pending card on create_start action, then updates card on next call\n   * @param {BoxItem} file - The file to which the annotation is assigned\n   * @param {Object} currentUser - the user who performed the action\n   * @param {Annotation} annotation - the current annotation to be created\n   * @param {string} id - unique id for the incoming annotation\n   * @param {boolean} isPending - indicates the current creation process of the annotation\n   */\n\n  _createClass(Feed, [{\n    key: \"addAnnotation\",\n    value: function addAnnotation(file, currentUser, annotation, id, isPending) {\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      this.file = file; // Add the pending interstitial card\n\n      if (isPending) {\n        var newAnnotation = _objectSpread({}, annotation, {\n          created_by: currentUser,\n          id: id,\n          type: 'annotation'\n        });\n        this.addPendingItem(this.file.id, currentUser, newAnnotation);\n        return;\n      } // Create action has completed, so update the existing pending item\n\n      this.updateFeedItem(_objectSpread({}, annotation, {\n        isPending: false\n      }), id);\n    }\n  }, {\n    key: \"getCacheKey\",\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id folder id\n     * @return {string} key\n     */\n    value: function getCacheKey(id) {\n      return \"\".concat(TYPED_ID_FEED_PREFIX).concat(id);\n    }\n    /**\n     * Gets the items from the cache\n     *\n     * @param {string} id the cache id\n     */\n  }, {\n    key: \"getCachedItems\",\n    value: function getCachedItems(id) {\n      var cache = this.getCache();\n      var cacheKey = this.getCacheKey(id);\n      return cache.get(cacheKey);\n    }\n    /**\n     * Sets the items in the cache\n     *\n     * @param {string} id - the cache id\n     * @param {Array} items - the feed items to cache\n     */\n  }, {\n    key: \"setCachedItems\",\n    value: function setCachedItems(id, items) {\n      var cache = this.getCache();\n      var cacheKey = this.getCacheKey(id);\n      cache.set(cacheKey, {\n        errors: this.errors,\n        items: items\n      });\n    }\n    /**\n     * Gets the feed items\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {boolean} shouldRefreshCache - Optionally updates the cache\n     * @param {Function} successCallback - the success callback  which is called after data fetching is complete\n     * @param {Function} errorCallback - the error callback which is called after data fetching is complete if there was an error\n     * @param {Function} onError - the function to be called immediately after an error occurs\n     * @param {Object} [options]- feature flips, etc\n     * @param {Object} [options.shouldShowAppActivity] - feature flip the new app activity api\n     */\n  }, {\n    key: \"feedItems\",\n    value: function (_feedItems) {\n      function feedItems(_x, _x2, _x3, _x4, _x5) {\n        return _feedItems.apply(this, arguments);\n      }\n      feedItems.toString = function () {\n        return _feedItems.toString();\n      };\n      return feedItems;\n    }(function (file, shouldRefreshCache, successCallback, errorCallback, onError) {\n      var _this2 = this;\n      var _ref2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {},\n        _ref2$shouldShowAnnot = _ref2.shouldShowAnnotations,\n        shouldShowAnnotations = _ref2$shouldShowAnnot === void 0 ? false : _ref2$shouldShowAnnot,\n        _ref2$shouldShowAppAc = _ref2.shouldShowAppActivity,\n        shouldShowAppActivity = _ref2$shouldShowAppAc === void 0 ? false : _ref2$shouldShowAppAc;\n      var id = file.id,\n        _file$permissions = file.permissions,\n        permissions = _file$permissions === void 0 ? {} : _file$permissions;\n      var cachedItems = this.getCachedItems(id);\n      if (cachedItems) {\n        var _errors = cachedItems.errors,\n          items = cachedItems.items;\n        if (_errors.length) {\n          errorCallback(items, _errors);\n        } else {\n          successCallback(items);\n        }\n        if (!shouldRefreshCache) {\n          return;\n        }\n      }\n      this.file = file;\n      this.errors = [];\n      this.errorCallback = onError;\n      var annotationsPromise = shouldShowAnnotations ? this.fetchAnnotations(permissions) : Promise.resolve();\n      var versionsPromise = this.fetchVersions();\n      var currentVersionPromise = this.fetchCurrentVersion();\n      var commentsPromise = this.fetchComments(permissions);\n      var tasksPromise = this.fetchTasksNew();\n      var appActivityPromise = shouldShowAppActivity ? this.fetchAppActivity(permissions) : Promise.resolve();\n      Promise.all([versionsPromise, currentVersionPromise, commentsPromise, tasksPromise, appActivityPromise, annotationsPromise]).then(function (_ref3) {\n        var _ref4 = _toArray(_ref3),\n          versions = _ref4[0],\n          currentVersion = _ref4[1],\n          feedItems = _ref4.slice(2);\n        var versionsWithCurrent = _this2.versionsAPI.addCurrentVersion(currentVersion, versions, _this2.file);\n        var sortedFeedItems = sortFeedItems.apply(void 0, [versionsWithCurrent].concat(_toConsumableArray(feedItems)));\n        if (!_this2.isDestroyed()) {\n          _this2.setCachedItems(id, sortedFeedItems);\n          if (_this2.errors.length) {\n            errorCallback(sortedFeedItems, _this2.errors);\n          } else {\n            successCallback(sortedFeedItems);\n          }\n        }\n      });\n    })\n  }, {\n    key: \"fetchAnnotations\",\n    value: function fetchAnnotations(permissions) {\n      var _this3 = this;\n      this.annotationsAPI = new AnnotationsAPI(this.options);\n      return new Promise(function (resolve) {\n        _this3.annotationsAPI.getAnnotations(_this3.file.id, undefined, permissions, resolve, _this3.fetchFeedItemErrorCallback.bind(_this3, resolve));\n      });\n    }\n    /**\n     * Fetches the comments for a file\n     *\n     * @param {Object} permissions - the file permissions\n     * @return {Promise} - the file comments\n     */\n  }, {\n    key: \"fetchComments\",\n    value: function fetchComments(permissions) {\n      var _this4 = this;\n      this.commentsAPI = new CommentsAPI(this.options);\n      return new Promise(function (resolve) {\n        _this4.commentsAPI.getComments(_this4.file.id, permissions, resolve, _this4.fetchFeedItemErrorCallback.bind(_this4, resolve));\n      });\n    }\n    /**\n     * Fetches the versions for a file\n     *\n     * @return {Promise} - the file versions\n     */\n  }, {\n    key: \"fetchVersions\",\n    value: function fetchVersions() {\n      var _this5 = this;\n      this.versionsAPI = new VersionsAPI(this.options);\n      return new Promise(function (resolve) {\n        _this5.versionsAPI.getVersions(_this5.file.id, resolve, _this5.fetchFeedItemErrorCallback.bind(_this5, resolve));\n      });\n    }\n    /**\n     * Fetches the current version for a file\n     *\n     * @return {Promise} - the file versions\n     */\n  }, {\n    key: \"fetchCurrentVersion\",\n    value: function fetchCurrentVersion() {\n      var _this6 = this;\n      this.versionsAPI = new VersionsAPI(this.options);\n      return new Promise(function (resolve) {\n        var _this6$file$file_vers = _this6.file.file_version,\n          file_version = _this6$file$file_vers === void 0 ? {} : _this6$file$file_vers;\n        _this6.versionsAPI.getVersion(_this6.file.id, file_version.id, resolve, _this6.fetchFeedItemErrorCallback.bind(_this6, resolve));\n      });\n    }\n    /**\n     * Fetches the tasks for a file\n     *\n     * @return {Promise} - the feed items\n     */\n  }, {\n    key: \"fetchTasksNew\",\n    value: function fetchTasksNew() {\n      var _this7 = this;\n      this.tasksNewAPI = new TasksNewAPI(this.options);\n      return new Promise(function (resolve) {\n        _this7.tasksNewAPI.getTasksForFile({\n          file: {\n            id: _this7.file.id\n          },\n          successCallback: resolve,\n          errorCallback: function errorCallback(err, code) {\n            return _this7.fetchFeedItemErrorCallback(resolve, err, code);\n          }\n        });\n      });\n    }\n    /**\n     * Error callback for fetching feed items.\n     * Should only call the error callback if the response is a 401, 429 or >= 500\n     *\n     * @param {Function} resolve - the function which will be called on error\n     * @param {Object} e - the axios error\n     * @param {string} code - the error code\n     * @return {void}\n     */\n  }, {\n    key: \"fetchFeedItemErrorCallback\",\n    value: function fetchFeedItemErrorCallback(resolve, e, code) {\n      var status = e.status;\n      var shouldDisplayError = isUserCorrectableError(status);\n      this.feedErrorCallback(shouldDisplayError, e, code);\n      resolve();\n    }\n    /**\n     * Updates a task assignment\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {string} taskId - ID of task to be updated\n     * @param {string} taskCollaboratorId - Task assignment ID\n     * @param {TaskCollabStatus} taskCollaboratorStatus - New task assignment status\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error\n     * @return {void}\n     */\n  }, {\n    key: \"createTaskCollaboratorsforGroup\",\n    /**\n     * Creates a task group via the API.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Task|TaskUpdatePayload} task - The newly created or existing task from the API\n     * @param {SelectorItem} assignee - The user assigned to this task\n     * @param {Function} errorCallback - Task create error callback\n     * @return {Promise<TaskAssignment>}\n     */\n    value: function createTaskCollaboratorsforGroup(file, task, assignee) {\n      var _this8 = this;\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      this.file = file;\n      return new Promise(function (resolve, reject) {\n        var taskCollaboratorsAPI = new TaskCollaboratorsAPI(_this8.options);\n        _this8.taskCollaboratorsAPI.push(taskCollaboratorsAPI);\n        taskCollaboratorsAPI.createTaskCollaboratorsforGroup({\n          file: file,\n          task: task,\n          group: assignee,\n          successCallback: resolve,\n          errorCallback: function errorCallback(e) {\n            reject(e);\n          }\n        });\n      });\n    }\n    /**\n     * Creates a task collaborator via the API.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Task|TaskUpdatePayload} task - The newly created or existing task from the API\n     * @param {SelectorItem} assignee - The user assigned to this task\n     * @param {Function} errorCallback - Task create error callback\n     * @return {Promise<TaskAssignment>}\n     */\n  }, {\n    key: \"createTaskCollaborator\",\n    value: function createTaskCollaborator(file, task, assignee) {\n      var _this9 = this;\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      this.file = file;\n      return new Promise(function (resolve, reject) {\n        var taskCollaboratorsAPI = new TaskCollaboratorsAPI(_this9.options);\n        _this9.taskCollaboratorsAPI.push(taskCollaboratorsAPI);\n        taskCollaboratorsAPI.createTaskCollaborator({\n          file: file,\n          task: task,\n          user: assignee,\n          successCallback: resolve,\n          errorCallback: function errorCallback(e) {\n            reject(e);\n          }\n        });\n      });\n    }\n    /**\n     * Deletes a task collaborator via the API.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Task|TaskUpdatePayload} task - The newly deleted or existing task from the API\n     * @param {TaskCollabAssignee} assignee - The user assigned to this task\n     * @param {Function} errorCallback - Task delete error callback\n     * @return {Promise<TaskAssignment>}\n     */\n  }, {\n    key: \"deleteTaskCollaborator\",\n    value: function deleteTaskCollaborator(file, task, assignee) {\n      var _this10 = this;\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      this.file.id = file.id;\n      return new Promise(function (resolve, reject) {\n        var taskCollaboratorsAPI = new TaskCollaboratorsAPI(_this10.options);\n        _this10.taskCollaboratorsAPI.push(taskCollaboratorsAPI);\n        taskCollaboratorsAPI.deleteTaskCollaborator({\n          file: file,\n          task: task,\n          taskCollaborator: {\n            id: assignee.id\n          },\n          successCallback: resolve,\n          errorCallback: function errorCallback(e) {\n            reject(e);\n          }\n        });\n      });\n    }\n    /**\n     * Creates a task link via the API.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Task} task - The newly created task from the API\n     * @param {Function} errorCallback - Task create error callback\n     * @return {Promise<TaskAssignment}\n     */\n  }, {\n    key: \"createTaskLink\",\n    value: function createTaskLink(file, task) {\n      var _this11 = this;\n      if (!file.id) {\n        throw getBadItemError();\n      }\n      this.file = file;\n      return new Promise(function (resolve, reject) {\n        var taskLinksAPI = new TaskLinksAPI(_this11.options);\n        _this11.taskLinksAPI.push(taskLinksAPI);\n        taskLinksAPI.createTaskLink({\n          file: file,\n          task: task,\n          successCallback: resolve,\n          errorCallback: reject\n        });\n      });\n    }\n    /**\n     * Deletes a task in the new API\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {string} taskId - The task's id\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error\n     * @return {void}\n     */\n  }, {\n    key: \"createFeedError\",\n    /**\n     * Constructs an error object that renders to an inline feed error\n     *\n     * @param {string} message - The error message body.\n     * @param {string} title - The error message title.\n     * @return {Object} An error message object\n     */\n    value: function createFeedError(message) {\n      var title = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : commonMessages.errorOccured;\n      return {\n        error: {\n          message: message,\n          title: title\n        }\n      };\n    }\n    /**\n     * Replace a feed item with new feed item data.\n     *\n     * @param {Object} updates - The new data to be applied to the feed item.\n     * @param {string} id - ID of the feed item to replace.\n     * @return {void}\n     */\n  }, {\n    key: \"destroyTaskCollaborators\",\n    value: function destroyTaskCollaborators() {\n      if (Array.isArray(this.taskCollaboratorsAPI)) {\n        this.taskCollaboratorsAPI.forEach(function (api) {\n          return api.destroy();\n        });\n        this.taskCollaboratorsAPI = [];\n      }\n    }\n  }, {\n    key: \"destroyTaskLinks\",\n    value: function destroyTaskLinks() {\n      if (Array.isArray(this.taskLinksAPI)) {\n        this.taskLinksAPI.forEach(function (api) {\n          return api.destroy();\n        });\n        this.taskLinksAPI = [];\n      }\n    }\n    /**\n     * Fetches app activities for a file\n     * @param {BoxItemPermission} permissions - Permissions to attach to the app activity items\n     *\n     * @return {Promise} - the feed items\n     */\n  }, {\n    key: \"fetchAppActivity\",\n    value: function fetchAppActivity(permissions) {\n      var _this12 = this;\n      this.appActivityAPI = new AppActivityAPI(this.options);\n      return new Promise(function (resolve) {\n        _this12.appActivityAPI.getAppActivity(_this12.file.id, permissions, resolve, _this12.fetchFeedItemErrorCallback.bind(_this12, resolve));\n      });\n    }\n    /**\n     * Deletes an app activity item.\n     *\n     * @param {BoxItem} file - The file to which the app activity belongs to\n     * @param {string} appActivityId - The app activity item id to delete\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error\n     * @return {void}\n     */\n  }, {\n    key: \"destroy\",\n    /**\n     * Destroys all the task feed API's\n     *\n     * @return {void}\n     */\n    value: function destroy() {\n      _get(_getPrototypeOf(Feed.prototype), \"destroy\", this).call(this);\n      if (this.annotationsAPI) {\n        this.annotationsAPI.destroy();\n        delete this.annotationsAPI;\n      }\n      if (this.commentsAPI) {\n        this.commentsAPI.destroy();\n        delete this.commentsAPI;\n      }\n      if (this.versionsAPI) {\n        this.versionsAPI.destroy();\n        delete this.versionsAPI;\n      }\n      if (this.appActivityAPI) {\n        this.appActivityAPI.destroy();\n        delete this.appActivityAPI;\n      }\n      if (this.tasksNewAPI) {\n        this.tasksNewAPI.destroy();\n        delete this.tasksNewAPI;\n      }\n      this.destroyTaskCollaborators();\n      this.destroyTaskLinks();\n    }\n  }]);\n  return Feed;\n}(Base);\nexport default Feed;","map":{"version":3,"sources":["../../src/api/Feed.js"],"names":["uniqueId","noop","getBadItemError","getBadUserError","isUserCorrectableError","commonMessages","messages","sortFeedItems","Base","AnnotationsAPI","CommentsAPI","VersionsAPI","TasksNewAPI","GroupsAPI","TaskCollaboratorsAPI","TaskLinksAPI","AppActivityAPI","ERROR_CODE_CREATE_TASK","ERROR_CODE_UPDATE_TASK","ERROR_CODE_GROUP_EXCEEDS_LIMIT","HTTP_STATUS_CODE_CONFLICT","IS_ERROR_DISPLAYED","TASK_NEW_APPROVED","TASK_NEW_COMPLETED","TASK_NEW_REJECTED","TASK_NEW_NOT_STARTED","TYPED_ID_FEED_PREFIX","TASK_MAX_GROUP_ASSIGNEES","TASK_NEW_INITIAL_STATUS","TASK","Feed","options","taskCollaboratorsAPI","taskLinksAPI","errors","file","currentUser","annotation","id","isPending","newAnnotation","created_by","type","addPendingItem","updateFeedItem","annotationId","permissions","successCallBack","errorCallback","annotationsAPI","deleteAnnotation","deleteFeedItem","bind","error","code","deleteCommentErrorCallback","cache","getCache","cacheKey","getCacheKey","get","items","set","shouldRefreshCache","successCallback","onError","shouldShowAnnotations","shouldShowAppActivity","cachedItems","getCachedItems","length","annotationsPromise","fetchAnnotations","Promise","resolve","versionsPromise","fetchVersions","currentVersionPromise","fetchCurrentVersion","commentsPromise","fetchComments","tasksPromise","fetchTasksNew","appActivityPromise","fetchAppActivity","all","then","versions","currentVersion","feedItems","versionsWithCurrent","versionsAPI","addCurrentVersion","sortedFeedItems","isDestroyed","setCachedItems","getAnnotations","undefined","fetchFeedItemErrorCallback","commentsAPI","getComments","getVersions","file_version","getVersion","tasksNewAPI","getTasksForFile","err","e","status","shouldDisplayError","feedErrorCallback","taskId","taskCollaboratorId","taskCollaboratorStatus","collaboratorsApi","push","taskCollaboratorPayload","handleError","errorMessage","taskApproveErrorMessage","taskCompleteErrorMessage","taskRejectErrorMessage","createFeedError","taskActionErrorTitle","updateTaskCollaborator","taskCollaborator","taskCollab","updateTaskCollaboratorSuccessCallback","updatedCollaborator","getTask","task","groupInfoPromises","addedAssignees","filter","assignee","item","map","getGroupCount","group","groupId","groupCounts","hasAnyGroupCountExceeded","some","groupInfo","total_count","warning","reject","updateTaskWithDeps","taskData","commentId","deleteComment","commentDeleteErrorMessage","message","assignees","taskType","dueAt","completionRule","uuid","dueAtString","dueAtDate","Date","toISOString","pendingTask","target","role","completion_rule","created_at","due_at","description","assigned_to","entries","avatar_url","can_delete","can_update","limit","next_marker","can_create_task_collaborator","can_create_task_link","task_links","task_type","taskPayload","createTaskWithDeps","taskWithDepsData","catch","createTaskCollaboratorsforGroup","createTaskCollaborator","user","deleteTaskCollaborator","createTaskLink","deleteTask","taskDeleteErrorMessage","feedItem","hasError","console","itemBase","date","pendingFeedItem","modified_at","feedItemsWithPendingItem","commentData","tagged_message","commentCreateConflictMessage","commentCreateErrorMessage","title","errorOccured","updates","updatedFeedItems","text","hasMention","taggedMessage","createComment","comment","createCommentSuccessCallback","createCommentErrorCallback","updateComment","Array","isArray","forEach","api","destroy","appActivityAPI","getAppActivity","appActivityId","deleteAppActivity","deleteAppActivityErrorCallback","appActivityDeleteErrorMessage","destroyTaskCollaborators","destroyTaskLinks"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for activity feed API's\n * @author Box\n */\nimport uniqueId from 'lodash/uniqueId';\nimport noop from 'lodash/noop';\nimport type { MessageDescriptor } from 'react-intl';\nimport { getBadItemError, getBadUserError, isUserCorrectableError } from '../utils/error';\nimport commonMessages from '../elements/common/messages';\nimport messages from './messages';\nimport { sortFeedItems } from '../utils/sorter';\nimport Base from './Base';\nimport AnnotationsAPI from './Annotations';\nimport CommentsAPI from './Comments';\nimport VersionsAPI from './Versions';\nimport TasksNewAPI from './tasks/TasksNew';\nimport GroupsAPI from './Groups';\nimport TaskCollaboratorsAPI from './tasks/TaskCollaborators';\nimport TaskLinksAPI from './tasks/TaskLinks';\nimport AppActivityAPI from './AppActivity';\nimport {\n    ERROR_CODE_CREATE_TASK,\n    ERROR_CODE_UPDATE_TASK,\n    ERROR_CODE_GROUP_EXCEEDS_LIMIT,\n    HTTP_STATUS_CODE_CONFLICT,\n    IS_ERROR_DISPLAYED,\n    TASK_NEW_APPROVED,\n    TASK_NEW_COMPLETED,\n    TASK_NEW_REJECTED,\n    TASK_NEW_NOT_STARTED,\n    TYPED_ID_FEED_PREFIX,\n    TASK_MAX_GROUP_ASSIGNEES,\n} from '../constants';\nimport type {\n    TaskCompletionRule,\n    TaskCollabAssignee,\n    TaskCollabStatus,\n    TaskLink,\n    TaskNew,\n    TaskType,\n    TaskPayload,\n    TaskUpdatePayload,\n} from '../common/types/tasks';\nimport type { ElementsXhrError, ErrorResponseData, APIOptions } from '../common/types/api';\nimport type {\n    SelectorItems,\n    SelectorItem,\n    UserMini,\n    GroupMini,\n    BoxItem,\n    BoxItemPermission,\n    BoxItemVersion,\n    FileVersions,\n    User,\n} from '../common/types/core';\nimport type {\n    Annotation,\n    AnnotationPermission,\n    Annotations,\n    AppActivityItems,\n    Comment,\n    Comments,\n    FeedItem,\n    FeedItems,\n    Task,\n    Tasks,\n} from '../common/types/feed';\n\nconst TASK_NEW_INITIAL_STATUS = TASK_NEW_NOT_STARTED;\nconst TASK = 'task';\n\ntype FeedItemsCache = {\n    errors: ErrorResponseData[],\n    items: FeedItems,\n};\n\ntype ErrorCallback = (e: ElementsXhrError, code: string, contextInfo?: Object) => void;\n\nclass Feed extends Base {\n    /**\n     * @property {AnnotationsAPI}\n     */\n    annotationsAPI: AnnotationsAPI;\n\n    /**\n     * @property {VersionsAPI}\n     */\n    versionsAPI: VersionsAPI;\n\n    /**\n     * @property {CommentsAPI}\n     */\n    commentsAPI: CommentsAPI;\n\n    /**\n     * @property {AppActivityAPI}\n     */\n    appActivityAPI: AppActivityAPI;\n\n    /**\n     * @property {TasksNewAPI}\n     */\n    tasksNewAPI: TasksNewAPI;\n\n    /**\n     * @property {TaskCollaboratorsAPI}\n     */\n    taskCollaboratorsAPI: TaskCollaboratorsAPI[];\n\n    /**\n     * @property {TaskLinksAPI}\n     */\n    taskLinksAPI: TaskLinksAPI[];\n\n    /**\n     * @property {BoxItem}\n     */\n    file: BoxItem;\n\n    /**\n     * @property {ElementsXhrError}\n     */\n    errors: ElementsXhrError[];\n\n    constructor(options: APIOptions) {\n        super(options);\n        this.taskCollaboratorsAPI = [];\n        this.taskLinksAPI = [];\n        this.errors = [];\n    }\n\n    /**\n     * Creates pending card on create_start action, then updates card on next call\n     * @param {BoxItem} file - The file to which the annotation is assigned\n     * @param {Object} currentUser - the user who performed the action\n     * @param {Annotation} annotation - the current annotation to be created\n     * @param {string} id - unique id for the incoming annotation\n     * @param {boolean} isPending - indicates the current creation process of the annotation\n     */\n    addAnnotation(file: BoxItem, currentUser: User, annotation: Annotation, id: string, isPending: boolean): void {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n\n        // Add the pending interstitial card\n        if (isPending) {\n            const newAnnotation = {\n                ...annotation,\n                created_by: currentUser,\n                id,\n                type: 'annotation',\n            };\n\n            this.addPendingItem(this.file.id, currentUser, newAnnotation);\n\n            return;\n        }\n        // Create action has completed, so update the existing pending item\n        this.updateFeedItem({ ...annotation, isPending: false }, id);\n    }\n\n    deleteAnnotation = (\n        file: BoxItem,\n        annotationId: string,\n        permissions: AnnotationPermission,\n        successCallBack: Function,\n        errorCallback: Function,\n    ): void => {\n        this.annotationsAPI = new AnnotationsAPI(this.options);\n\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n\n        this.updateFeedItem({ isPending: true }, annotationId);\n        this.annotationsAPI.deleteAnnotation(\n            this.file.id,\n            annotationId,\n            permissions,\n            this.deleteFeedItem.bind(this, annotationId, successCallBack),\n            (error: ElementsXhrError, code: string) => {\n                // Reusing comment error handler since annotations are treated as comments to user\n                this.deleteCommentErrorCallback(error, code, annotationId);\n            },\n        );\n    };\n\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id folder id\n     * @return {string} key\n     */\n    getCacheKey(id: string): string {\n        return `${TYPED_ID_FEED_PREFIX}${id}`;\n    }\n\n    /**\n     * Gets the items from the cache\n     *\n     * @param {string} id the cache id\n     */\n    getCachedItems(id: string): ?FeedItemsCache {\n        const cache = this.getCache();\n        const cacheKey = this.getCacheKey(id);\n        return cache.get(cacheKey);\n    }\n\n    /**\n     * Sets the items in the cache\n     *\n     * @param {string} id - the cache id\n     * @param {Array} items - the feed items to cache\n     */\n    setCachedItems(id: string, items: FeedItems) {\n        const cache = this.getCache();\n        const cacheKey = this.getCacheKey(id);\n        cache.set(cacheKey, {\n            errors: this.errors,\n            items,\n        });\n    }\n\n    /**\n     * Gets the feed items\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {boolean} shouldRefreshCache - Optionally updates the cache\n     * @param {Function} successCallback - the success callback  which is called after data fetching is complete\n     * @param {Function} errorCallback - the error callback which is called after data fetching is complete if there was an error\n     * @param {Function} onError - the function to be called immediately after an error occurs\n     * @param {Object} [options]- feature flips, etc\n     * @param {Object} [options.shouldShowAppActivity] - feature flip the new app activity api\n     */\n    feedItems(\n        file: BoxItem,\n        shouldRefreshCache: boolean,\n        successCallback: Function,\n        errorCallback: (feedItems: FeedItems, errors: ElementsXhrError[]) => void,\n        onError: ErrorCallback,\n        {\n            shouldShowAnnotations = false,\n            shouldShowAppActivity = false,\n        }: { shouldShowAnnotations?: boolean, shouldShowAppActivity?: boolean } = {},\n    ): void {\n        const { id, permissions = {} } = file;\n        const cachedItems = this.getCachedItems(id);\n        if (cachedItems) {\n            const { errors, items } = cachedItems;\n            if (errors.length) {\n                errorCallback(items, errors);\n            } else {\n                successCallback(items);\n            }\n\n            if (!shouldRefreshCache) {\n                return;\n            }\n        }\n\n        this.file = file;\n        this.errors = [];\n        this.errorCallback = onError;\n        const annotationsPromise = shouldShowAnnotations ? this.fetchAnnotations(permissions) : Promise.resolve();\n        const versionsPromise = this.fetchVersions();\n        const currentVersionPromise = this.fetchCurrentVersion();\n        const commentsPromise = this.fetchComments(permissions);\n        const tasksPromise = this.fetchTasksNew();\n        const appActivityPromise = shouldShowAppActivity ? this.fetchAppActivity(permissions) : Promise.resolve();\n\n        Promise.all([\n            versionsPromise,\n            currentVersionPromise,\n            commentsPromise,\n            tasksPromise,\n            appActivityPromise,\n            annotationsPromise,\n        ]).then(([versions: ?FileVersions, currentVersion: ?BoxItemVersion, ...feedItems]) => {\n            const versionsWithCurrent = this.versionsAPI.addCurrentVersion(currentVersion, versions, this.file);\n            const sortedFeedItems = sortFeedItems(versionsWithCurrent, ...feedItems);\n            if (!this.isDestroyed()) {\n                this.setCachedItems(id, sortedFeedItems);\n                if (this.errors.length) {\n                    errorCallback(sortedFeedItems, this.errors);\n                } else {\n                    successCallback(sortedFeedItems);\n                }\n            }\n        });\n    }\n\n    fetchAnnotations(permissions: BoxItemPermission): Promise<?Annotations> {\n        this.annotationsAPI = new AnnotationsAPI(this.options);\n        return new Promise(resolve => {\n            this.annotationsAPI.getAnnotations(\n                this.file.id,\n                undefined,\n                permissions,\n                resolve,\n                this.fetchFeedItemErrorCallback.bind(this, resolve),\n            );\n        });\n    }\n\n    /**\n     * Fetches the comments for a file\n     *\n     * @param {Object} permissions - the file permissions\n     * @return {Promise} - the file comments\n     */\n    fetchComments(permissions: BoxItemPermission): Promise<?Comments> {\n        this.commentsAPI = new CommentsAPI(this.options);\n        return new Promise(resolve => {\n            this.commentsAPI.getComments(\n                this.file.id,\n                permissions,\n                resolve,\n                this.fetchFeedItemErrorCallback.bind(this, resolve),\n            );\n        });\n    }\n\n    /**\n     * Fetches the versions for a file\n     *\n     * @return {Promise} - the file versions\n     */\n    fetchVersions(): Promise<?FileVersions> {\n        this.versionsAPI = new VersionsAPI(this.options);\n\n        return new Promise(resolve => {\n            this.versionsAPI.getVersions(this.file.id, resolve, this.fetchFeedItemErrorCallback.bind(this, resolve));\n        });\n    }\n\n    /**\n     * Fetches the current version for a file\n     *\n     * @return {Promise} - the file versions\n     */\n    fetchCurrentVersion(): Promise<?BoxItemVersion> {\n        this.versionsAPI = new VersionsAPI(this.options);\n\n        return new Promise(resolve => {\n            const { file_version = {} } = this.file;\n            this.versionsAPI.getVersion(\n                this.file.id,\n                file_version.id,\n                resolve,\n                this.fetchFeedItemErrorCallback.bind(this, resolve),\n            );\n        });\n    }\n\n    /**\n     * Fetches the tasks for a file\n     *\n     * @return {Promise} - the feed items\n     */\n    fetchTasksNew(): Promise<?Tasks> {\n        this.tasksNewAPI = new TasksNewAPI(this.options);\n\n        return new Promise(resolve => {\n            this.tasksNewAPI.getTasksForFile({\n                file: { id: this.file.id },\n                successCallback: resolve,\n                errorCallback: (err, code) => this.fetchFeedItemErrorCallback(resolve, err, code),\n            });\n        });\n    }\n\n    /**\n     * Error callback for fetching feed items.\n     * Should only call the error callback if the response is a 401, 429 or >= 500\n     *\n     * @param {Function} resolve - the function which will be called on error\n     * @param {Object} e - the axios error\n     * @param {string} code - the error code\n     * @return {void}\n     */\n    fetchFeedItemErrorCallback(resolve: Function, e: ElementsXhrError, code: string) {\n        const { status } = e;\n        const shouldDisplayError = isUserCorrectableError(status);\n        this.feedErrorCallback(shouldDisplayError, e, code);\n        resolve();\n    }\n\n    /**\n     * Updates a task assignment\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {string} taskId - ID of task to be updated\n     * @param {string} taskCollaboratorId - Task assignment ID\n     * @param {TaskCollabStatus} taskCollaboratorStatus - New task assignment status\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error\n     * @return {void}\n     */\n    updateTaskCollaborator = (\n        file: BoxItem,\n        taskId: string,\n        taskCollaboratorId: string,\n        taskCollaboratorStatus: TaskCollabStatus,\n        successCallback: Function,\n        errorCallback: ErrorCallback,\n    ): void => {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n        this.updateFeedItem({ isPending: true }, taskId);\n        const collaboratorsApi = new TaskCollaboratorsAPI(this.options);\n        this.taskCollaboratorsAPI.push(collaboratorsApi);\n        const taskCollaboratorPayload = {\n            id: taskCollaboratorId,\n            status: taskCollaboratorStatus,\n        };\n        const handleError = (e: ElementsXhrError, code: string) => {\n            let errorMessage;\n            switch (taskCollaboratorStatus) {\n                case TASK_NEW_APPROVED:\n                    errorMessage = messages.taskApproveErrorMessage;\n                    break;\n                case TASK_NEW_COMPLETED:\n                    errorMessage = messages.taskCompleteErrorMessage;\n                    break;\n                case TASK_NEW_REJECTED:\n                    errorMessage = messages.taskRejectErrorMessage;\n                    break;\n                default:\n                    errorMessage = messages.taskCompleteErrorMessage;\n            }\n            this.updateFeedItem(this.createFeedError(errorMessage, messages.taskActionErrorTitle), taskId);\n            this.feedErrorCallback(true, e, code);\n        };\n        collaboratorsApi.updateTaskCollaborator({\n            file,\n            taskCollaborator: taskCollaboratorPayload,\n            successCallback: (taskCollab: TaskCollabAssignee) => {\n                this.updateTaskCollaboratorSuccessCallback(taskId, file, taskCollab, successCallback, handleError);\n            },\n            errorCallback: handleError,\n        });\n    };\n\n    /**\n     * Updates the task assignment state of the updated task\n     *\n     * @param {string} taskId - Box task id\n     * @param {TaskAssignment} updatedCollaborator - New task assignment from API\n     * @param {Function} successCallback - the function which will be called on success\n     * @return {void}\n     */\n    updateTaskCollaboratorSuccessCallback = (\n        taskId: string,\n        file: { id: string },\n        updatedCollaborator: TaskCollabAssignee,\n        successCallback: Function,\n        errorCallback: Function,\n    ): void => {\n        this.tasksNewAPI = new TasksNewAPI(this.options);\n        this.tasksNewAPI.getTask({\n            id: taskId,\n            file,\n            successCallback: task => {\n                this.updateFeedItem({ ...task, isPending: false }, taskId);\n                successCallback(updatedCollaborator);\n            },\n            errorCallback,\n        });\n    };\n\n    /**\n     * Updates a task in the new API\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {string} task - The update task payload object\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error\n     * @return {void}\n     */\n    updateTaskNew = async (\n        file: BoxItem,\n        task: TaskUpdatePayload,\n        successCallback: () => void = noop,\n        errorCallback: ErrorCallback = noop,\n    ) => {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n        this.tasksNewAPI = new TasksNewAPI(this.options);\n        this.updateFeedItem({ isPending: true }, task.id);\n\n        try {\n            // create request for the size of each group by ID\n            // TODO: use async/await for both creating and editing tasks\n            const groupInfoPromises: Array<Promise<any>> = task.addedAssignees\n                .filter(\n                    (assignee: SelectorItem<UserMini | GroupMini>) => assignee.item && assignee.item.type === 'group',\n                )\n                .map(assignee => assignee.id)\n                .map(groupId => {\n                    return new GroupsAPI(this.options).getGroupCount({\n                        file,\n                        group: { id: groupId },\n                    });\n                });\n\n            const groupCounts: Array<{ total_count: number }> = await Promise.all(groupInfoPromises);\n            const hasAnyGroupCountExceeded: boolean = groupCounts.some(\n                groupInfo => groupInfo.total_count > TASK_MAX_GROUP_ASSIGNEES,\n            );\n            const warning = {\n                code: ERROR_CODE_GROUP_EXCEEDS_LIMIT,\n                type: 'warning',\n            };\n\n            if (hasAnyGroupCountExceeded) {\n                this.feedErrorCallback(false, warning, ERROR_CODE_GROUP_EXCEEDS_LIMIT);\n                return;\n            }\n\n            await new Promise((resolve, reject) => {\n                this.tasksNewAPI.updateTaskWithDeps({\n                    file,\n                    task,\n                    successCallback: resolve,\n                    errorCallback: reject,\n                });\n            });\n\n            await new Promise((resolve, reject) => {\n                this.tasksNewAPI.getTask({\n                    file,\n                    id: task.id,\n                    successCallback: (taskData: Task) => {\n                        this.updateFeedItem(\n                            {\n                                ...taskData,\n                                isPending: false,\n                            },\n                            task.id,\n                        );\n\n                        resolve();\n                    },\n                    errorCallback: (e: ElementsXhrError) => {\n                        this.updateFeedItem({ isPending: false }, task.id);\n                        this.feedErrorCallback(false, e, ERROR_CODE_UPDATE_TASK);\n                        reject();\n                    },\n                });\n            });\n\n            // everything succeeded, so call the passed in success callback\n            if (!this.isDestroyed()) {\n                successCallback();\n            }\n        } catch (e) {\n            this.updateFeedItem({ isPending: false }, task.id);\n            this.feedErrorCallback(false, e, ERROR_CODE_UPDATE_TASK);\n        }\n    };\n\n    /**\n     * Deletes a comment.\n     *\n     * @param {BoxItem} file - The file to which the comment belongs to\n     * @param {string} commentId - Comment ID\n     * @param {BoxItemPermission} permissions - Permissions for the comment\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error     *\n     * @return {void}\n     */\n    deleteComment = (\n        file: BoxItem,\n        commentId: string,\n        permissions: BoxItemPermission,\n        successCallback: Function,\n        errorCallback: ErrorCallback,\n    ): void => {\n        this.commentsAPI = new CommentsAPI(this.options);\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n        this.updateFeedItem({ isPending: true }, commentId);\n\n        this.commentsAPI.deleteComment({\n            file,\n            commentId,\n            permissions,\n            successCallback: this.deleteFeedItem.bind(this, commentId, successCallback),\n            errorCallback: (e: ElementsXhrError, code: string) => {\n                this.deleteCommentErrorCallback(e, code, commentId);\n            },\n        });\n    };\n\n    /**\n     * Error callback for deleting a comment\n     *\n     * @param {ElementsXhrError} e - the error returned by the API\n     * @param {string} code - the error code\n     * @param {string} commentId - the comment id\n     * @return {void}\n     */\n    deleteCommentErrorCallback = (e: ElementsXhrError, code: string, commentId: string) => {\n        this.updateFeedItem(this.createFeedError(messages.commentDeleteErrorMessage), commentId);\n        this.feedErrorCallback(true, e, code);\n    };\n\n    /**\n     * Creates a task.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Object} currentUser - the user who performed the action\n     * @param {string} message - Task text\n     * @param {Array} assignees - List of assignees\n     * @param {number} dueAt - Task's due date\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error\n     * @return {void}\n     */\n    createTaskNew = (\n        file: BoxItem,\n        currentUser: User,\n        message: string,\n        assignees: SelectorItems<>,\n        taskType: TaskType,\n        dueAt: ?string,\n        completionRule: TaskCompletionRule,\n        successCallback: Function,\n        errorCallback: ErrorCallback,\n    ): void => {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n        const uuid = uniqueId('task_');\n        let dueAtString;\n        if (dueAt) {\n            const dueAtDate: Date = new Date(dueAt);\n            dueAtString = dueAtDate.toISOString();\n        }\n\n        // TODO: make pending task generator a function\n        const pendingTask: TaskNew = {\n            created_by: {\n                type: 'task_collaborator',\n                target: currentUser,\n                id: uniqueId(),\n                role: 'CREATOR',\n                status: TASK_NEW_INITIAL_STATUS,\n            },\n            completion_rule: completionRule,\n            created_at: new Date().toISOString(),\n            due_at: dueAtString,\n            id: uuid,\n            description: message,\n            type: TASK,\n            assigned_to: {\n                entries: assignees.map((assignee: SelectorItem<UserMini | GroupMini>) => ({\n                    id: uniqueId(),\n                    target: { ...assignee, avatar_url: '', type: 'user' },\n                    status: TASK_NEW_INITIAL_STATUS,\n                    permissions: {\n                        can_delete: false,\n                        can_update: false,\n                    },\n                    role: 'ASSIGNEE',\n                    type: 'task_collaborator',\n                })),\n                limit: 10,\n                next_marker: null,\n            },\n            permissions: {\n                can_update: false,\n                can_delete: false,\n                can_create_task_collaborator: false,\n                can_create_task_link: false,\n            },\n            task_links: {\n                entries: [\n                    {\n                        id: uniqueId(),\n                        type: 'task_link',\n                        target: {\n                            type: 'file',\n                            ...file,\n                        },\n                        permissions: {\n                            can_delete: false,\n                            can_update: false,\n                        },\n                    },\n                ],\n                limit: 1,\n                next_marker: null,\n            },\n            task_type: taskType,\n            status: TASK_NEW_NOT_STARTED,\n        };\n\n        const taskPayload: TaskPayload = {\n            description: message,\n            due_at: dueAtString,\n            task_type: taskType,\n            completion_rule: completionRule,\n        };\n\n        // create request for the size of each group by ID\n        const groupInfoPromises: Array<Promise<any>> = assignees\n            .filter((assignee: SelectorItem<UserMini | GroupMini>) => (assignee.item && assignee.item.type) === 'group')\n            .map(assignee => assignee.id)\n            .map(groupId => {\n                return new GroupsAPI(this.options).getGroupCount({\n                    file,\n                    group: { id: groupId },\n                });\n            });\n\n        // Fetch each group size in parallel --> return an array of group sizes\n        Promise.all(groupInfoPromises)\n            .then((groupCounts: Array<{ total_count: number }>) => {\n                const hasAnyGroupCountExceeded: boolean = groupCounts.some(\n                    groupInfo => groupInfo.total_count > TASK_MAX_GROUP_ASSIGNEES,\n                );\n                const warning = {\n                    code: ERROR_CODE_GROUP_EXCEEDS_LIMIT,\n                    type: 'warning',\n                };\n                if (hasAnyGroupCountExceeded) {\n                    this.feedErrorCallback(false, warning, ERROR_CODE_GROUP_EXCEEDS_LIMIT);\n                    return;\n                }\n\n                this.tasksNewAPI = new TasksNewAPI(this.options);\n                this.tasksNewAPI.createTaskWithDeps({\n                    file,\n                    task: taskPayload,\n                    assignees,\n                    successCallback: (taskWithDepsData: any) => {\n                        this.addPendingItem(this.file.id, currentUser, pendingTask);\n                        this.updateFeedItem(\n                            {\n                                ...taskWithDepsData,\n                                task_links: {\n                                    entries: taskWithDepsData.task_links,\n                                    next_marker: null,\n                                    limit: 1,\n                                },\n                                assigned_to: {\n                                    entries: taskWithDepsData.assigned_to,\n                                    next_marker: null,\n                                    limit: taskWithDepsData.assigned_to.length,\n                                },\n                                isPending: false,\n                            },\n                            uuid,\n                        );\n                        successCallback(taskWithDepsData);\n                    },\n                    errorCallback: (e: ElementsXhrError, code: string) => {\n                        this.feedErrorCallback(false, e, code);\n                    },\n                });\n            })\n            .catch(error => {\n                this.feedErrorCallback(false, error, ERROR_CODE_CREATE_TASK);\n            });\n    };\n\n    /**\n     * Creates a task group via the API.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Task|TaskUpdatePayload} task - The newly created or existing task from the API\n     * @param {SelectorItem} assignee - The user assigned to this task\n     * @param {Function} errorCallback - Task create error callback\n     * @return {Promise<TaskAssignment>}\n     */\n    createTaskCollaboratorsforGroup(\n        file: BoxItem,\n        task: Task | TaskUpdatePayload,\n        assignee: SelectorItem<UserMini | GroupMini>,\n    ): Promise<Array<TaskCollabAssignee>> {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        return new Promise((resolve, reject) => {\n            const taskCollaboratorsAPI = new TaskCollaboratorsAPI(this.options);\n            this.taskCollaboratorsAPI.push(taskCollaboratorsAPI);\n            taskCollaboratorsAPI.createTaskCollaboratorsforGroup({\n                file,\n                task,\n                group: assignee,\n                successCallback: resolve,\n                errorCallback: (e: ElementsXhrError) => {\n                    reject(e);\n                },\n            });\n        });\n    }\n\n    /**\n     * Creates a task collaborator via the API.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Task|TaskUpdatePayload} task - The newly created or existing task from the API\n     * @param {SelectorItem} assignee - The user assigned to this task\n     * @param {Function} errorCallback - Task create error callback\n     * @return {Promise<TaskAssignment>}\n     */\n    createTaskCollaborator(\n        file: BoxItem,\n        task: Task | TaskUpdatePayload,\n        assignee: SelectorItem<UserMini | GroupMini>,\n    ): Promise<TaskCollabAssignee> {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        return new Promise((resolve, reject) => {\n            const taskCollaboratorsAPI = new TaskCollaboratorsAPI(this.options);\n            this.taskCollaboratorsAPI.push(taskCollaboratorsAPI);\n\n            taskCollaboratorsAPI.createTaskCollaborator({\n                file,\n                task,\n                user: assignee,\n                successCallback: resolve,\n                errorCallback: (e: ElementsXhrError) => {\n                    reject(e);\n                },\n            });\n        });\n    }\n\n    /**\n     * Deletes a task collaborator via the API.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Task|TaskUpdatePayload} task - The newly deleted or existing task from the API\n     * @param {TaskCollabAssignee} assignee - The user assigned to this task\n     * @param {Function} errorCallback - Task delete error callback\n     * @return {Promise<TaskAssignment>}\n     */\n    deleteTaskCollaborator(\n        file: BoxItem,\n        task: Task | TaskUpdatePayload,\n        assignee: TaskCollabAssignee,\n    ): Promise<TaskCollabAssignee> {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file.id = file.id;\n        return new Promise((resolve, reject) => {\n            const taskCollaboratorsAPI = new TaskCollaboratorsAPI(this.options);\n            this.taskCollaboratorsAPI.push(taskCollaboratorsAPI);\n\n            taskCollaboratorsAPI.deleteTaskCollaborator({\n                file,\n                task,\n                taskCollaborator: { id: assignee.id },\n                successCallback: resolve,\n                errorCallback: (e: ElementsXhrError) => {\n                    reject(e);\n                },\n            });\n        });\n    }\n\n    /**\n     * Creates a task link via the API.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Task} task - The newly created task from the API\n     * @param {Function} errorCallback - Task create error callback\n     * @return {Promise<TaskAssignment}\n     */\n    createTaskLink(file: BoxItem, task: Task): Promise<TaskLink> {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        return new Promise((resolve, reject) => {\n            const taskLinksAPI = new TaskLinksAPI(this.options);\n            this.taskLinksAPI.push(taskLinksAPI);\n\n            taskLinksAPI.createTaskLink({\n                file,\n                task,\n                successCallback: resolve,\n                errorCallback: reject,\n            });\n        });\n    }\n\n    /**\n     * Deletes a task in the new API\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {string} taskId - The task's id\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error\n     * @return {void}\n     */\n    deleteTaskNew = (\n        file: BoxItem,\n        task: TaskNew,\n        successCallback: (taskId: string) => void = noop,\n        errorCallback: ErrorCallback = noop,\n    ) => {\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n        this.tasksNewAPI = new TasksNewAPI(this.options);\n        this.updateFeedItem({ isPending: true }, task.id);\n\n        this.tasksNewAPI.deleteTask({\n            file,\n            task,\n            successCallback: this.deleteFeedItem.bind(this, task.id, successCallback),\n            errorCallback: (e: ElementsXhrError, code: string) => {\n                this.updateFeedItem(this.createFeedError(messages.taskDeleteErrorMessage), task.id);\n                this.feedErrorCallback(true, e, code);\n            },\n        });\n    };\n\n    /**\n     * Deletes a feed item from the cache\n     *\n     * @param {string} id - The id of the feed item to be deleted\n     * @param {Function} successCallback - function to be called after the delete\n     */\n    deleteFeedItem = (id: string, successCallback: Function = noop) => {\n        const cachedItems = this.getCachedItems(this.file.id);\n        if (cachedItems) {\n            const feedItems = cachedItems.items.filter(feedItem => feedItem.id !== id);\n            this.setCachedItems(this.file.id, feedItems);\n\n            if (!this.isDestroyed()) {\n                successCallback(id);\n            }\n        }\n    };\n\n    /**\n     * Network error callback\n     *\n     * @param {boolean} hasError - true if the UI should display an error\n     * @param {ElementsXhrError} e - the error returned by the API\n     * @param {string} code - the error code for the error which occured\n     * @return {void}\n     */\n    feedErrorCallback = (hasError: boolean = false, e: ElementsXhrError, code: string): void => {\n        if (hasError) {\n            this.errors.push({ ...e, code });\n        }\n\n        if (!this.isDestroyed() && this.errorCallback) {\n            this.errorCallback(e, code, {\n                error: e,\n                [IS_ERROR_DISPLAYED]: hasError,\n            });\n        }\n\n        console.error(e); // eslint-disable-line no-console\n    };\n\n    /**\n     * Add a placeholder pending feed item.\n     *\n     * @param {string} id - the file id\n     * @param {Object} currentUser - the user who performed the action\n     * @param {Object} itemBase - Base properties for item to be added to the feed as pending.\n     * @return {void}\n     */\n    addPendingItem = (id: string, currentUser: User, itemBase: Object): Comment | Task | TaskNew | BoxItemVersion => {\n        if (!currentUser) {\n            throw getBadUserError();\n        }\n\n        const date = new Date().toISOString();\n        const pendingFeedItem = {\n            created_at: date,\n            created_by: currentUser,\n            modified_at: date,\n            isPending: true,\n            ...itemBase,\n        };\n        const cachedItems = this.getCachedItems(this.file.id);\n        const feedItems = cachedItems ? cachedItems.items : [];\n        const feedItemsWithPendingItem = [...feedItems, pendingFeedItem];\n        this.setCachedItems(id, feedItemsWithPendingItem);\n\n        return pendingFeedItem;\n    };\n\n    /**\n     * Callback for successful creation of a Comment.\n     *\n     * @param {Comment} commentData - API returned Comment\n     * @param {string} id - ID of the feed item to update with the new comment data\n     * @return {void}\n     */\n    createCommentSuccessCallback = (commentData: Comment, id: string, successCallback: Function): void => {\n        const { message = '', tagged_message = '' } = commentData;\n        // Comment component uses tagged_message only\n        commentData.tagged_message = tagged_message || message;\n\n        this.updateFeedItem(\n            {\n                ...commentData,\n                isPending: false,\n            },\n            id,\n        );\n\n        if (!this.isDestroyed()) {\n            successCallback(commentData);\n        }\n    };\n\n    /**\n     * Callback for failed creation of a Comment.\n     *\n     * @param {Object} e - The axios error\n     * @param {string} code - the error code\n     * @param {string} id - ID of the feed item to update\n     * @return {void}\n     */\n    createCommentErrorCallback = (e: ElementsXhrError, code: string, id: string) => {\n        const errorMessage =\n            e.status === HTTP_STATUS_CODE_CONFLICT\n                ? messages.commentCreateConflictMessage\n                : messages.commentCreateErrorMessage;\n        this.updateFeedItem(this.createFeedError(errorMessage), id);\n        this.feedErrorCallback(false, e, code);\n    };\n\n    /**\n     * Constructs an error object that renders to an inline feed error\n     *\n     * @param {string} message - The error message body.\n     * @param {string} title - The error message title.\n     * @return {Object} An error message object\n     */\n    createFeedError(message: MessageDescriptor, title: MessageDescriptor = commonMessages.errorOccured) {\n        return {\n            error: { message, title },\n        };\n    }\n\n    /**\n     * Replace a feed item with new feed item data.\n     *\n     * @param {Object} updates - The new data to be applied to the feed item.\n     * @param {string} id - ID of the feed item to replace.\n     * @return {void}\n     */\n    updateFeedItem = (updates: Object, id: string): ?FeedItems => {\n        if (!this.file.id) {\n            throw getBadItemError();\n        }\n\n        const cachedItems = this.getCachedItems(this.file.id);\n        if (cachedItems) {\n            const updatedFeedItems = cachedItems.items.map((item: FeedItem) => {\n                if (item.id === id) {\n                    return {\n                        ...item,\n                        ...updates,\n                    };\n                }\n\n                return item;\n            });\n\n            this.setCachedItems(this.file.id, updatedFeedItems);\n            return updatedFeedItems;\n        }\n\n        return null;\n    };\n\n    /**\n     * Create a comment, and make a pending item to be replaced once the API is successful.\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Object} currentUser - the user who performed the action\n     * @param {string} text - the comment text\n     * @param {boolean} hasMention - true if there is an @mention in the text\n     * @param {Function} successCallback - the success callback\n     * @param {Function} errorCallback - the error callback\n     * @return {void}\n     */\n    createComment = (\n        file: BoxItem,\n        currentUser: User,\n        text: string,\n        hasMention: boolean,\n        successCallback: Function,\n        errorCallback: ErrorCallback,\n    ): void => {\n        const uuid = uniqueId('comment_');\n        const commentData = {\n            id: uuid,\n            tagged_message: text,\n            type: 'comment',\n        };\n\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n        this.addPendingItem(this.file.id, currentUser, commentData);\n\n        const message = {};\n        if (hasMention) {\n            message.taggedMessage = text;\n        } else {\n            message.message = text;\n        }\n\n        this.commentsAPI = new CommentsAPI(this.options);\n\n        this.commentsAPI.createComment({\n            file,\n            ...message,\n            successCallback: (comment: Comment) => {\n                this.createCommentSuccessCallback(comment, uuid, successCallback);\n            },\n            errorCallback: (e: ErrorResponseData, code: string) => {\n                this.createCommentErrorCallback(e, code, uuid);\n            },\n        });\n    };\n\n    /**\n     * Update a comment\n     *\n     * @param {BoxItem} file - The file to which the task is assigned\n     * @param {Object} currentUser - the user who performed the action\n     * @param {string} text - the comment text\n     * @param {boolean} hasMention - true if there is an @mention in the text\n     * @param {Function} successCallback - the success callback\n     * @param {Function} errorCallback - the error callback\n     * @return {void}\n     */\n    updateComment = (\n        file: BoxItem,\n        commentId: string,\n        text: string,\n        hasMention: boolean,\n        permissions: BoxItemPermission,\n        successCallback: Function,\n        errorCallback: ErrorCallback,\n    ): void => {\n        const commentData = {\n            tagged_message: text,\n        };\n\n        if (!file.id) {\n            throw getBadItemError();\n        }\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n        this.updateFeedItem({ ...commentData, isPending: true }, commentId);\n\n        const message = {};\n        if (hasMention) {\n            message.tagged_message = text;\n        } else {\n            message.message = text;\n        }\n\n        this.commentsAPI = new CommentsAPI(this.options);\n\n        this.commentsAPI.updateComment({\n            file,\n            commentId,\n            permissions,\n            ...message,\n            successCallback: (comment: Comment) => {\n                // use the request payload instead of response in the\n                // feed item update because response may not contain\n                // the tagged version of the message\n                this.updateFeedItem(\n                    {\n                        ...message,\n                        isPending: false,\n                    },\n                    commentId,\n                );\n                if (!this.isDestroyed()) {\n                    successCallback(comment);\n                }\n            },\n            errorCallback: (e: ErrorResponseData, code: string) => {\n                this.feedErrorCallback(true, e, code);\n            },\n        });\n    };\n\n    destroyTaskCollaborators() {\n        if (Array.isArray(this.taskCollaboratorsAPI)) {\n            this.taskCollaboratorsAPI.forEach(api => api.destroy());\n            this.taskCollaboratorsAPI = [];\n        }\n    }\n\n    destroyTaskLinks() {\n        if (Array.isArray(this.taskLinksAPI)) {\n            this.taskLinksAPI.forEach(api => api.destroy());\n            this.taskLinksAPI = [];\n        }\n    }\n\n    /**\n     * Fetches app activities for a file\n     * @param {BoxItemPermission} permissions - Permissions to attach to the app activity items\n     *\n     * @return {Promise} - the feed items\n     */\n    fetchAppActivity(permissions: BoxItemPermission): Promise<?AppActivityItems> {\n        this.appActivityAPI = new AppActivityAPI(this.options);\n\n        return new Promise(resolve => {\n            this.appActivityAPI.getAppActivity(\n                this.file.id,\n                permissions,\n                resolve,\n                this.fetchFeedItemErrorCallback.bind(this, resolve),\n            );\n        });\n    }\n\n    /**\n     * Deletes an app activity item.\n     *\n     * @param {BoxItem} file - The file to which the app activity belongs to\n     * @param {string} appActivityId - The app activity item id to delete\n     * @param {Function} successCallback - the function which will be called on success\n     * @param {Function} errorCallback - the function which will be called on error\n     * @return {void}\n     */\n    deleteAppActivity = (\n        file: BoxItem,\n        appActivityId: string,\n        successCallback: Function,\n        errorCallback: ErrorCallback,\n    ): void => {\n        const { id } = file;\n        if (!id) {\n            throw getBadItemError();\n        }\n\n        this.appActivityAPI = new AppActivityAPI(this.options);\n\n        this.file = file;\n        this.errorCallback = errorCallback;\n        this.updateFeedItem({ isPending: true }, appActivityId);\n\n        this.appActivityAPI.deleteAppActivity({\n            id,\n            appActivityId,\n            successCallback: this.deleteFeedItem.bind(this, appActivityId, successCallback),\n            errorCallback: (e: ElementsXhrError, code: string) => {\n                this.deleteAppActivityErrorCallback(e, code, appActivityId);\n            },\n        });\n    };\n\n    /**\n     * Error callback for deleting an app activity item\n     *\n     * @param {ElementsXhrError} e - the error returned by the API\n     * @param {string} code - the error code\n     * @param {string} id - the app activity id\n     * @return {void}\n     */\n    deleteAppActivityErrorCallback = (e: ElementsXhrError, code: string, id: string) => {\n        this.updateFeedItem(this.createFeedError(messages.appActivityDeleteErrorMessage), id);\n        this.feedErrorCallback(true, e, code);\n    };\n\n    /**\n     * Destroys all the task feed API's\n     *\n     * @return {void}\n     */\n    destroy() {\n        super.destroy();\n\n        if (this.annotationsAPI) {\n            this.annotationsAPI.destroy();\n            delete this.annotationsAPI;\n        }\n\n        if (this.commentsAPI) {\n            this.commentsAPI.destroy();\n            delete this.commentsAPI;\n        }\n\n        if (this.versionsAPI) {\n            this.versionsAPI.destroy();\n            delete this.versionsAPI;\n        }\n\n        if (this.appActivityAPI) {\n            this.appActivityAPI.destroy();\n            delete this.appActivityAPI;\n        }\n\n        if (this.tasksNewAPI) {\n            this.tasksNewAPI.destroy();\n            delete this.tasksNewAPI;\n        }\n\n        this.destroyTaskCollaborators();\n        this.destroyTaskLinks();\n    }\n}\n\nexport default Feed;\n"]},"metadata":{},"sourceType":"module"}