{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Base helper for the Box Upload APIs\n * @author Box\n */\nimport Base from '../Base';\nimport { DEFAULT_RETRY_DELAY_MS, MS_IN_S, DEFAULT_HOSTNAME_UPLOAD } from '../../constants';\nvar MAX_RETRY = 5; // Note: We may have to change this number if we add a lot more fast upload hosts.\n\nvar MAX_REACHABILITY_RETRY = 10;\nvar BaseUpload = /*#__PURE__*/\nfunction (_Base) {\n  _inherits(BaseUpload, _Base);\n  function BaseUpload() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, BaseUpload);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BaseUpload)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"retryCount\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"reachabilityRetryCount\", 0);\n    _defineProperty(_assertThisInitialized(_this), \"isUploadFallbackLogicEnabled\", false);\n    _defineProperty(_assertThisInitialized(_this), \"makePreflightRequest\", function () {\n      if (_this.isDestroyed()) {\n        return;\n      }\n      var url = \"\".concat(_this.getBaseApiUrl(), \"/files/content\");\n      if (_this.fileId) {\n        url = url.replace('content', \"\".concat(_this.fileId, \"/content\"));\n      }\n      if (_this.isUploadFallbackLogicEnabled) {\n        // Add unreachable hosts to url\n        var unreachableHostUrls = _this.uploadsReachability.getUnreachableHostsUrls();\n        if (unreachableHostUrls.length !== 0) {\n          url += \"?unreachable_hosts=\".concat(unreachableHostUrls.join(','));\n        }\n      }\n      var _this$file = _this.file,\n        size = _this$file.size,\n        name = _this$file.name;\n      var attributes = {\n        name: _this.fileName || name,\n        parent: {\n          id: _this.folderId\n        },\n        description: _this.fileDescription,\n        size: size\n      };\n      _this.xhr.options({\n        url: url,\n        data: attributes,\n        successHandler: function successHandler(response) {\n          if (_this.isUploadFallbackLogicEnabled) {\n            _this.preflightSuccessReachabilityHandler(response);\n          } else {\n            _this.preflightSuccessHandler(response);\n          }\n        },\n        errorHandler: _this.preflightErrorHandler\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"preflightSuccessReachabilityHandler\", /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(_ref2) {\n        var data, upload_url, uploadHost, isHostReachable;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = _ref2.data;\n                if (!_this.isDestroyed()) {\n                  _context.next = 3;\n                  break;\n                }\n                return _context.abrupt(\"return\");\n              case 3:\n                upload_url = data.upload_url; // If upload_url is not available, don't make reachability test\n\n                if (upload_url) {\n                  _context.next = 7;\n                  break;\n                }\n                _this.preflightSuccessHandler({\n                  data: data\n                });\n                return _context.abrupt(\"return\");\n              case 7:\n                uploadHost = _this.getUploadHostFromUrl(upload_url); // The default upload host should always be reachable\n\n                if (!(uploadHost === \"\".concat(DEFAULT_HOSTNAME_UPLOAD, \"/\"))) {\n                  _context.next = 11;\n                  break;\n                }\n                _this.preflightSuccessHandler({\n                  data: data\n                });\n                return _context.abrupt(\"return\");\n              case 11:\n                _context.next = 13;\n                return _this.uploadsReachability.isReachable(uploadHost);\n              case 13:\n                isHostReachable = _context.sent;\n                if (isHostReachable) {\n                  _this.preflightSuccessHandler({\n                    data: data\n                  });\n                } else if (_this.reachabilityRetryCount >= MAX_REACHABILITY_RETRY) {\n                  _this.preflightSuccessHandler({\n                    data: {}\n                  });\n                } else {\n                  _this.reachabilityRetryCount += 1;\n                  _this.makePreflightRequest();\n                }\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    _defineProperty(_assertThisInitialized(_this), \"preflightErrorHandler\", function (error) {\n      if (_this.isDestroyed()) {\n        return;\n      }\n      _this.fileName = _this.file ? _this.file.name : ''; // TODO: Normalize error object and clean up error handling\n\n      var errorData = error;\n      var response = error.response;\n      if (response && response.data) {\n        errorData = response.data;\n      }\n      if (_this.retryCount >= MAX_RETRY) {\n        _this.errorCallback(errorData); // Automatically handle name conflict errors\n      } else if (errorData && errorData.status === 409) {\n        if (_this.overwrite) {\n          // Error response contains file ID to upload a new file version for\n          var conflictFileId = errorData.context_info.conflicts.id;\n          if (!_this.fileId && !!conflictFileId) {\n            _this.fileId = conflictFileId;\n          }\n        } else if (_this.conflictCallback) {\n          // conflictCallback handler for setting new file name\n          _this.fileName = _this.conflictCallback(_this.fileName);\n        } else {\n          // Otherwise, reupload and append timestamp\n          // 'test.jpg' becomes 'test-TIMESTAMP.jpg'\n          var extension = _this.fileName.substr(_this.fileName.lastIndexOf('.')) || '';\n          _this.fileName = \"\".concat(_this.fileName.substr(0, _this.fileName.lastIndexOf('.')), \"-\").concat(Date.now()).concat(extension);\n        }\n        _this.makePreflightRequest();\n        _this.retryCount += 1; // When rate limited, retry after interval defined in header\n      } else if (errorData && (errorData.status === 429 || errorData.code === 'too_many_requests')) {\n        var retryAfterMs = DEFAULT_RETRY_DELAY_MS;\n        if (errorData.headers) {\n          var retryAfterSec = parseInt(errorData.headers['retry-after'] || errorData.headers.get('Retry-After'), 10);\n          if (!Number.isNaN(retryAfterSec)) {\n            retryAfterMs = retryAfterSec * MS_IN_S;\n          }\n        }\n        _this.retryTimeout = setTimeout(_this.makePreflightRequest, retryAfterMs);\n        _this.retryCount += 1; // If another error status that isn't name conflict or rate limiting, fail upload\n      } else if (errorData && (errorData.status || errorData.message === 'Failed to fetch') && typeof _this.errorCallback === 'function') {\n        _this.errorCallback(errorData); // Retry with exponential backoff for other failures since these are likely to be network errors\n      } else {\n        _this.retryTimeout = setTimeout(_this.makePreflightRequest, Math.pow(2, _this.retryCount) * MS_IN_S);\n        _this.retryCount += 1;\n      }\n    });\n    return _this;\n  }\n  _createClass(BaseUpload, [{\n    key: \"readFile\",\n    /**\n     * Read a blob with FileReader\n     *\n     * @param {FileReader} reader\n     * @param {Blob} blob\n     * @return {Promise}\n     */\n    value: function readFile(reader, blob) {\n      return new Promise(function (resolve, reject) {\n        reader.readAsArrayBuffer(blob);\n        reader.onload = function () {\n          resolve({\n            buffer: reader.result,\n            readCompleteTimestamp: Date.now()\n          });\n        };\n        reader.onerror = reject;\n      });\n    }\n    /**\n     * Parse uploadHost from uploadUrl\n     *\n     * @param uploadUrl - uploadUrl from preflight response\n     * @return {string}\n     */\n  }, {\n    key: \"getUploadHostFromUrl\",\n    value: function getUploadHostFromUrl(uploadUrl) {\n      var splitUrl = uploadUrl.split('/');\n      var uploadHost = \"\".concat(splitUrl[0], \"//\").concat(splitUrl[2], \"/\");\n      return uploadHost;\n    }\n  }]);\n  return BaseUpload;\n}(Base);\nexport default BaseUpload;","map":{"version":3,"sources":["../../../src/api/uploads/BaseUpload.js"],"names":["Base","DEFAULT_RETRY_DELAY_MS","MS_IN_S","DEFAULT_HOSTNAME_UPLOAD","MAX_RETRY","MAX_REACHABILITY_RETRY","BaseUpload","isDestroyed","url","getBaseApiUrl","fileId","replace","isUploadFallbackLogicEnabled","unreachableHostUrls","uploadsReachability","getUnreachableHostsUrls","length","join","size","name","file","attributes","fileName","parent","id","folderId","description","fileDescription","xhr","options","data","successHandler","preflightSuccessReachabilityHandler","response","preflightSuccessHandler","errorHandler","preflightErrorHandler","upload_url","uploadHost","getUploadHostFromUrl","isHostReachable","isReachable","reachabilityRetryCount","makePreflightRequest","error","errorData","retryCount","errorCallback","status","overwrite","conflictFileId","context_info","conflicts","conflictCallback","extension","substr","lastIndexOf","Date","now","code","retryAfterMs","headers","retryAfterSec","parseInt","get","Number","isNaN","retryTimeout","setTimeout","message","reader","blob","Promise","resolve","reject","readAsArrayBuffer","onload","buffer","result","readCompleteTimestamp","onerror","uploadUrl","splitUrl","split"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Base helper for the Box Upload APIs\n * @author Box\n */\n\nimport Base from '../Base';\nimport { DEFAULT_RETRY_DELAY_MS, MS_IN_S, DEFAULT_HOSTNAME_UPLOAD } from '../../constants';\n\nconst MAX_RETRY = 5;\n// Note: We may have to change this number if we add a lot more fast upload hosts.\nconst MAX_REACHABILITY_RETRY = 10;\n\nclass BaseUpload extends Base {\n    errorCallback: Function;\n\n    file: File;\n\n    fileId: ?string;\n\n    fileName: string;\n\n    fileDescription: ?string;\n\n    folderId: string;\n\n    overwrite: boolean;\n\n    conflictCallback: ?(fileName: string) => string;\n\n    preflightSuccessHandler: Function;\n\n    retryCount: number = 0;\n\n    reachabilityRetryCount: number = 0;\n\n    retryTimeout: TimeoutID;\n\n    isUploadFallbackLogicEnabled: boolean = false;\n\n    /**\n     * Sends an upload pre-flight request. If a file ID is available,\n     * send a pre-flight request to that file version.\n     *\n     * @private\n     * @return {void}\n     */\n    makePreflightRequest = (): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        let url = `${this.getBaseApiUrl()}/files/content`;\n        if (this.fileId) {\n            url = url.replace('content', `${this.fileId}/content`);\n        }\n\n        if (this.isUploadFallbackLogicEnabled) {\n            // Add unreachable hosts to url\n            const unreachableHostUrls = this.uploadsReachability.getUnreachableHostsUrls();\n            if (unreachableHostUrls.length !== 0) {\n                url += `?unreachable_hosts=${unreachableHostUrls.join(',')}`;\n            }\n        }\n\n        const { size, name } = this.file;\n        const attributes = {\n            name: this.fileName || name,\n            parent: { id: this.folderId },\n            description: this.fileDescription,\n            size,\n        };\n\n        this.xhr.options({\n            url,\n            data: attributes,\n            successHandler: response => {\n                if (this.isUploadFallbackLogicEnabled) {\n                    this.preflightSuccessReachabilityHandler(response);\n                } else {\n                    this.preflightSuccessHandler(response);\n                }\n            },\n            errorHandler: this.preflightErrorHandler,\n        });\n    };\n\n    /**\n     * Handles successful preflight response.\n     * Performs a upload reachability test before calling preflightSuccessHandler.\n     *\n     * @param {Object} - Request options\n     * @return {Promise} Async function promise\n     */\n    preflightSuccessReachabilityHandler = async ({ data }: { data: { upload_url?: string } }): Promise<any> => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { upload_url } = data;\n        // If upload_url is not available, don't make reachability test\n        if (!upload_url) {\n            this.preflightSuccessHandler({ data });\n            return;\n        }\n\n        const uploadHost = this.getUploadHostFromUrl(upload_url);\n        // The default upload host should always be reachable\n        if (uploadHost === `${DEFAULT_HOSTNAME_UPLOAD}/`) {\n            this.preflightSuccessHandler({ data });\n            return;\n        }\n\n        // If upload host reachable upload file, else make a new preflight request\n        const isHostReachable = await this.uploadsReachability.isReachable(uploadHost);\n        if (isHostReachable) {\n            this.preflightSuccessHandler({ data });\n        } else if (this.reachabilityRetryCount >= MAX_REACHABILITY_RETRY) {\n            this.preflightSuccessHandler({ data: {} });\n        } else {\n            this.reachabilityRetryCount += 1;\n            this.makePreflightRequest();\n        }\n    };\n\n    /**\n     * Handles a preflight error\n     *\n     * @param {Object} error - preflight error\n     * @return {void}\n     */\n    preflightErrorHandler = (error: any): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.fileName = this.file ? this.file.name : '';\n\n        // TODO: Normalize error object and clean up error handling\n        let errorData = error;\n        const { response } = error;\n        if (response && response.data) {\n            errorData = response.data;\n        }\n\n        if (this.retryCount >= MAX_RETRY) {\n            this.errorCallback(errorData);\n            // Automatically handle name conflict errors\n        } else if (errorData && errorData.status === 409) {\n            if (this.overwrite) {\n                // Error response contains file ID to upload a new file version for\n                const conflictFileId = errorData.context_info.conflicts.id;\n                if (!this.fileId && !!conflictFileId) {\n                    this.fileId = conflictFileId;\n                }\n            } else if (this.conflictCallback) {\n                // conflictCallback handler for setting new file name\n                this.fileName = this.conflictCallback(this.fileName);\n            } else {\n                // Otherwise, reupload and append timestamp\n                // 'test.jpg' becomes 'test-TIMESTAMP.jpg'\n                const extension = this.fileName.substr(this.fileName.lastIndexOf('.')) || '';\n                this.fileName = `${this.fileName.substr(0, this.fileName.lastIndexOf('.'))}-${Date.now()}${extension}`;\n            }\n            this.makePreflightRequest();\n            this.retryCount += 1;\n\n            // When rate limited, retry after interval defined in header\n        } else if (errorData && (errorData.status === 429 || errorData.code === 'too_many_requests')) {\n            let retryAfterMs = DEFAULT_RETRY_DELAY_MS;\n\n            if (errorData.headers) {\n                const retryAfterSec = parseInt(\n                    errorData.headers['retry-after'] || errorData.headers.get('Retry-After'),\n                    10,\n                );\n\n                if (!Number.isNaN(retryAfterSec)) {\n                    retryAfterMs = retryAfterSec * MS_IN_S;\n                }\n            }\n\n            this.retryTimeout = setTimeout(this.makePreflightRequest, retryAfterMs);\n            this.retryCount += 1;\n\n            // If another error status that isn't name conflict or rate limiting, fail upload\n        } else if (\n            errorData &&\n            (errorData.status || errorData.message === 'Failed to fetch') &&\n            typeof this.errorCallback === 'function'\n        ) {\n            this.errorCallback(errorData);\n            // Retry with exponential backoff for other failures since these are likely to be network errors\n        } else {\n            this.retryTimeout = setTimeout(this.makePreflightRequest, 2 ** this.retryCount * MS_IN_S);\n            this.retryCount += 1;\n        }\n    };\n\n    /**\n     * Read a blob with FileReader\n     *\n     * @param {FileReader} reader\n     * @param {Blob} blob\n     * @return {Promise}\n     */\n    readFile(reader: FileReader, blob: Blob): Promise<any> {\n        return new Promise((resolve, reject) => {\n            reader.readAsArrayBuffer(blob);\n            reader.onload = () => {\n                resolve({\n                    buffer: reader.result,\n                    readCompleteTimestamp: Date.now(),\n                });\n            };\n\n            reader.onerror = reject;\n        });\n    }\n\n    /**\n     * Parse uploadHost from uploadUrl\n     *\n     * @param uploadUrl - uploadUrl from preflight response\n     * @return {string}\n     */\n    getUploadHostFromUrl(uploadUrl: string): string {\n        const splitUrl = uploadUrl.split('/');\n        const uploadHost = `${splitUrl[0]}//${splitUrl[2]}/`;\n        return uploadHost;\n    }\n}\n\nexport default BaseUpload;\n"]},"metadata":{},"sourceType":"module"}