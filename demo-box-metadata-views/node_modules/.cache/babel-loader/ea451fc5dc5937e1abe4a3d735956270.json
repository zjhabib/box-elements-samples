{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport omit from 'lodash/omit';\nimport classNames from 'classnames';\nimport './Menu.scss';\n/**\n * The selectors are used to identify the menu item that is selected. We need to eventually\n * rewrite this logic as there seem to be strong coupling between the selector and MenuItem\n * that we want to decouple. The span is here to allow Menu to recognize MenuItem even if it is\n * wrapped by a span coming from a tooltip.\n */\n\nvar MENU_ITEM_SELECTOR = '.menu-item:not([aria-disabled])';\nvar TOP_LEVEL_MENU_ITEM_SELECTOR = \"ul:not(.submenu) > \".concat(MENU_ITEM_SELECTOR, \", ul:not(.submenu) > li > \").concat(MENU_ITEM_SELECTOR, \", ul:not(.submenu) > span > \").concat(MENU_ITEM_SELECTOR);\nvar SUBMENU_ITEM_SELECTOR = \"ul.submenu > \".concat(MENU_ITEM_SELECTOR, \", ul.submenu > li > \").concat(MENU_ITEM_SELECTOR, \", ul.submenu > span > \").concat(MENU_ITEM_SELECTOR);\nfunction stopPropagationAndPreventDefault(event) {\n  event.stopPropagation();\n  event.preventDefault();\n}\nvar Menu = /*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Menu, _React$Component);\n  function Menu(_props) {\n    var _this;\n    _classCallCheck(this, Menu);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Menu).call(this, _props));\n    _defineProperty(_assertThisInitialized(_this), \"setInitialFocusIndex\", function () {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.props;\n      var initialFocusIndex = props.initialFocusIndex,\n        isHidden = props.isHidden;\n      if (isHidden || initialFocusIndex === undefined) {\n        return;\n      } // If an initialFocusIndex was specified, attempt to use it to focus\n\n      if (typeof initialFocusIndex === 'number') {\n        // We do this after a timeout so that the menu is properly mounted before we attempt to focus it\n        setTimeout(function () {\n          _this.setFocus(initialFocusIndex);\n        }, 0);\n      } else if (initialFocusIndex === null) {\n        // If no initial focus index is set, focus on the menu itself so that keyboard shortcut still works after a mouse click.\n        setTimeout(function () {\n          if (_this.menuEl) {\n            _this.menuEl.focus();\n          }\n        }, 0);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"setMenuItemEls\", function () {\n      var _this$props = _this.props,\n        isSubmenu = _this$props.isSubmenu,\n        menuItemSelector = _this$props.menuItemSelector;\n      var selector = menuItemSelector || (isSubmenu ? SUBMENU_ITEM_SELECTOR : TOP_LEVEL_MENU_ITEM_SELECTOR); // Keep track of all the valid menu items that were rendered (querySelector since we don't want to pass ref functions to every single child)\n\n      _this.menuItemEls = _this.menuEl ? [].slice.call(_this.menuEl.querySelectorAll(selector)) : [];\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getMenuItemElFromEventTarget\", function (target) {\n      var menuItemEl = null;\n      var menuIndex = -1;\n      for (var i = 0; i < _this.menuItemEls.length; i += 1) {\n        if (_this.menuItemEls[i].contains(target)) {\n          menuItemEl = _this.menuItemEls[i];\n          menuIndex = i;\n          break;\n        }\n      }\n      return {\n        menuItemEl: menuItemEl,\n        menuIndex: menuIndex\n      };\n    });\n    _defineProperty(_assertThisInitialized(_this), \"setFocus\", function (index) {\n      if (!_this.menuItemEls.length) {\n        return;\n      }\n      var numMenuItems = _this.menuItemEls.length;\n      if (index >= numMenuItems) {\n        _this.focusIndex = 0;\n      } else if (index < 0) {\n        _this.focusIndex = numMenuItems - 1;\n      } else {\n        _this.focusIndex = index;\n      }\n      _this.menuItemEls[_this.focusIndex].focus();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"focusFirstItem\", function () {\n      _this.setFocus(0);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"focusLastItem\", function () {\n      _this.setFocus(-1);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"focusNextItem\", function () {\n      _this.setFocus(_this.focusIndex + 1);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"focusPreviousItem\", function () {\n      _this.setFocus(_this.focusIndex - 1);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"fireOnCloseHandler\", function (isKeyboardEvent, event) {\n      var onClose = _this.props.onClose;\n      if (onClose) {\n        // We need to pass the event type so we know which item to focus.\n        onClose(isKeyboardEvent, event);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleClick\", function (event) {\n      var _ref = event.target instanceof Node ? _this.getMenuItemElFromEventTarget(event.target) : {},\n        menuItemEl = _ref.menuItemEl;\n      if (!menuItemEl) {\n        return;\n      }\n      _this.fireOnCloseHandler(false, event);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleKeyDown\", function (event) {\n      var _this$props2 = _this.props,\n        isSubmenu = _this$props2.isSubmenu,\n        initialFocusIndex = _this$props2.initialFocusIndex;\n      switch (event.key) {\n        case 'ArrowDown':\n          stopPropagationAndPreventDefault(event); // If it's first keyboard event, focus on first item.\n\n          if (initialFocusIndex === null && !_this.keyboardPressed) {\n            _this.focusFirstItem();\n          } else {\n            _this.focusNextItem();\n          }\n          break;\n        case 'ArrowUp':\n          stopPropagationAndPreventDefault(event);\n          _this.focusPreviousItem();\n          break;\n        case 'ArrowLeft':\n          // Close submenu when arrow-left is clicked\n          if (!isSubmenu) {\n            return;\n          }\n          stopPropagationAndPreventDefault(event);\n          _this.fireOnCloseHandler(true, event);\n          break;\n        case 'Home':\n        case 'PageUp':\n          stopPropagationAndPreventDefault(event);\n          _this.focusFirstItem();\n          break;\n        case 'End':\n        case 'PageDown':\n          stopPropagationAndPreventDefault(event);\n          _this.focusLastItem();\n          break;\n        case 'Escape':\n          stopPropagationAndPreventDefault(event);\n          _this.fireOnCloseHandler(true, event);\n          break;\n        case 'Tab':\n          // DO NOT PREVENT DEFAULT OR STOP PROPAGATION - This should move focus natively\n          _this.fireOnCloseHandler(true, event);\n          break;\n        case ' ':\n        case 'Enter':\n          stopPropagationAndPreventDefault(event);\n          if (event.target instanceof HTMLElement) {\n            event.target.click();\n          }\n          break;\n        default:\n          break;\n      }\n      _this.keyboardPressed = true;\n    });\n    _this.focusIndex = 0;\n    _this.menuEl = null;\n    _this.menuItemEls = [];\n    return _this;\n  }\n  _createClass(Menu, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.setMenuItemEls();\n      this.setInitialFocusIndex();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(_ref2) {\n      var prevIsHidden = _ref2.isHidden,\n        prevChildren = _ref2.children;\n      var _this$props3 = this.props,\n        children = _this$props3.children,\n        isHidden = _this$props3.isHidden,\n        isSubmenu = _this$props3.isSubmenu;\n      if (isSubmenu && prevIsHidden && !isHidden) {\n        // If updating submenu, use the current props instead of previous props.\n        this.setMenuItemEls();\n        this.setInitialFocusIndex(this.props);\n      } // update focus index and menu item elements when the number of children changes\n\n      if (React.Children.toArray(prevChildren).length !== React.Children.toArray(children).length) {\n        var focusedMenuItemEl = this.menuItemEls[this.focusIndex];\n        this.setMenuItemEls();\n        var _this$getMenuItemElFr = this.getMenuItemElFromEventTarget(focusedMenuItemEl),\n          menuIndex = _this$getMenuItemElFr.menuIndex;\n        this.setFocus(menuIndex);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var _this$props4 = this.props,\n        children = _this$props4.children,\n        className = _this$props4.className,\n        isHidden = _this$props4.isHidden,\n        setRef = _this$props4.setRef,\n        shouldOutlineFocus = _this$props4.shouldOutlineFocus,\n        rest = _objectWithoutProperties(_this$props4, [\"children\", \"className\", \"isHidden\", \"setRef\", \"shouldOutlineFocus\"]);\n      var menuProps = omit(rest, ['onClose', 'initialFocusIndex', 'isSubmenu', 'menuItemSelector']);\n      menuProps.className = classNames('aria-menu', className, {\n        'is-hidden': isHidden,\n        'should-outline-focus': shouldOutlineFocus\n      });\n      menuProps.ref = function (ref) {\n        _this2.menuEl = ref;\n        if (setRef) {\n          setRef(ref);\n        }\n      };\n      menuProps.role = 'menu';\n      menuProps.tabIndex = -1;\n      menuProps.onClick = this.handleClick;\n      menuProps.onKeyDown = this.handleKeyDown;\n      return React.createElement(\"ul\", menuProps, children);\n    }\n  }]);\n  return Menu;\n}(React.Component);\n_defineProperty(Menu, \"defaultProps\", {\n  className: '',\n  isSubmenu: false,\n  isHidden: false\n});\nexport default Menu;","map":{"version":3,"sources":["../../../src/components/menu/Menu.tsx"],"names":["React","omit","classNames","MENU_ITEM_SELECTOR","TOP_LEVEL_MENU_ITEM_SELECTOR","SUBMENU_ITEM_SELECTOR","stopPropagationAndPreventDefault","event","stopPropagation","preventDefault","Menu","Component","className","isSubmenu","isHidden","props","focusIndex","menuEl","menuItemEls","setMenuItemEls","setInitialFocusIndex","prevIsHidden","children","prevChildren","Children","toArray","length","focusedMenuItemEl","menuIndex","getMenuItemElFromEventTarget","setFocus","initialFocusIndex","undefined","setTimeout","focus","menuItemSelector","selector","slice","call","querySelectorAll","target","menuItemEl","i","contains","index","numMenuItems","isKeyboardEvent","onClose","Node","fireOnCloseHandler","key","keyboardPressed","focusFirstItem","focusNextItem","focusPreviousItem","focusLastItem","HTMLElement","click","setRef","shouldOutlineFocus","rest","menuProps","ref","role","tabIndex","onClick","handleClick","onKeyDown","handleKeyDown"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport omit from 'lodash/omit';\nimport classNames from 'classnames';\n\nimport './Menu.scss';\n\n/**\n * The selectors are used to identify the menu item that is selected. We need to eventually\n * rewrite this logic as there seem to be strong coupling between the selector and MenuItem\n * that we want to decouple. The span is here to allow Menu to recognize MenuItem even if it is\n * wrapped by a span coming from a tooltip.\n */\nconst MENU_ITEM_SELECTOR = '.menu-item:not([aria-disabled])';\nconst TOP_LEVEL_MENU_ITEM_SELECTOR = `ul:not(.submenu) > ${MENU_ITEM_SELECTOR}, ul:not(.submenu) > li > ${MENU_ITEM_SELECTOR}, ul:not(.submenu) > span > ${MENU_ITEM_SELECTOR}`;\nconst SUBMENU_ITEM_SELECTOR = `ul.submenu > ${MENU_ITEM_SELECTOR}, ul.submenu > li > ${MENU_ITEM_SELECTOR}, ul.submenu > span > ${MENU_ITEM_SELECTOR}`;\n\nfunction stopPropagationAndPreventDefault(event: React.KeyboardEvent<HTMLElement>) {\n    event.stopPropagation();\n    event.preventDefault();\n}\n\ninterface MenuProps {\n    /** children - menu items */\n    children: Array<React.ReactNode> | Array<React.ReactChild> | React.ReactChild;\n    /** className - CSS class name for the menu */\n    className: string;\n    /** initialFocusIndex - focuses a specific menu item index when menu is mounted */\n    initialFocusIndex?: number;\n    /** isHidden - whether the menuâ€™s content is hidden */\n    isHidden?: boolean;\n    /** isSubmenu - whether this is a submenu of another menu */\n    isSubmenu?: boolean;\n    /** menuItemSelector - overrides the default menu selector */\n    menuItemSelector?: string;\n    /** onClick - function called when the menu is clicked */\n    onClick?: (event: React.MouseEvent<HTMLUListElement, MouseEvent>) => void;\n    /** onClick - function called when the menu is closed */\n    onClose?: (\n        isKeyboardEvent?: boolean,\n        event?: React.MouseEvent<HTMLUListElement, MouseEvent> | React.KeyboardEvent<HTMLElement>,\n    ) => void;\n    /** onClick - function called when a key is pressed within the menu */\n    onKeyDown?: (event: React.KeyboardEvent<HTMLUListElement>) => void;\n    /** ref - reference to the menu element in the DOM */\n    ref?: string | ((instance: HTMLUListElement | null) => void) | React.RefObject<HTMLUListElement> | null | undefined;\n    /** role - ARIA role for the menu */\n    role?: string;\n    /** setRef - will fire this callback when menu should \"close' */\n    setRef?: Function;\n    /** shouldOutlineFocus - whether the focused menu item should have an outline */\n    shouldOutlineFocus?: boolean;\n    /** tabIndex - indicator of whether the menu is focusable */\n    tabIndex?: number;\n}\n\nclass Menu extends React.Component<MenuProps> {\n    static defaultProps = {\n        className: '',\n        isSubmenu: false,\n        isHidden: false,\n    };\n\n    constructor(props: MenuProps) {\n        super(props);\n\n        this.focusIndex = 0;\n        this.menuEl = null;\n        this.menuItemEls = [];\n    }\n\n    componentDidMount() {\n        this.setMenuItemEls();\n        this.setInitialFocusIndex();\n    }\n\n    componentDidUpdate({ isHidden: prevIsHidden, children: prevChildren }: MenuProps) {\n        const { children, isHidden, isSubmenu } = this.props;\n\n        if (isSubmenu && prevIsHidden && !isHidden) {\n            // If updating submenu, use the current props instead of previous props.\n            this.setMenuItemEls();\n            this.setInitialFocusIndex(this.props);\n        }\n\n        // update focus index and menu item elements when the number of children changes\n        if (React.Children.toArray(prevChildren).length !== React.Children.toArray(children).length) {\n            const focusedMenuItemEl = this.menuItemEls[this.focusIndex];\n            this.setMenuItemEls();\n            const { menuIndex } = this.getMenuItemElFromEventTarget(focusedMenuItemEl);\n            this.setFocus(menuIndex);\n        }\n    }\n\n    setInitialFocusIndex = (props: MenuProps = this.props) => {\n        const { initialFocusIndex, isHidden } = props;\n\n        if (isHidden || initialFocusIndex === undefined) {\n            return;\n        }\n\n        // If an initialFocusIndex was specified, attempt to use it to focus\n        if (typeof initialFocusIndex === 'number') {\n            // We do this after a timeout so that the menu is properly mounted before we attempt to focus it\n            setTimeout(() => {\n                this.setFocus(initialFocusIndex);\n            }, 0);\n        } else if (initialFocusIndex === null) {\n            // If no initial focus index is set, focus on the menu itself so that keyboard shortcut still works after a mouse click.\n            setTimeout(() => {\n                if (this.menuEl) {\n                    this.menuEl.focus();\n                }\n            }, 0);\n        }\n    };\n\n    setMenuItemEls = () => {\n        const { isSubmenu, menuItemSelector } = this.props;\n\n        const selector = menuItemSelector || (isSubmenu ? SUBMENU_ITEM_SELECTOR : TOP_LEVEL_MENU_ITEM_SELECTOR);\n        // Keep track of all the valid menu items that were rendered (querySelector since we don't want to pass ref functions to every single child)\n        this.menuItemEls = this.menuEl ? [].slice.call(this.menuEl.querySelectorAll(selector)) : [];\n    };\n\n    getMenuItemElFromEventTarget = (\n        target: Node,\n    ): {\n        menuItemEl?: HTMLElement | null;\n        menuIndex: number;\n    } => {\n        let menuItemEl = null;\n        let menuIndex = -1;\n\n        for (let i = 0; i < this.menuItemEls.length; i += 1) {\n            if (this.menuItemEls[i].contains(target)) {\n                menuItemEl = this.menuItemEls[i];\n                menuIndex = i;\n                break;\n            }\n        }\n        return { menuItemEl, menuIndex };\n    };\n\n    setFocus = (index: number) => {\n        if (!this.menuItemEls.length) {\n            return;\n        }\n\n        const numMenuItems = this.menuItemEls.length;\n\n        if (index >= numMenuItems) {\n            this.focusIndex = 0;\n        } else if (index < 0) {\n            this.focusIndex = numMenuItems - 1;\n        } else {\n            this.focusIndex = index;\n        }\n\n        this.menuItemEls[this.focusIndex].focus();\n    };\n\n    focusIndex: number;\n\n    keyboardPressed: boolean | null | undefined;\n\n    menuEl: HTMLUListElement | null | undefined;\n\n    menuItemEls: Array<HTMLElement>;\n\n    focusFirstItem = () => {\n        this.setFocus(0);\n    };\n\n    focusLastItem = () => {\n        this.setFocus(-1);\n    };\n\n    focusNextItem = () => {\n        this.setFocus(this.focusIndex + 1);\n    };\n\n    focusPreviousItem = () => {\n        this.setFocus(this.focusIndex - 1);\n    };\n\n    fireOnCloseHandler = (\n        isKeyboardEvent?: boolean,\n        event?: React.MouseEvent<HTMLUListElement, MouseEvent> | React.KeyboardEvent<HTMLElement>,\n    ) => {\n        const { onClose } = this.props;\n\n        if (onClose) {\n            // We need to pass the event type so we know which item to focus.\n            onClose(isKeyboardEvent, event);\n        }\n    };\n\n    handleClick = (event: React.MouseEvent<HTMLUListElement, MouseEvent>) => {\n        const { menuItemEl }: { menuItemEl?: HTMLElement | null } =\n            event.target instanceof Node ? this.getMenuItemElFromEventTarget(event.target) : {};\n\n        if (!menuItemEl) {\n            return;\n        }\n        this.fireOnCloseHandler(false, event);\n    };\n\n    handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n        const { isSubmenu, initialFocusIndex } = this.props;\n\n        switch (event.key) {\n            case 'ArrowDown':\n                stopPropagationAndPreventDefault(event); // If it's first keyboard event, focus on first item.\n\n                if (initialFocusIndex === null && !this.keyboardPressed) {\n                    this.focusFirstItem();\n                } else {\n                    this.focusNextItem();\n                }\n\n                break;\n\n            case 'ArrowUp':\n                stopPropagationAndPreventDefault(event);\n                this.focusPreviousItem();\n                break;\n\n            case 'ArrowLeft':\n                // Close submenu when arrow-left is clicked\n                if (!isSubmenu) {\n                    return;\n                }\n\n                stopPropagationAndPreventDefault(event);\n                this.fireOnCloseHandler(true, event);\n                break;\n\n            case 'Home':\n            case 'PageUp':\n                stopPropagationAndPreventDefault(event);\n                this.focusFirstItem();\n                break;\n\n            case 'End':\n            case 'PageDown':\n                stopPropagationAndPreventDefault(event);\n                this.focusLastItem();\n                break;\n\n            case 'Escape':\n                stopPropagationAndPreventDefault(event);\n                this.fireOnCloseHandler(true, event);\n                break;\n\n            case 'Tab':\n                // DO NOT PREVENT DEFAULT OR STOP PROPAGATION - This should move focus natively\n                this.fireOnCloseHandler(true, event);\n                break;\n\n            case ' ':\n            case 'Enter':\n                stopPropagationAndPreventDefault(event);\n\n                if (event.target instanceof HTMLElement) {\n                    event.target.click();\n                }\n\n                break;\n\n            default:\n                break;\n        }\n\n        this.keyboardPressed = true;\n    };\n\n    render() {\n        const { children, className, isHidden, setRef, shouldOutlineFocus, ...rest } = this.props;\n\n        const menuProps = omit(rest, ['onClose', 'initialFocusIndex', 'isSubmenu', 'menuItemSelector']) as MenuProps;\n        menuProps.className = classNames('aria-menu', className, {\n            'is-hidden': isHidden,\n            'should-outline-focus': shouldOutlineFocus,\n        });\n        menuProps.ref = (ref: HTMLUListElement | null) => {\n            this.menuEl = ref;\n            if (setRef) {\n                setRef(ref);\n            }\n        };\n        menuProps.role = 'menu';\n        menuProps.tabIndex = -1;\n        menuProps.onClick = this.handleClick;\n        menuProps.onKeyDown = this.handleKeyDown;\n\n        return <ul {...menuProps}>{children}</ul>;\n    }\n}\n\nexport default Menu;\n"]},"metadata":{},"sourceType":"module"}