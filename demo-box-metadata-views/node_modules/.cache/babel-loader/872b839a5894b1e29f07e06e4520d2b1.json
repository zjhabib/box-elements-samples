{"ast":null,"code":"/**\n * \n * @file Date and time utilities\n * @author Box\n */\nimport isNaN from 'lodash/isNaN';\nvar MILLISECONDS_PER_SECOND = 1000; // 24 hours * 60 minutes * 60 seconds * 1000 milliseconds\n\nvar MILLISECONDS_PER_DAY = 24 * 60 * 60 * MILLISECONDS_PER_SECOND; // 60 sec * 1000\n\nvar MILLISECONDS_PER_MINUTE = 60 * MILLISECONDS_PER_SECOND;\n/**\n * RegExp matcher for acceptable ISO 8601 date formats w/ timezone (see below)\n * Capture groups structured as follows:\n * 1) the date/time portion (2018-06-13T00:00:00.000)\n * 2) the milliseconds (if matched)\n * 3) the timezone portion (e.g., Z, +03, -0400, +05:00)\n * 4) the Z format for timezone (if matched)\n * 5) the short format for timezone (if matched)\n * 6) the colon-less format for timezone (if matched)\n * 7) the colon long format for timezone (if matched)\n */\n\nvar RE_ISO8601_DATE = /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,3})?)?((Z$)|(?:[+-](?:([0-2]\\d$)|([0-2]\\d(?:00|30)$)|([0-2]\\d:(?:00|30)$))))$/;\nvar ISO8601_DATETIME = 1;\nvar ISO8601_MILLISECONDS = 2;\nvar ISO8601_TIMEZONE = 3;\nvar ISO8601_Z_FMT = 4;\nvar ISO8601_SHORT_FMT = 5;\nvar ISO8601_MEDIUM_FMT = 6;\nvar ISO8601_LONG_FMT = 7;\n/**\n * Helper to normalize a date value to a date object\n * @param dateValue - Date number, string, or object\n * @returns {date} the normalized date object\n */\n\nfunction convertToDate(dateValue) {\n  return dateValue instanceof Date ? dateValue : new Date(dateValue);\n}\n/**\n * Converts an integer value in seconds to milliseconds.\n * @param {number} seconds - The value in seconds\n * @returns {number} the value in milliseconds\n */\n\nfunction convertToMs(seconds) {\n  return seconds * MILLISECONDS_PER_SECOND;\n}\n/**\n * Checks whether the given date value (in unix milliseconds) is today.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is today\n */\n\nfunction isToday(dateValue) {\n  return new Date().toDateString() === convertToDate(dateValue).toDateString();\n}\n/**\n * Checks whether the given date value (in unix milliseconds) is yesterday.\n * @param {number|string|Date} dateValue - Date object or integer or representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is yesterday\n */\n\nfunction isYesterday(dateValue) {\n  return isToday(convertToDate(dateValue).getTime() + MILLISECONDS_PER_DAY);\n}\n/**\n * Checks whether the given date value (in unix milliseconds) is tomorrow.\n * @param {number|string|Date} dateValue - Date object or integer or representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is tomorrow\n */\n\nfunction isTomorrow(dateValue) {\n  return isToday(convertToDate(dateValue).getTime() - MILLISECONDS_PER_DAY);\n}\n/**\n * Checks whether the given date value (in unix milliseconds) is in the current month.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is in the current month\n */\n\nfunction isCurrentMonth(dateValue) {\n  return new Date().getMonth() === convertToDate(dateValue).getMonth();\n}\n/**\n * Checks whether the given date value (in unix milliseconds) is in the current year.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is in the current year\n */\n\nfunction isCurrentYear(dateValue) {\n  return new Date().getFullYear() === convertToDate(dateValue).getFullYear();\n}\n/**\n * Formats a number of seconds as a time string\n *\n * @param {number} seconds - seconds\n * @return {string} a string formatted like 3:57:35\n */\n\nfunction formatTime(seconds) {\n  var h = Math.floor(seconds / 3600);\n  var m = Math.floor(seconds % 3600 / 60);\n  var s = Math.floor(seconds % 3600 % 60);\n  var hour = h > 0 ? \"\".concat(h.toString(), \":\") : '';\n  var sec = s < 10 ? \"0\".concat(s.toString()) : s.toString();\n  var min = m.toString();\n  if (h > 0 && m < 10) {\n    min = \"0\".concat(min);\n  }\n  return \"\".concat(hour).concat(min, \":\").concat(sec);\n}\n/**\n * Adds time to a given dateValue\n *\n * @param {number|Date} dateValue - date or integer value to add time to\n * @param {number} timeToAdd - amount of time to add in ms\n * @return {number|Date} the modified date or integer\n */\n\nfunction addTime(dateValue, timeToAdd) {\n  if (dateValue instanceof Date) {\n    return new Date(dateValue.getTime() + timeToAdd);\n  }\n  return dateValue + timeToAdd;\n}\n/**\n * Will convert\n *      2018-06-13T07:00:00.000Z\n * to\n *      2018-06-13T00:00:00.000Z\n *\n * This is the opposite of convertISOStringToUTCDate\n *\n * @param {Date} date\n * @return {number}\n */\n\nfunction convertDateToUnixMidnightTime(date) {\n  // date is localized to 00:00:00 at system/browser timezone\n  var utcUnixTimeInMs = date.getTime(); // timezone an integer offset; minutes behind GMT\n  // we use the browser timezone offset instead of the user's,\n  // because the datepicker uses the browser to get the \"midnight\"\n  // time in the user's timezone with getTime()\n\n  var timezoneOffsetInMins = date.getTimezoneOffset();\n  var timezoneOffsetInMs = timezoneOffsetInMins * MILLISECONDS_PER_MINUTE; // we need the unix/epoch time for midnight on the date selected\n\n  var unixDayMidnightTime = utcUnixTimeInMs - timezoneOffsetInMs;\n  return unixDayMidnightTime;\n}\n/**\n * Will check to see if a date object is not valid, according to the browser\n * JS engine.\n *\n * @param {Date} date\n * @return {boolean} whether the date value passes validation\n */\n\nfunction isValidDate(date) {\n  return !isNaN(date.getTime());\n}\n/**\n * Will convert ISO8601-compatible dates (with zone designators)\n *      2018-06-13T00:00:00.000-0500\n *      or\n *      2018-06-13T00:00:00.000-05\n *\n * to\n *      2018-06-13T00:00:00.000-05:00\n *\n * Equivalent formats between the two (e.g., uzing 'Z') will remain unchanged.\n * If the date format cannot be converted, it will pass along the existing value\n * @param {string} isoString\n * @return {string} converted date format, if applicable\n */\n\nfunction convertISOStringtoRFC3339String(isoString) {\n  // test that the date format inbound is ISO8601-compatible\n  if (RE_ISO8601_DATE.test(isoString)) {\n    // if it is, parse out the timezone part if it's in a longer format\n    // use the capture groups instead of the split result for the datetime and the time zone\n    var parseDate = isoString.split(RE_ISO8601_DATE);\n    var dateTime = parseDate[ISO8601_DATETIME];\n    var milliseconds = parseDate[ISO8601_MILLISECONDS];\n    var timeZone = parseDate[ISO8601_TIMEZONE]; // add milliseconds if missing, to standardize output\n\n    if (!milliseconds) {\n      dateTime += '.000';\n    }\n    if (parseDate[ISO8601_Z_FMT]) {\n      return isoString;\n    }\n    if (parseDate[ISO8601_SHORT_FMT]) {\n      return \"\".concat(dateTime + timeZone, \":00\");\n    }\n    if (parseDate[ISO8601_MEDIUM_FMT]) {\n      return \"\".concat(dateTime + timeZone.substr(0, 3), \":\").concat(timeZone.substr(3));\n    }\n    if (parseDate[ISO8601_LONG_FMT]) {\n      return isoString;\n    }\n  }\n  return isoString;\n}\n/**\n * Will convert\n *      2018-06-13T00:00:00.000Z\n * to\n *      2018-06-13T07:00:00.000Z\n *\n * This is the opposite of convertDateToUnixMidnightTime\n *\n * @param {string} isoString - ISO string in UTC time zone\n */\n\nfunction convertISOStringToUTCDate(isoString) {\n  // get date in UTC midnight time\n  var utcDate = new Date(convertISOStringtoRFC3339String(isoString));\n  var utcTime = utcDate.getTime(); // get browser's timezone\n\n  var timezoneOffsetInMins = utcDate.getTimezoneOffset();\n  var timezoneOffsetInMs = timezoneOffsetInMins * MILLISECONDS_PER_MINUTE; // return date in utc timezone\n\n  var localizedUnixTimeInMs = utcTime + timezoneOffsetInMs;\n  return new Date(localizedUnixTimeInMs);\n}\nexport { convertToDate, convertToMs, convertDateToUnixMidnightTime, convertISOStringToUTCDate, convertISOStringtoRFC3339String, isToday, isTomorrow, isValidDate, isYesterday, isCurrentMonth, isCurrentYear, formatTime, addTime };","map":{"version":3,"sources":["../../src/utils/datetime.js"],"names":["isNaN","MILLISECONDS_PER_SECOND","MILLISECONDS_PER_DAY","MILLISECONDS_PER_MINUTE","RE_ISO8601_DATE","ISO8601_DATETIME","ISO8601_MILLISECONDS","ISO8601_TIMEZONE","ISO8601_Z_FMT","ISO8601_SHORT_FMT","ISO8601_MEDIUM_FMT","ISO8601_LONG_FMT","convertToDate","dateValue","Date","convertToMs","seconds","isToday","toDateString","isYesterday","getTime","isTomorrow","isCurrentMonth","getMonth","isCurrentYear","getFullYear","formatTime","h","Math","floor","m","s","hour","toString","sec","min","addTime","timeToAdd","convertDateToUnixMidnightTime","date","utcUnixTimeInMs","timezoneOffsetInMins","getTimezoneOffset","timezoneOffsetInMs","unixDayMidnightTime","isValidDate","convertISOStringtoRFC3339String","isoString","test","parseDate","split","dateTime","milliseconds","timeZone","substr","convertISOStringToUTCDate","utcDate","utcTime","localizedUnixTimeInMs"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Date and time utilities\n * @author Box\n */\nimport isNaN from 'lodash/isNaN';\n\nconst MILLISECONDS_PER_SECOND = 1000;\n// 24 hours * 60 minutes * 60 seconds * 1000 milliseconds\nconst MILLISECONDS_PER_DAY = 24 * 60 * 60 * MILLISECONDS_PER_SECOND;\n// 60 sec * 1000\nconst MILLISECONDS_PER_MINUTE = 60 * MILLISECONDS_PER_SECOND;\n\n/**\n * RegExp matcher for acceptable ISO 8601 date formats w/ timezone (see below)\n * Capture groups structured as follows:\n * 1) the date/time portion (2018-06-13T00:00:00.000)\n * 2) the milliseconds (if matched)\n * 3) the timezone portion (e.g., Z, +03, -0400, +05:00)\n * 4) the Z format for timezone (if matched)\n * 5) the short format for timezone (if matched)\n * 6) the colon-less format for timezone (if matched)\n * 7) the colon long format for timezone (if matched)\n */\nconst RE_ISO8601_DATE = /^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{1,3})?)?((Z$)|(?:[+-](?:([0-2]\\d$)|([0-2]\\d(?:00|30)$)|([0-2]\\d:(?:00|30)$))))$/;\nconst ISO8601_DATETIME: 1 = 1;\nconst ISO8601_MILLISECONDS: 2 = 2;\nconst ISO8601_TIMEZONE: 3 = 3;\nconst ISO8601_Z_FMT: 4 = 4;\nconst ISO8601_SHORT_FMT: 5 = 5;\nconst ISO8601_MEDIUM_FMT: 6 = 6;\nconst ISO8601_LONG_FMT: 7 = 7;\n\n/**\n * Helper to normalize a date value to a date object\n * @param dateValue - Date number, string, or object\n * @returns {date} the normalized date object\n */\nfunction convertToDate(dateValue: number | string | Date): Date {\n    return dateValue instanceof Date ? dateValue : new Date(dateValue);\n}\n\n/**\n * Converts an integer value in seconds to milliseconds.\n * @param {number} seconds - The value in seconds\n * @returns {number} the value in milliseconds\n */\nfunction convertToMs(seconds: number): number {\n    return seconds * MILLISECONDS_PER_SECOND;\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is today.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is today\n */\nfunction isToday(dateValue: number | string | Date): boolean {\n    return new Date().toDateString() === convertToDate(dateValue).toDateString();\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is yesterday.\n * @param {number|string|Date} dateValue - Date object or integer or representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is yesterday\n */\nfunction isYesterday(dateValue: number | string | Date): boolean {\n    return isToday(convertToDate(dateValue).getTime() + MILLISECONDS_PER_DAY);\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is tomorrow.\n * @param {number|string|Date} dateValue - Date object or integer or representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is tomorrow\n */\nfunction isTomorrow(dateValue: number | string | Date): boolean {\n    return isToday(convertToDate(dateValue).getTime() - MILLISECONDS_PER_DAY);\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is in the current month.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is in the current month\n */\nfunction isCurrentMonth(dateValue: number | string | Date): boolean {\n    return new Date().getMonth() === convertToDate(dateValue).getMonth();\n}\n\n/**\n * Checks whether the given date value (in unix milliseconds) is in the current year.\n * @param {number|string|Date} dateValue - Date object or integer representing the number of milliseconds since 1/1/1970 UTC\n * @returns {boolean} whether the given value is in the current year\n */\nfunction isCurrentYear(dateValue: number | string | Date): boolean {\n    return new Date().getFullYear() === convertToDate(dateValue).getFullYear();\n}\n\n/**\n * Formats a number of seconds as a time string\n *\n * @param {number} seconds - seconds\n * @return {string} a string formatted like 3:57:35\n */\nfunction formatTime(seconds: number): string {\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = Math.floor((seconds % 3600) % 60);\n    const hour = h > 0 ? `${h.toString()}:` : '';\n    const sec = s < 10 ? `0${s.toString()}` : s.toString();\n    let min = m.toString();\n    if (h > 0 && m < 10) {\n        min = `0${min}`;\n    }\n    return `${hour}${min}:${sec}`;\n}\n\n/**\n * Adds time to a given dateValue\n *\n * @param {number|Date} dateValue - date or integer value to add time to\n * @param {number} timeToAdd - amount of time to add in ms\n * @return {number|Date} the modified date or integer\n */\nfunction addTime(dateValue: number | Date, timeToAdd: number): number | Date {\n    if (dateValue instanceof Date) {\n        return new Date(dateValue.getTime() + timeToAdd);\n    }\n\n    return dateValue + timeToAdd;\n}\n\n/**\n * Will convert\n *      2018-06-13T07:00:00.000Z\n * to\n *      2018-06-13T00:00:00.000Z\n *\n * This is the opposite of convertISOStringToUTCDate\n *\n * @param {Date} date\n * @return {number}\n */\nfunction convertDateToUnixMidnightTime(date: Date) {\n    // date is localized to 00:00:00 at system/browser timezone\n    const utcUnixTimeInMs = date.getTime();\n\n    // timezone an integer offset; minutes behind GMT\n    // we use the browser timezone offset instead of the user's,\n    // because the datepicker uses the browser to get the \"midnight\"\n    // time in the user's timezone with getTime()\n    const timezoneOffsetInMins = date.getTimezoneOffset();\n    const timezoneOffsetInMs = timezoneOffsetInMins * MILLISECONDS_PER_MINUTE;\n\n    // we need the unix/epoch time for midnight on the date selected\n    const unixDayMidnightTime = utcUnixTimeInMs - timezoneOffsetInMs;\n    return unixDayMidnightTime;\n}\n\n/**\n * Will check to see if a date object is not valid, according to the browser\n * JS engine.\n *\n * @param {Date} date\n * @return {boolean} whether the date value passes validation\n */\nfunction isValidDate(date: Date): boolean {\n    return !isNaN(date.getTime());\n}\n\n/**\n * Will convert ISO8601-compatible dates (with zone designators)\n *      2018-06-13T00:00:00.000-0500\n *      or\n *      2018-06-13T00:00:00.000-05\n *\n * to\n *      2018-06-13T00:00:00.000-05:00\n *\n * Equivalent formats between the two (e.g., uzing 'Z') will remain unchanged.\n * If the date format cannot be converted, it will pass along the existing value\n * @param {string} isoString\n * @return {string} converted date format, if applicable\n */\nfunction convertISOStringtoRFC3339String(isoString: string): string {\n    // test that the date format inbound is ISO8601-compatible\n    if (RE_ISO8601_DATE.test(isoString)) {\n        // if it is, parse out the timezone part if it's in a longer format\n        // use the capture groups instead of the split result for the datetime and the time zone\n        const parseDate = isoString.split(RE_ISO8601_DATE);\n        let dateTime = parseDate[ISO8601_DATETIME];\n        const milliseconds = parseDate[ISO8601_MILLISECONDS];\n        const timeZone = parseDate[ISO8601_TIMEZONE];\n\n        // add milliseconds if missing, to standardize output\n        if (!milliseconds) {\n            dateTime += '.000';\n        }\n\n        if (parseDate[ISO8601_Z_FMT]) {\n            return isoString;\n        }\n\n        if (parseDate[ISO8601_SHORT_FMT]) {\n            return `${dateTime + timeZone}:00`;\n        }\n\n        if (parseDate[ISO8601_MEDIUM_FMT]) {\n            return `${dateTime + timeZone.substr(0, 3)}:${timeZone.substr(3)}`;\n        }\n\n        if (parseDate[ISO8601_LONG_FMT]) {\n            return isoString;\n        }\n    }\n    return isoString;\n}\n\n/**\n * Will convert\n *      2018-06-13T00:00:00.000Z\n * to\n *      2018-06-13T07:00:00.000Z\n *\n * This is the opposite of convertDateToUnixMidnightTime\n *\n * @param {string} isoString - ISO string in UTC time zone\n */\nfunction convertISOStringToUTCDate(isoString: string): Date {\n    // get date in UTC midnight time\n    const utcDate = new Date(convertISOStringtoRFC3339String(isoString));\n    const utcTime = utcDate.getTime();\n\n    // get browser's timezone\n    const timezoneOffsetInMins = utcDate.getTimezoneOffset();\n    const timezoneOffsetInMs = timezoneOffsetInMins * MILLISECONDS_PER_MINUTE;\n\n    // return date in utc timezone\n    const localizedUnixTimeInMs = utcTime + timezoneOffsetInMs;\n    return new Date(localizedUnixTimeInMs);\n}\n\nexport {\n    convertToDate,\n    convertToMs,\n    convertDateToUnixMidnightTime,\n    convertISOStringToUTCDate,\n    convertISOStringtoRFC3339String,\n    isToday,\n    isTomorrow,\n    isValidDate,\n    isYesterday,\n    isCurrentMonth,\n    isCurrentYear,\n    formatTime,\n    addTime,\n};\n"]},"metadata":{},"sourceType":"module"}