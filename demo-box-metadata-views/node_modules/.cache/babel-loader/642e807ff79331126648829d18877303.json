{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport omit from 'lodash/omit';\nimport { injectIntl } from 'react-intl';\nimport BaseSelectField from './BaseSelectField';\nimport CLEAR from './constants';\nimport messages from './messages';\nvar SingleSelectField = /*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(SingleSelectField, _React$Component);\n  function SingleSelectField() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, SingleSelectField);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SingleSelectField)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"handleChange\", function (selectedOptions) {\n      var _this$props = _this.props,\n        onChange = _this$props.onChange,\n        fieldType = _this$props.fieldType; // There should only ever be 1 selected item\n\n      if (onChange && selectedOptions.length === 1) {\n        onChange(selectedOptions[0], fieldType);\n      } else if (selectedOptions.length === 0) {\n        onChange({\n          value: null\n        });\n      }\n    });\n    return _this;\n  }\n  _createClass(SingleSelectField, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n        intl = _this$props2.intl,\n        isDisabled = _this$props2.isDisabled,\n        selectedValue = _this$props2.selectedValue,\n        placeholder = _this$props2.placeholder,\n        shouldShowClearOption = _this$props2.shouldShowClearOption,\n        options = _this$props2.options,\n        rest = _objectWithoutProperties(_this$props2, [\"intl\", \"isDisabled\", \"selectedValue\", \"placeholder\", \"shouldShowClearOption\", \"options\"]); // @TODO: Invariant testing\n      // 1) selectedValue is required to be contained in the options\n      // 2) # of options should be non-zero\n      // Make sure to omit passed props that could be interpreted incorrectly by the base component\n\n      var selectFieldProps = omit(rest, ['defaultValue', 'multiple', 'onChange']); // If selectedValue is passed in, map it to the multi selected equivalent\n\n      var isFieldSelected = selectedValue !== null;\n      selectFieldProps.selectedValues = !isFieldSelected ? [] : [selectedValue];\n      var optionsWithClearOption = shouldShowClearOption ? [{\n        value: CLEAR,\n        displayText: intl.formatMessage(messages.clearAll)\n      }].concat(_toConsumableArray(options)) : options;\n      return React.createElement(BaseSelectField, _extends({\n        className: !isFieldSelected && placeholder ? 'placeholder' : '',\n        isDisabled: isDisabled,\n        onChange: this.handleChange,\n        placeholder: placeholder,\n        options: optionsWithClearOption,\n        shouldShowClearOption: shouldShowClearOption\n      }, selectFieldProps));\n    }\n  }]);\n  return SingleSelectField;\n}(React.Component);\nexport { SingleSelectField as SingleSelectFieldBase };\nexport default injectIntl(SingleSelectField);","map":{"version":3,"sources":["../../../src/components/select-field/SingleSelectField.js"],"names":["React","omit","injectIntl","BaseSelectField","CLEAR","messages","SingleSelectField","Component","selectedOptions","onChange","fieldType","props","length","value","intl","isDisabled","selectedValue","placeholder","shouldShowClearOption","options","rest","selectFieldProps","isFieldSelected","selectedValues","optionsWithClearOption","displayText","formatMessage","clearAll","handleChange","SingleSelectFieldBase"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAOC,IAAP,MAAiB,aAAjB;AACA,SAASC,UAAT,QAA2B,YAA3B;AAEA,OAAOC,eAAP,MAA4B,mBAA5B;AAEA,OAAOC,KAAP,MAAkB,aAAlB;AACA,OAAOC,QAAP,MAAqB,YAArB;IAuBMC,iB;;;;;;;;;;;mEACa,UAACE,eAAD,EAA8C;MAAA,IAAA,WAAA,GACzB,KAAA,CAAKG,KADoB;QACjDF,QADiD,GAAA,WAAA,CACjDA,QADiD;QACvCC,SADuC,GAAA,WAAA,CACvCA,SADuC,CAAA,CAGzD;;MACA,IAAID,QAAQ,IAAID,eAAe,CAACI,MAAhBJ,KAA2B,CAA3C,EAA8C;QAC1CC,QAAQ,CAACD,eAAe,CAAC,CAAD,CAAhB,EAAqBE,SAArB,CAARD;MACH,CAFD,MAEO,IAAID,eAAe,CAACI,MAAhBJ,KAA2B,CAA/B,EAAkC;QACrCC,QAAQ,CAAC;UAAEI,KAAK,EAAE;QAAT,CAAD,CAARJ;MACH;IACJ,C;;;;;6BAEQ;MAAA,IAAA,YAAA,GAC6F,IAAA,CAAKE,KADlG;QACGG,IADH,GAAA,YAAA,CACGA,IADH;QACSC,UADT,GAAA,YAAA,CACSA,UADT;QACqBC,aADrB,GAAA,YAAA,CACqBA,aADrB;QACoCC,WADpC,GAAA,YAAA,CACoCA,WADpC;QACiDC,qBADjD,GAAA,YAAA,CACiDA,qBADjD;QACwEC,OADxE,GAAA,YAAA,CACwEA,OADxE;QACoFC,IADpF,GAAA,wBAAA,CAAA,YAAA,EAAA,CAAA,MAAA,EAAA,YAAA,EAAA,eAAA,EAAA,aAAA,EAAA,uBAAA,EAAA,SAAA,CAAA,CAAA,CAAA,CAGL;MACA;MACA;MAEA;;MACA,IAAMC,gBAAgB,GAAGpB,IAAI,CAACmB,IAAD,EAAO,CAAC,cAAD,EAAiB,UAAjB,EAA6B,UAA7B,CAAP,CAA7B,CARK,CAUL;;MACA,IAAME,eAAe,GAAGN,aAAa,KAAK,IAA1C;MACAK,gBAAgB,CAACE,cAAjBF,GAAkC,CAACC,eAAD,GAAmB,EAAnB,GAAwB,CAACN,aAAD,CAA1DK;MAEA,IAAMG,sBAAsB,GAAGN,qBAAqB,GAAA,CAE1C;QACIL,KAAK,EAAET,KADX;QAEIqB,WAAW,EAAEX,IAAI,CAACY,aAALZ,CAAmBT,QAAQ,CAACsB,QAA5Bb;MAFjB,CAF0C,CAAA,CAAA,MAAA,CAAA,kBAAA,CAMvCK,OANuC,CAAA,CAAA,GAQ9CA,OARN;MAUA,OACI,KAAA,CAAA,aAAA,CAAC,eAAD,EAAA,QAAA,CAAA;QACI,SAAS,EAAE,CAACG,eAAD,IAAoBL,WAApB,GAAkC,aAAlC,GAAkD,EADjE;QAEI,UAAU,EAAEF,UAFhB;QAGI,QAAQ,EAAE,IAAA,CAAKa,YAHnB;QAII,WAAW,EAAEX,WAJjB;QAKI,OAAO,EAAEO,sBALb;QAMI,qBAAqB,EAAEN;MAN3B,CAAA,EAOQG,gBAPR,CAAA,CADJ;IAWH;;;EA/C2BrB,KAAK,CAACO,S;AAkDtC,SAASD,iBAAiB,IAAIuB,qBAA9B;AACA,eAAe3B,UAAU,CAACI,iBAAD,CAAzB","sourcesContent":["// @flow\nimport * as React from 'react';\nimport omit from 'lodash/omit';\nimport { injectIntl } from 'react-intl';\n\nimport BaseSelectField from './BaseSelectField';\nimport type { SelectOptionValueProp, SelectOptionProp } from './props';\nimport CLEAR from './constants';\nimport messages from './messages';\n\ntype Props = {\n    /** The type of the field */\n    fieldType?: string,\n    /* Intl object */\n    intl: Object,\n    /** The select field is disabled if true */\n    isDisabled?: boolean,\n    /** The select field overlay (dropdown) will have a scrollbar and max-height if true * */\n    isScrollable?: boolean,\n    /** The currently selected option value */\n    onChange: Function,\n    /** List of options (displayText, value) */\n    options: Array<SelectOptionProp>,\n    /** The placeholder text for the field  */\n    placeholder?: string | React.Node,\n    /** Function will be called with the selected option after user selects a new option */\n    selectedValue?: SelectOptionValueProp,\n    /** Will show Clear All option */\n    shouldShowClearOption?: boolean,\n};\n\nclass SingleSelectField extends React.Component<Props> {\n    handleChange = (selectedOptions: Array<SelectOptionProp>) => {\n        const { onChange, fieldType } = this.props;\n\n        // There should only ever be 1 selected item\n        if (onChange && selectedOptions.length === 1) {\n            onChange(selectedOptions[0], fieldType);\n        } else if (selectedOptions.length === 0) {\n            onChange({ value: null });\n        }\n    };\n\n    render() {\n        const { intl, isDisabled, selectedValue, placeholder, shouldShowClearOption, options, ...rest } = this.props;\n\n        // @TODO: Invariant testing\n        // 1) selectedValue is required to be contained in the options\n        // 2) # of options should be non-zero\n\n        // Make sure to omit passed props that could be interpreted incorrectly by the base component\n        const selectFieldProps = omit(rest, ['defaultValue', 'multiple', 'onChange']);\n\n        // If selectedValue is passed in, map it to the multi selected equivalent\n        const isFieldSelected = selectedValue !== null;\n        selectFieldProps.selectedValues = !isFieldSelected ? [] : [selectedValue];\n\n        const optionsWithClearOption = shouldShowClearOption\n            ? [\n                  {\n                      value: CLEAR,\n                      displayText: intl.formatMessage(messages.clearAll),\n                  },\n                  ...options,\n              ]\n            : options;\n\n        return (\n            <BaseSelectField\n                className={!isFieldSelected && placeholder ? 'placeholder' : ''}\n                isDisabled={isDisabled}\n                onChange={this.handleChange}\n                placeholder={placeholder}\n                options={optionsWithClearOption}\n                shouldShowClearOption={shouldShowClearOption}\n                {...selectFieldProps}\n            />\n        );\n    }\n}\n\nexport { SingleSelectField as SingleSelectFieldBase };\nexport default injectIntl(SingleSelectField);\n"]},"metadata":{},"sourceType":"module"}