{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport { CompositeDecorator, EditorState } from 'draft-js';\nimport noop from 'lodash/noop';\nimport DraftJSMentionSelectorCore from './DraftJSMentionSelectorCore';\nimport DraftMentionItem from './DraftMentionItem';\nimport FormInput from '../form/FormInput';\nimport * as messages from '../input-messages';\n\n/**\n * Scans a Draft ContentBlock for entity ranges, so they can be annotated\n * @see docs at {@link https://draftjs.org/docs/advanced-topics-decorators.html#compositedecorator}\n * @param {ContentBlock} contentBlock\n * @param {function} callback\n * @param {ContentState} contentState\n */\nvar mentionStrategy = function mentionStrategy(contentBlock, callback, contentState) {\n  contentBlock.findEntityRanges(function (character) {\n    var entityKey = character.getEntity();\n    var ret = entityKey !== null && contentState.getEntity(entityKey).getType() === 'MENTION';\n    return ret;\n  }, callback);\n};\nvar DraftJSMentionSelector = /*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(DraftJSMentionSelector, _React$Component);\n  function DraftJSMentionSelector(props) {\n    var _this;\n    _classCallCheck(this, DraftJSMentionSelector);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DraftJSMentionSelector).call(this, props));\n    _defineProperty(_assertThisInitialized(_this), \"handleBlur\", function (event) {\n      if (_this.props.validateOnBlur && _this.containerEl && event.relatedTarget instanceof Node && !_this.containerEl.contains(event.relatedTarget)) {\n        _this.checkValidity();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleFocus\", function (event) {\n      var onFocus = _this.props.onFocus;\n      if (onFocus) {\n        onFocus(event);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleChange\", function (nextEditorState) {\n      var internalEditorState = _this.state.internalEditorState;\n      var onChange = _this.props.onChange;\n      onChange(nextEditorState);\n      if (internalEditorState) {\n        _this.setState({\n          internalEditorState: nextEditorState\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleValidityStateUpdateHandler\", function () {\n      var isTouched = _this.state.isTouched;\n      if (!isTouched) {\n        return;\n      }\n      var error = _this.getErrorFromValidityState();\n      _this.setState({\n        error: error\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"checkValidity\", function () {\n      _this.handleValidityStateUpdateHandler();\n    });\n    var mentionDecorator = new CompositeDecorator([{\n      strategy: mentionStrategy,\n      component: DraftMentionItem\n    }]); // @NOTE (smotraghi 2017-05-30):\n    // This component might be either own its EditorState (in which case it lives in `this.state.internalEditorState`)\n    // or be a controlled component whose EditorState is passed in via the `editorState` prop.\n    // If `props.editorState` is set, `internalEditorState` is `null`,\n    // otherwise we initialize it here\n\n    _this.state = {\n      contacts: [],\n      isTouched: false,\n      internalEditorState: props.editorState ? null : EditorState.createEmpty(mentionDecorator),\n      error: null\n    };\n    return _this;\n  }\n  _createClass(DraftJSMentionSelector, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var prevInternalEditorState = prevState.internalEditorState;\n      var internalEditorState = this.state.internalEditorState;\n      var prevEditorStateFromProps = prevProps.editorState;\n      var editorState = this.props.editorState; // Determine whether we're working with the internal editor state or\n      // external editor state passed in from props\n\n      var prevEditorState = prevInternalEditorState || prevEditorStateFromProps;\n      var currentEditorState = internalEditorState || editorState; // Only handle isTouched state transitions and check validity if the\n      // editorState references are different. This is to avoid getting stuck\n      // in an infinite loop of checking validity because checkValidity always\n      // calls setState({ error })\n\n      if (prevEditorState && currentEditorState && prevEditorState !== currentEditorState) {\n        var newState = this.getDerivedStateFromEditorState(currentEditorState, prevEditorState);\n        if (newState) {\n          this.setState(newState, this.checkValidityIfAllowed);\n        } else {\n          this.checkValidityIfAllowed();\n        }\n      }\n    }\n  }, {\n    key: \"getDerivedStateFromEditorState\",\n    value: function getDerivedStateFromEditorState(currentEditorState, previousEditorState) {\n      var isPreviousEditorStateEmpty = this.isEditorStateEmpty(previousEditorState);\n      var isCurrentEditorStateEmpty = this.isEditorStateEmpty(currentEditorState);\n      var isNewEditorState = isCurrentEditorStateEmpty && !isPreviousEditorStateEmpty;\n      var isEditorStateDirty = isPreviousEditorStateEmpty && !isCurrentEditorStateEmpty;\n      var newState = null; // Detect case where controlled EditorState is created anew and empty.\n      // If next editorState is empty and the current editorState is not empty\n      // that means it is a new empty state and this component should not be marked dirty\n\n      if (isNewEditorState) {\n        newState = {\n          isTouched: false,\n          error: null\n        };\n      } else if (isEditorStateDirty) {\n        // Detect case where controlled EditorState has been made dirty\n        // If the current editorState is empty and the next editorState is not\n        // empty then this is the first interaction so mark this component dirty\n        newState = {\n          isTouched: true\n        };\n      }\n      return newState;\n    }\n  }, {\n    key: \"checkValidityIfAllowed\",\n    value: function checkValidityIfAllowed() {\n      var validateOnBlur = this.props.validateOnBlur;\n      if (!validateOnBlur) {\n        this.checkValidity();\n      }\n    }\n  }, {\n    key: \"isEditorStateEmpty\",\n    value: function isEditorStateEmpty(editorState) {\n      var text = editorState.getCurrentContent().getPlainText().trim();\n      var lastChangeType = editorState.getLastChangeType();\n      return text.length === 0 && lastChangeType === null;\n    }\n    /**\n     * @returns {string}\n     */\n  }, {\n    key: \"getErrorFromValidityState\",\n    value: function getErrorFromValidityState() {\n      var _this$props = this.props,\n        externalEditorState = _this$props.editorState,\n        isRequired = _this$props.isRequired,\n        maxLength = _this$props.maxLength,\n        minLength = _this$props.minLength;\n      var internalEditorState = this.state.internalEditorState; // manually check for content length if isRequired is true\n\n      var editorState = internalEditorState || externalEditorState;\n      var _editorState$getCurre = editorState.getCurrentContent().getPlainText().trim(),\n        length = _editorState$getCurre.length;\n      if (isRequired && !length) {\n        return messages.valueMissing();\n      }\n      if (typeof minLength !== 'undefined' && length < minLength) {\n        return messages.tooShort(minLength);\n      }\n      if (typeof maxLength !== 'undefined' && length > maxLength) {\n        return messages.tooLong(maxLength);\n      }\n      return null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var _this$props2 = this.props,\n        _this$props2$classNam = _this$props2.className,\n        className = _this$props2$classNam === void 0 ? '' : _this$props2$classNam,\n        externalEditorState = _this$props2.editorState,\n        hideLabel = _this$props2.hideLabel,\n        isDisabled = _this$props2.isDisabled,\n        isRequired = _this$props2.isRequired,\n        label = _this$props2.label,\n        mentionTriggers = _this$props2.mentionTriggers,\n        name = _this$props2.name,\n        onMention = _this$props2.onMention,\n        placeholder = _this$props2.placeholder,\n        selectorRow = _this$props2.selectorRow,\n        startMentionMessage = _this$props2.startMentionMessage,\n        onReturn = _this$props2.onReturn;\n      var _this$state = this.state,\n        contacts = _this$state.contacts,\n        internalEditorState = _this$state.internalEditorState,\n        error = _this$state.error;\n      var handleBlur = this.handleBlur,\n        handleChange = this.handleChange,\n        handleFocus = this.handleFocus;\n      var editorState = internalEditorState || externalEditorState;\n      return React.createElement(\"div\", {\n        ref: function ref(containerEl) {\n          _this2.containerEl = containerEl;\n        },\n        className: className\n      }, React.createElement(FormInput, {\n        name: name,\n        onValidityStateUpdate: this.handleValidityStateUpdateHandler\n      }, React.createElement(DraftJSMentionSelectorCore, {\n        contacts: contacts,\n        editorState: editorState,\n        error: error,\n        hideLabel: hideLabel,\n        isDisabled: isDisabled,\n        isRequired: isRequired,\n        label: label,\n        mentionTriggers: mentionTriggers,\n        onBlur: handleBlur,\n        onChange: handleChange,\n        onFocus: handleFocus,\n        onMention: onMention,\n        onReturn: onReturn,\n        placeholder: placeholder,\n        selectorRow: selectorRow,\n        startMentionMessage: startMentionMessage\n      })));\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps) {\n      var contacts = nextProps.contacts;\n      return contacts ? {\n        contacts: contacts\n      } : null;\n    }\n  }]);\n  return DraftJSMentionSelector;\n}(React.Component);\n_defineProperty(DraftJSMentionSelector, \"defaultProps\", {\n  isRequired: false,\n  onChange: noop,\n  validateOnBlur: true\n});\nexport default DraftJSMentionSelector;","map":{"version":3,"sources":["../../../../src/components/form-elements/draft-js-mention-selector/DraftJSMentionSelector.js"],"names":["React","CompositeDecorator","EditorState","noop","DraftJSMentionSelectorCore","DraftMentionItem","FormInput","messages","mentionStrategy","contentBlock","callback","contentState","findEntityRanges","entityKey","character","getEntity","ret","getType","DraftJSMentionSelector","Component","isRequired","onChange","validateOnBlur","props","mentionDecorator","strategy","component","state","contacts","isTouched","internalEditorState","editorState","createEmpty","error","nextProps","prevProps","prevState","prevInternalEditorState","prevEditorStateFromProps","prevEditorState","currentEditorState","newState","getDerivedStateFromEditorState","setState","checkValidityIfAllowed","previousEditorState","isPreviousEditorStateEmpty","isEditorStateEmpty","isCurrentEditorStateEmpty","isNewEditorState","isEditorStateDirty","checkValidity","text","getCurrentContent","getPlainText","trim","lastChangeType","getLastChangeType","length","externalEditorState","maxLength","minLength","valueMissing","tooShort","tooLong","event","containerEl","relatedTarget","Node","contains","onFocus","nextEditorState","getErrorFromValidityState","handleValidityStateUpdateHandler","className","hideLabel","isDisabled","label","mentionTriggers","name","onMention","placeholder","selectorRow","startMentionMessage","onReturn","handleBlur","handleChange","handleFocus"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport { CompositeDecorator, EditorState } from 'draft-js';\nimport noop from 'lodash/noop';\n\nimport DraftJSMentionSelectorCore from './DraftJSMentionSelectorCore';\nimport DraftMentionItem from './DraftMentionItem';\nimport FormInput from '../form/FormInput';\nimport * as messages from '../input-messages';\nimport type { SelectorItems } from '../../../common/types/core';\n\n/**\n * Scans a Draft ContentBlock for entity ranges, so they can be annotated\n * @see docs at {@link https://draftjs.org/docs/advanced-topics-decorators.html#compositedecorator}\n * @param {ContentBlock} contentBlock\n * @param {function} callback\n * @param {ContentState} contentState\n */\nconst mentionStrategy = (contentBlock, callback, contentState) => {\n    contentBlock.findEntityRanges(character => {\n        const entityKey = character.getEntity();\n\n        const ret = entityKey !== null && contentState.getEntity(entityKey).getType() === 'MENTION';\n        return ret;\n    }, callback);\n};\n\ntype Props = {\n    className?: string,\n    contacts: SelectorItems<>,\n    editorState?: EditorState,\n    hideLabel?: boolean,\n    isDisabled?: boolean,\n    isRequired?: boolean,\n    label: React.Node,\n    maxLength?: number,\n    mentionTriggers?: Array<string>,\n    minLength?: number,\n    name: string,\n    onChange: Function,\n    onFocus?: Function,\n    onMention?: Function,\n    onReturn?: Function,\n    placeholder?: string,\n    selectorRow?: React.Element<any>,\n    startMentionMessage?: React.Node,\n    validateOnBlur?: boolean,\n};\n\ntype State = {\n    contacts: SelectorItems<>,\n    error: ?Object,\n    internalEditorState: ?EditorState,\n    isTouched: boolean,\n};\n\nclass DraftJSMentionSelector extends React.Component<Props, State> {\n    static defaultProps = {\n        isRequired: false,\n        onChange: noop,\n        validateOnBlur: true,\n    };\n\n    constructor(props: Props) {\n        super(props);\n\n        const mentionDecorator = new CompositeDecorator([\n            {\n                strategy: mentionStrategy,\n                component: DraftMentionItem,\n            },\n        ]);\n\n        // @NOTE (smotraghi 2017-05-30):\n        // This component might be either own its EditorState (in which case it lives in `this.state.internalEditorState`)\n        // or be a controlled component whose EditorState is passed in via the `editorState` prop.\n        // If `props.editorState` is set, `internalEditorState` is `null`,\n        // otherwise we initialize it here\n        this.state = {\n            contacts: [],\n            isTouched: false,\n            internalEditorState: props.editorState ? null : EditorState.createEmpty(mentionDecorator),\n            error: null,\n        };\n    }\n\n    static getDerivedStateFromProps(nextProps: Props) {\n        const { contacts } = nextProps;\n        return contacts ? { contacts } : null;\n    }\n\n    componentDidUpdate(prevProps: Props, prevState: State) {\n        const { internalEditorState: prevInternalEditorState } = prevState;\n        const { internalEditorState } = this.state;\n\n        const { editorState: prevEditorStateFromProps } = prevProps;\n        const { editorState } = this.props;\n\n        // Determine whether we're working with the internal editor state or\n        // external editor state passed in from props\n        const prevEditorState = prevInternalEditorState || prevEditorStateFromProps;\n        const currentEditorState = internalEditorState || editorState;\n\n        // Only handle isTouched state transitions and check validity if the\n        // editorState references are different. This is to avoid getting stuck\n        // in an infinite loop of checking validity because checkValidity always\n        // calls setState({ error })\n        if (prevEditorState && currentEditorState && prevEditorState !== currentEditorState) {\n            const newState = this.getDerivedStateFromEditorState(currentEditorState, prevEditorState);\n            if (newState) {\n                this.setState(newState, this.checkValidityIfAllowed);\n            } else {\n                this.checkValidityIfAllowed();\n            }\n        }\n    }\n\n    getDerivedStateFromEditorState(currentEditorState: EditorState, previousEditorState: EditorState) {\n        const isPreviousEditorStateEmpty = this.isEditorStateEmpty(previousEditorState);\n        const isCurrentEditorStateEmpty = this.isEditorStateEmpty(currentEditorState);\n        const isNewEditorState = isCurrentEditorStateEmpty && !isPreviousEditorStateEmpty;\n        const isEditorStateDirty = isPreviousEditorStateEmpty && !isCurrentEditorStateEmpty;\n\n        let newState = null;\n        // Detect case where controlled EditorState is created anew and empty.\n        // If next editorState is empty and the current editorState is not empty\n        // that means it is a new empty state and this component should not be marked dirty\n        if (isNewEditorState) {\n            newState = { isTouched: false, error: null };\n        } else if (isEditorStateDirty) {\n            // Detect case where controlled EditorState has been made dirty\n            // If the current editorState is empty and the next editorState is not\n            // empty then this is the first interaction so mark this component dirty\n            newState = { isTouched: true };\n        }\n\n        return newState;\n    }\n\n    checkValidityIfAllowed() {\n        const { validateOnBlur }: Props = this.props;\n\n        if (!validateOnBlur) {\n            this.checkValidity();\n        }\n    }\n\n    isEditorStateEmpty(editorState: EditorState): boolean {\n        const text = editorState\n            .getCurrentContent()\n            .getPlainText()\n            .trim();\n        const lastChangeType = editorState.getLastChangeType();\n\n        return text.length === 0 && lastChangeType === null;\n    }\n\n    /**\n     * @returns {string}\n     */\n    getErrorFromValidityState() {\n        const { editorState: externalEditorState, isRequired, maxLength, minLength } = this.props;\n        const { internalEditorState } = this.state;\n\n        // manually check for content length if isRequired is true\n        const editorState: EditorState = internalEditorState || externalEditorState;\n        const { length } = editorState\n            .getCurrentContent()\n            .getPlainText()\n            .trim();\n\n        if (isRequired && !length) {\n            return messages.valueMissing();\n        }\n\n        if (typeof minLength !== 'undefined' && length < minLength) {\n            return messages.tooShort(minLength);\n        }\n\n        if (typeof maxLength !== 'undefined' && length > maxLength) {\n            return messages.tooLong(maxLength);\n        }\n\n        return null;\n    }\n\n    containerEl: ?HTMLDivElement;\n\n    /**\n     * Event handler called on blur. Triggers validation\n     * @param {SyntheticFocusEvent} event The event object\n     * @returns {void}\n     */\n    handleBlur = (event: SyntheticFocusEvent<>) => {\n        if (\n            this.props.validateOnBlur &&\n            this.containerEl &&\n            event.relatedTarget instanceof Node &&\n            !this.containerEl.contains(event.relatedTarget)\n        ) {\n            this.checkValidity();\n        }\n    };\n\n    handleFocus = (event: SyntheticEvent<>) => {\n        const { onFocus } = this.props;\n\n        if (onFocus) {\n            onFocus(event);\n        }\n    };\n\n    /**\n     * Updates editorState, rechecks validity\n     * @param {EditorState} nextEditorState The new editor state to set in the state\n     * @returns {void}\n     */\n    handleChange = (nextEditorState: EditorState) => {\n        const { internalEditorState }: State = this.state;\n        const { onChange }: Props = this.props;\n\n        onChange(nextEditorState);\n\n        if (internalEditorState) {\n            this.setState({ internalEditorState: nextEditorState });\n        }\n    };\n\n    handleValidityStateUpdateHandler = () => {\n        const { isTouched } = this.state;\n\n        if (!isTouched) {\n            return;\n        }\n\n        const error = this.getErrorFromValidityState();\n\n        this.setState({ error });\n    };\n\n    checkValidity = () => {\n        this.handleValidityStateUpdateHandler();\n    };\n\n    render() {\n        const {\n            className = '',\n            editorState: externalEditorState,\n            hideLabel,\n            isDisabled,\n            isRequired,\n            label,\n            mentionTriggers,\n            name,\n            onMention,\n            placeholder,\n            selectorRow,\n            startMentionMessage,\n            onReturn,\n        } = this.props;\n        const { contacts, internalEditorState, error } = this.state;\n        const { handleBlur, handleChange, handleFocus } = this;\n        const editorState: EditorState = internalEditorState || externalEditorState;\n\n        return (\n            <div\n                ref={containerEl => {\n                    this.containerEl = containerEl;\n                }}\n                className={className}\n            >\n                <FormInput name={name} onValidityStateUpdate={this.handleValidityStateUpdateHandler}>\n                    <DraftJSMentionSelectorCore\n                        contacts={contacts}\n                        editorState={editorState}\n                        error={error}\n                        hideLabel={hideLabel}\n                        isDisabled={isDisabled}\n                        isRequired={isRequired}\n                        label={label}\n                        mentionTriggers={mentionTriggers}\n                        onBlur={handleBlur}\n                        onChange={handleChange}\n                        onFocus={handleFocus}\n                        onMention={onMention}\n                        onReturn={onReturn}\n                        placeholder={placeholder}\n                        selectorRow={selectorRow}\n                        startMentionMessage={startMentionMessage}\n                    />\n                </FormInput>\n            </div>\n        );\n    }\n}\n\nexport default DraftJSMentionSelector;\n"]},"metadata":{},"sourceType":"module"}