{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Helper for the box item API\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport setProp from 'lodash/set';\nimport { getBadItemError, getBadPermissionsError } from '../utils/error';\nimport { fillMissingProperties } from '../utils/fields';\nimport Base from './Base';\nimport { ACCESS_NONE, CACHE_PREFIX_SEARCH, CACHE_PREFIX_FOLDER, TYPE_FOLDER, ERROR_CODE_DELETE_ITEM, ERROR_CODE_RENAME_ITEM, ERROR_CODE_SHARE_ITEM } from '../constants';\nvar Item = /*#__PURE__*/\nfunction (_Base) {\n  _inherits(Item, _Base);\n  function Item() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, Item);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Item)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"deleteSuccessHandler\", function () {\n      if (_this.isDestroyed()) {\n        return;\n      } // When fetching the parent folder from the cache\n      // we have no guarantees that it will be there since\n      // search results happen across folders and we only\n      // add those folders to cache that have been navigated to.\n\n      var parentKey = _this.getParentCacheKey(_this.parentId);\n      var folder = _this.getCache().get(parentKey);\n      if (!folder) {\n        _this.postDeleteCleanup();\n        return;\n      } // Same logic as above but in this case we may have the parent\n      // folders meta data in cache but not its contents.\n\n      var item_collection = folder.item_collection;\n      if (!item_collection) {\n        _this.postDeleteCleanup();\n        return;\n      }\n      var entries = item_collection.entries,\n        total_count = item_collection.total_count;\n      if (!Array.isArray(entries) || typeof total_count !== 'number') {\n        throw getBadItemError();\n      }\n      var childKey = _this.getCacheKey(_this.id);\n      var oldCount = entries.length;\n      var newEntries = entries.filter(function (entry) {\n        return entry !== childKey;\n      });\n      var newCount = newEntries.length;\n      var updatedObject = _this.merge(parentKey, 'item_collection', _extends(item_collection, {\n        entries: newEntries,\n        total_count: total_count - (oldCount - newCount)\n      }));\n      _this.successCallback(updatedObject);\n      _this.postDeleteCleanup();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"renameSuccessHandler\", function (_ref) {\n      var data = _ref.data;\n      if (!_this.isDestroyed()) {\n        // Get rid of all searches\n        _this.getCache().unsetAll(CACHE_PREFIX_SEARCH);\n        var updatedObject = _this.merge(_this.getCacheKey(_this.id), 'name', data.name);\n        _this.successCallback(updatedObject);\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"shareSuccessHandler\", function (data, fields) {\n      if (!_this.isDestroyed()) {\n        // Add fields that were requested but not returned\n        var dataWithMissingFields = fields ? fillMissingProperties(data, fields) : data;\n        var cache = _this.getCache();\n        var key = _this.getCacheKey(_this.id);\n        if (cache.has(key)) {\n          cache.merge(key, dataWithMissingFields);\n        } else {\n          cache.set(key, dataWithMissingFields);\n        }\n        _this.successCallback(cache.get(key));\n      }\n    });\n    return _this;\n  }\n  _createClass(Item, [{\n    key: \"getParentCacheKey\",\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {Function}\n     */\n\n    /**\n     * @property {Function}\n     */\n\n    /**\n     * Creates a key for the item's parent\n     * This is always a folder\n     *\n     * @param {string} Id - folder id\n     * @return {string} Key\n     */\n    value: function getParentCacheKey(id) {\n      return \"\".concat(CACHE_PREFIX_FOLDER).concat(id);\n    }\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} Id - Folder id\n     * @return {string} Key\n     */\n  }, {\n    key: \"getCacheKey\",\n    value: function getCacheKey(id) {\n      return \"getCacheKey(\".concat(id, \") should be overriden\");\n    }\n    /**\n     * API URL for items\n     *\n     * @param {string} id - Item id\n     * @protected\n     * @return {string} Base url for files\n     */\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(id) {\n      return \"getUrl(\".concat(id, \") should be overriden\");\n    }\n    /**\n     * Merges new data with old data and returns new data\n     *\n     * @param {String} cacheKey - The cache key of item to merge\n     * @param {String} key - The attribute to merge\n     * @param {Object} value - The value to merge\n     * @return {BoxItem} The newly updated object from the cache\n     */\n  }, {\n    key: \"merge\",\n    value: function merge(cacheKey, key, value) {\n      var cache = this.getCache();\n      cache.merge(cacheKey, setProp({}, key, value));\n      return cache.get(cacheKey);\n    }\n    /**\n     * Steps to do after deletion\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"postDeleteCleanup\",\n    value: function postDeleteCleanup() {\n      if (this.isDestroyed()) {\n        return;\n      } // Get rid of all searches\n\n      this.getCache().unsetAll(CACHE_PREFIX_SEARCH);\n      this.successCallback();\n    }\n    /**\n     * Handles response for deletion\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"deleteItem\",\n    /**\n     * API to delete an Item\n     *\n     * @param {Object} item - Item to delete\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    value: function deleteItem(item, successCallback) {\n      var _this2 = this;\n      var errorCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n      if (this.isDestroyed()) {\n        return Promise.reject();\n      }\n      this.errorCode = ERROR_CODE_DELETE_ITEM;\n      var id = item.id,\n        permissions = item.permissions,\n        parent = item.parent,\n        type = item.type;\n      if (!id || !permissions || !parent || !type) {\n        errorCallback(getBadItemError(), this.errorCode);\n        return Promise.reject();\n      }\n      var parentId = parent.id;\n      var can_delete = permissions.can_delete;\n      if (!can_delete || !parentId) {\n        errorCallback(getBadPermissionsError(), this.errorCode);\n        return Promise.reject();\n      }\n      this.id = id;\n      this.parentId = parentId;\n      this.successCallback = successCallback;\n      this.errorCallback = errorCallback;\n      var url = \"\".concat(this.getUrl(id)).concat(type === TYPE_FOLDER ? '?recursive=true' : '');\n      return this.xhr.delete({\n        url: url\n      }).then(this.deleteSuccessHandler).catch(function (e) {\n        _this2.errorHandler(e);\n      });\n    }\n    /**\n     * Handles response for rename\n     *\n     * @param {BoxItem} data - The updated item\n     * @return {void}\n     */\n  }, {\n    key: \"rename\",\n    /**\n     * API to rename an Item\n     *\n     * @param {Object} item - Item to rename\n     * @param {string} name - Item new name\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    value: function rename(item, name, successCallback) {\n      var _this3 = this;\n      var errorCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n      if (this.isDestroyed()) {\n        return Promise.reject();\n      }\n      this.errorCode = ERROR_CODE_RENAME_ITEM;\n      var id = item.id,\n        permissions = item.permissions;\n      if (!id || !permissions) {\n        errorCallback(getBadItemError(), this.errorCode);\n        return Promise.reject();\n      }\n      var can_rename = permissions.can_rename;\n      if (!can_rename) {\n        errorCallback(getBadPermissionsError(), this.errorCode);\n        return Promise.reject();\n      }\n      this.id = id;\n      this.successCallback = successCallback;\n      this.errorCallback = errorCallback;\n      return this.xhr.put({\n        url: \"\".concat(this.getUrl(id)),\n        data: {\n          name: name\n        }\n      }).then(this.renameSuccessHandler).catch(function (e) {\n        _this3.errorHandler(e);\n      });\n    }\n    /**\n     * Handles response for shared link\n     *\n     * @param {BoxItem} data - The updated item\n     * @param {Array<string>} [fields] - Optional fields from request\n     * @return {void}\n     */\n  }, {\n    key: \"validateRequest\",\n    /**\n     * Validate an item update request\n     *\n     * @param {string|void} itemID - ID of item to share\n     * @param {BoxItemPermission|void} itemPermissions - Permissions for item\n     * @throws {Error}\n     * @return {void}\n     */\n    value: function validateRequest(itemID, itemPermissions) {\n      if (!itemID || !itemPermissions) {\n        this.errorCode = ERROR_CODE_SHARE_ITEM;\n        throw getBadItemError();\n      }\n      var can_share = itemPermissions.can_share,\n        can_set_share_access = itemPermissions.can_set_share_access;\n      if (!can_share || !can_set_share_access) {\n        this.errorCode = ERROR_CODE_SHARE_ITEM;\n        throw getBadPermissionsError();\n      }\n    }\n    /**\n     * API to create or remove a shared link\n     *\n     * @param {Object} item - Item to share\n     * @param {string} access - Shared access level\n     * @param {Function} successCallback - Success callback\n     * @param {Function|void} errorCallback - Error callback\n     * @param {Array<string>|void} [options.fields] - Optionally include specific fields\n     * @return {Promise<void>}\n     */\n  }, {\n    key: \"share\",\n    value: function () {\n      var _share = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(item, access,\n      // if \"access\" is undefined, the backend will set the default access level for the shared link\n      successCallback) {\n        var errorCallback,\n          options,\n          id,\n          permissions,\n          fields,\n          requestData,\n          _ref2,\n          data,\n          _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                errorCallback = _args.length > 3 && _args[3] !== undefined ? _args[3] : noop;\n                options = _args.length > 4 && _args[4] !== undefined ? _args[4] : {};\n                if (!this.isDestroyed()) {\n                  _context.next = 4;\n                  break;\n                }\n                return _context.abrupt(\"return\", Promise.reject());\n              case 4:\n                _context.prev = 4;\n                id = item.id, permissions = item.permissions;\n                this.id = id;\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback;\n                this.validateRequest(id, permissions);\n                fields = options.fields;\n                requestData = {\n                  url: this.getUrl(this.id),\n                  data: {\n                    shared_link: access === ACCESS_NONE ? null : {\n                      access: access\n                    }\n                  }\n                };\n                if (fields) {\n                  requestData.params = {\n                    fields: fields.toString()\n                  };\n                }\n                _context.next = 15;\n                return this.xhr.put(requestData);\n              case 15:\n                _ref2 = _context.sent;\n                data = _ref2.data;\n                return _context.abrupt(\"return\", this.shareSuccessHandler(data, fields));\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context[\"catch\"](4);\n                return _context.abrupt(\"return\", this.errorHandler(_context.t0));\n              case 23:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 20]]);\n      }));\n      function share(_x, _x2, _x3) {\n        return _share.apply(this, arguments);\n      }\n      return share;\n    }()\n    /**\n     * API to update a shared link\n     *\n     * @param {BoxItem} item - Item to update\n     * @param {$Shape<SharedLink>} sharedLinkParams - New shared link parameters\n     * @param {Function} successCallback - Success callback\n     * @param {Function|void} errorCallback - Error callback\n     * @param {Array<string>|void} [options.fields] - Optionally include specific fields\n     * @return {Promise<void>}\n     */\n  }, {\n    key: \"updateSharedLink\",\n    value: function () {\n      var _updateSharedLink = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(item, sharedLinkParams, successCallback) {\n        var errorCallback,\n          options,\n          id,\n          permissions,\n          fields,\n          requestData,\n          _ref3,\n          data,\n          _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                errorCallback = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : noop;\n                options = _args2.length > 4 && _args2[4] !== undefined ? _args2[4] : {};\n                if (!this.isDestroyed()) {\n                  _context2.next = 4;\n                  break;\n                }\n                return _context2.abrupt(\"return\", Promise.reject());\n              case 4:\n                _context2.prev = 4;\n                id = item.id, permissions = item.permissions;\n                this.id = id;\n                this.successCallback = successCallback;\n                this.errorCallback = errorCallback;\n                this.validateRequest(id, permissions);\n                fields = options.fields;\n                requestData = {\n                  url: this.getUrl(this.id),\n                  data: {\n                    shared_link: sharedLinkParams\n                  }\n                };\n                if (fields) {\n                  requestData.params = {\n                    fields: fields.toString()\n                  };\n                }\n                _context2.next = 15;\n                return this.xhr.put(requestData);\n              case 15:\n                _ref3 = _context2.sent;\n                data = _ref3.data;\n                return _context2.abrupt(\"return\", this.shareSuccessHandler(data, fields));\n              case 20:\n                _context2.prev = 20;\n                _context2.t0 = _context2[\"catch\"](4);\n                return _context2.abrupt(\"return\", this.errorHandler(_context2.t0));\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 20]]);\n      }));\n      function updateSharedLink(_x4, _x5, _x6) {\n        return _updateSharedLink.apply(this, arguments);\n      }\n      return updateSharedLink;\n    }()\n  }]);\n  return Item;\n}(Base);\nexport default Item;","map":{"version":3,"sources":["../../src/api/Item.js"],"names":["noop","setProp","getBadItemError","getBadPermissionsError","fillMissingProperties","Base","ACCESS_NONE","CACHE_PREFIX_SEARCH","CACHE_PREFIX_FOLDER","TYPE_FOLDER","ERROR_CODE_DELETE_ITEM","ERROR_CODE_RENAME_ITEM","ERROR_CODE_SHARE_ITEM","Item","id","cacheKey","key","value","cache","getCache","merge","get","isDestroyed","unsetAll","successCallback","parentKey","getParentCacheKey","parentId","folder","postDeleteCleanup","item_collection","entries","total_count","Array","isArray","childKey","getCacheKey","oldCount","length","newEntries","filter","entry","newCount","updatedObject","item","errorCallback","Promise","reject","errorCode","permissions","parent","type","can_delete","url","getUrl","xhr","delete","then","deleteSuccessHandler","catch","e","errorHandler","data","name","can_rename","put","renameSuccessHandler","fields","dataWithMissingFields","has","set","itemID","itemPermissions","can_share","can_set_share_access","access","options","validateRequest","requestData","shared_link","params","toString","shareSuccessHandler","sharedLinkParams"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the box item API\n * @author Box\n */\n\nimport noop from 'lodash/noop';\nimport setProp from 'lodash/set';\nimport { getBadItemError, getBadPermissionsError } from '../utils/error';\nimport { fillMissingProperties } from '../utils/fields';\nimport Base from './Base';\nimport {\n    ACCESS_NONE,\n    CACHE_PREFIX_SEARCH,\n    CACHE_PREFIX_FOLDER,\n    TYPE_FOLDER,\n    ERROR_CODE_DELETE_ITEM,\n    ERROR_CODE_RENAME_ITEM,\n    ERROR_CODE_SHARE_ITEM,\n} from '../constants';\nimport type { ElementsErrorCallback, RequestData, RequestOptions } from '../common/types/api';\nimport type {\n    BoxItem,\n    BoxItemPermission,\n    FlattenedBoxItem,\n    FlattenedBoxItemCollection,\n    SharedLink,\n} from '../common/types/core';\nimport type APICache from '../utils/Cache';\n\nclass Item extends Base {\n    /**\n     * @property {string}\n     */\n    id: string;\n\n    /**\n     * @property {string}\n     */\n    parentId: string;\n\n    /**\n     * @property {Function}\n     */\n    successCallback: Function;\n\n    /**\n     * @property {Function}\n     */\n    errorCallback: ElementsErrorCallback;\n\n    /**\n     * Creates a key for the item's parent\n     * This is always a folder\n     *\n     * @param {string} Id - folder id\n     * @return {string} Key\n     */\n    getParentCacheKey(id: string): string {\n        return `${CACHE_PREFIX_FOLDER}${id}`;\n    }\n\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} Id - Folder id\n     * @return {string} Key\n     */\n    getCacheKey(id: string): string {\n        return `getCacheKey(${id}) should be overriden`;\n    }\n\n    /**\n     * API URL for items\n     *\n     * @param {string} id - Item id\n     * @protected\n     * @return {string} Base url for files\n     */\n    getUrl(id: string): string {\n        return `getUrl(${id}) should be overriden`;\n    }\n\n    /**\n     * Merges new data with old data and returns new data\n     *\n     * @param {String} cacheKey - The cache key of item to merge\n     * @param {String} key - The attribute to merge\n     * @param {Object} value - The value to merge\n     * @return {BoxItem} The newly updated object from the cache\n     */\n    merge(cacheKey: string, key: string, value: any): BoxItem {\n        const cache: APICache = this.getCache();\n        cache.merge(cacheKey, setProp({}, key, value));\n        return cache.get(cacheKey);\n    }\n\n    /**\n     * Steps to do after deletion\n     *\n     * @return {void}\n     */\n    postDeleteCleanup(): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Get rid of all searches\n        this.getCache().unsetAll(CACHE_PREFIX_SEARCH);\n        this.successCallback();\n    }\n\n    /**\n     * Handles response for deletion\n     *\n     * @return {void}\n     */\n    deleteSuccessHandler = (): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // When fetching the parent folder from the cache\n        // we have no guarantees that it will be there since\n        // search results happen across folders and we only\n        // add those folders to cache that have been navigated to.\n        const parentKey: string = this.getParentCacheKey(this.parentId);\n        const folder: ?FlattenedBoxItem = this.getCache().get(parentKey);\n        if (!folder) {\n            this.postDeleteCleanup();\n            return;\n        }\n\n        // Same logic as above but in this case we may have the parent\n        // folders meta data in cache but not its contents.\n        const { item_collection }: FlattenedBoxItem = folder;\n        if (!item_collection) {\n            this.postDeleteCleanup();\n            return;\n        }\n\n        const { entries, total_count }: FlattenedBoxItemCollection = item_collection;\n        if (!Array.isArray(entries) || typeof total_count !== 'number') {\n            throw getBadItemError();\n        }\n\n        const childKey: string = this.getCacheKey(this.id);\n        const oldCount: number = entries.length;\n        const newEntries: string[] = entries.filter((entry: string) => entry !== childKey);\n        const newCount: number = newEntries.length;\n\n        const updatedObject: BoxItem = this.merge(\n            parentKey,\n            'item_collection',\n            Object.assign(item_collection, {\n                entries: newEntries,\n                total_count: total_count - (oldCount - newCount),\n            }),\n        );\n\n        this.successCallback(updatedObject);\n        this.postDeleteCleanup();\n    };\n\n    /**\n     * API to delete an Item\n     *\n     * @param {Object} item - Item to delete\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    deleteItem(item: BoxItem, successCallback: Function, errorCallback: ElementsErrorCallback = noop): Promise<void> {\n        if (this.isDestroyed()) {\n            return Promise.reject();\n        }\n\n        this.errorCode = ERROR_CODE_DELETE_ITEM;\n        const { id, permissions, parent, type }: BoxItem = item;\n        if (!id || !permissions || !parent || !type) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return Promise.reject();\n        }\n\n        const { id: parentId } = parent;\n        const { can_delete }: BoxItemPermission = permissions;\n        if (!can_delete || !parentId) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return Promise.reject();\n        }\n\n        this.id = id;\n        this.parentId = parentId;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        const url = `${this.getUrl(id)}${type === TYPE_FOLDER ? '?recursive=true' : ''}`;\n        return this.xhr\n            .delete({ url })\n            .then(this.deleteSuccessHandler)\n            .catch((e: $AxiosError<any>) => {\n                this.errorHandler(e);\n            });\n    }\n\n    /**\n     * Handles response for rename\n     *\n     * @param {BoxItem} data - The updated item\n     * @return {void}\n     */\n    renameSuccessHandler = ({ data }: { data: BoxItem }): void => {\n        if (!this.isDestroyed()) {\n            // Get rid of all searches\n            this.getCache().unsetAll(CACHE_PREFIX_SEARCH);\n            const updatedObject: BoxItem = this.merge(this.getCacheKey(this.id), 'name', data.name);\n            this.successCallback(updatedObject);\n        }\n    };\n\n    /**\n     * API to rename an Item\n     *\n     * @param {Object} item - Item to rename\n     * @param {string} name - Item new name\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    rename(\n        item: BoxItem,\n        name: string,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback = noop,\n    ): Promise<void> {\n        if (this.isDestroyed()) {\n            return Promise.reject();\n        }\n\n        this.errorCode = ERROR_CODE_RENAME_ITEM;\n        const { id, permissions }: BoxItem = item;\n        if (!id || !permissions) {\n            errorCallback(getBadItemError(), this.errorCode);\n            return Promise.reject();\n        }\n\n        const { can_rename }: BoxItemPermission = permissions;\n        if (!can_rename) {\n            errorCallback(getBadPermissionsError(), this.errorCode);\n            return Promise.reject();\n        }\n\n        this.id = id;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        return this.xhr\n            .put({ url: `${this.getUrl(id)}`, data: { name } })\n            .then(this.renameSuccessHandler)\n            .catch((e: $AxiosError<any>) => {\n                this.errorHandler(e);\n            });\n    }\n\n    /**\n     * Handles response for shared link\n     *\n     * @param {BoxItem} data - The updated item\n     * @param {Array<string>} [fields] - Optional fields from request\n     * @return {void}\n     */\n    shareSuccessHandler = (data: BoxItem, fields?: Array<string>): void => {\n        if (!this.isDestroyed()) {\n            // Add fields that were requested but not returned\n            const dataWithMissingFields = fields ? fillMissingProperties(data, fields) : data;\n            const cache: APICache = this.getCache();\n            const key = this.getCacheKey(this.id);\n\n            if (cache.has(key)) {\n                cache.merge(key, dataWithMissingFields);\n            } else {\n                cache.set(key, dataWithMissingFields);\n            }\n            this.successCallback(cache.get(key));\n        }\n    };\n\n    /**\n     * Validate an item update request\n     *\n     * @param {string|void} itemID - ID of item to share\n     * @param {BoxItemPermission|void} itemPermissions - Permissions for item\n     * @throws {Error}\n     * @return {void}\n     */\n    validateRequest(itemID: ?string, itemPermissions: ?BoxItemPermission) {\n        if (!itemID || !itemPermissions) {\n            this.errorCode = ERROR_CODE_SHARE_ITEM;\n            throw getBadItemError();\n        }\n\n        const { can_share, can_set_share_access }: BoxItemPermission = itemPermissions;\n        if (!can_share || !can_set_share_access) {\n            this.errorCode = ERROR_CODE_SHARE_ITEM;\n            throw getBadPermissionsError();\n        }\n    }\n\n    /**\n     * API to create or remove a shared link\n     *\n     * @param {Object} item - Item to share\n     * @param {string} access - Shared access level\n     * @param {Function} successCallback - Success callback\n     * @param {Function|void} errorCallback - Error callback\n     * @param {Array<string>|void} [options.fields] - Optionally include specific fields\n     * @return {Promise<void>}\n     */\n    async share(\n        item: BoxItem,\n        access: ?string, // if \"access\" is undefined, the backend will set the default access level for the shared link\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback = noop,\n        options: RequestOptions = {},\n    ): Promise<void> {\n        if (this.isDestroyed()) {\n            return Promise.reject();\n        }\n\n        try {\n            const { id, permissions }: BoxItem = item;\n            this.id = id;\n            this.successCallback = successCallback;\n            this.errorCallback = errorCallback;\n\n            this.validateRequest(id, permissions);\n\n            const { fields } = options;\n            const requestData: RequestData = {\n                url: this.getUrl(this.id),\n                data: {\n                    shared_link: access === ACCESS_NONE ? null : { access },\n                },\n            };\n            if (fields) {\n                requestData.params = { fields: fields.toString() };\n            }\n\n            const { data } = await this.xhr.put(requestData);\n            return this.shareSuccessHandler(data, fields);\n        } catch (e) {\n            return this.errorHandler(e);\n        }\n    }\n\n    /**\n     * API to update a shared link\n     *\n     * @param {BoxItem} item - Item to update\n     * @param {$Shape<SharedLink>} sharedLinkParams - New shared link parameters\n     * @param {Function} successCallback - Success callback\n     * @param {Function|void} errorCallback - Error callback\n     * @param {Array<string>|void} [options.fields] - Optionally include specific fields\n     * @return {Promise<void>}\n     */\n    async updateSharedLink(\n        item: BoxItem,\n        sharedLinkParams: $Shape<SharedLink>,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback = noop,\n        options: RequestOptions = {},\n    ): Promise<void> {\n        if (this.isDestroyed()) {\n            return Promise.reject();\n        }\n\n        try {\n            const { id, permissions }: BoxItem = item;\n            this.id = id;\n            this.successCallback = successCallback;\n            this.errorCallback = errorCallback;\n\n            this.validateRequest(id, permissions);\n\n            const { fields } = options;\n            const requestData: RequestData = {\n                url: this.getUrl(this.id),\n                data: {\n                    shared_link: sharedLinkParams,\n                },\n            };\n            if (fields) {\n                requestData.params = { fields: fields.toString() };\n            }\n\n            const { data } = await this.xhr.put(requestData);\n            return this.shareSuccessHandler(data, fields);\n        } catch (e) {\n            return this.errorHandler(e);\n        }\n    }\n}\n\nexport default Item;\n"]},"metadata":{},"sourceType":"module"}