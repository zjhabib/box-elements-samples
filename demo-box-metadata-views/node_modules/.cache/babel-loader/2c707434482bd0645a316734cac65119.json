{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Multiput upload base class\n * @author Box\n */\nimport BaseUpload from './BaseUpload';\nvar DEFAULT_MULTIPUT_CONFIG = {\n  digestReadahead: 5,\n  // How many parts past those currently uploading to precompute digest for\n  initialRetryDelayMs: 5000,\n  // Base for exponential backoff on retries\n  maxRetryDelayMs: 60000,\n  // Upper bound for time between retries\n  parallelism: 4,\n  // Maximum number of parts to upload at a time\n  requestTimeoutMs: 120000,\n  // Idle timeout on part upload, overall request timeout on other requests\n  retries: 5 // How many times to retry requests such as upload part or commit. Note that total number of attempts will be retries + 1 in worst case where all attempts fail.\n};\n\nvar BaseMultiput = /*#__PURE__*/\nfunction (_BaseUpload) {\n  _inherits(BaseMultiput, _BaseUpload);\n\n  /**\n   * [constructor]\n   *\n   * @param {Options} options\n   * @param {Object} sessionEndpoints\n   * @param {MultiputConfig} [config]\n   * @return {void}\n   */\n  function BaseMultiput(options, sessionEndpoints, config) {\n    var _this;\n    _classCallCheck(this, BaseMultiput);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseMultiput).call(this, _objectSpread({}, options, {\n      shouldRetry: false // disable XHR retries as there is already retry logic\n    })));\n\n    _defineProperty(_assertThisInitialized(_this), \"logEvent\", function (eventType, eventInfo) {\n      var data = {\n        event_type: eventType\n      };\n      if (eventInfo) {\n        data.event_info = eventInfo;\n      }\n      return _this.xhr.post({\n        url: _this.sessionEndpoints.logEvent,\n        data: data\n      });\n    });\n    _this.config = config || DEFAULT_MULTIPUT_CONFIG;\n    _this.sessionEndpoints = sessionEndpoints;\n    return _this;\n  }\n  /**\n   * POST log event\n   *\n   * @param {string} eventType\n   * @param {string} [eventInfo]\n   * @return {Promise}\n   */\n\n  return BaseMultiput;\n}(BaseUpload);\nexport default BaseMultiput;","map":{"version":3,"sources":["../../../src/api/uploads/BaseMultiput.js"],"names":["BaseUpload","DEFAULT_MULTIPUT_CONFIG","digestReadahead","initialRetryDelayMs","maxRetryDelayMs","parallelism","requestTimeoutMs","retries","BaseMultiput","options","sessionEndpoints","config","shouldRetry","eventType","eventInfo","data","event_type","event_info","xhr","post","url","logEvent"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAKA,OAAOA,UAAP,MAAuB,cAAvB;AAIA,IAAMC,uBAAuC,GAAG;EAC5CC,eAAe,EAAE,CAD2B;EACxB;EACpBC,mBAAmB,EAAE,IAFuB;EAEjB;EAC3BC,eAAe,EAAE,KAH2B;EAGpB;EACxBC,WAAW,EAAE,CAJ+B;EAI5B;EAChBC,gBAAgB,EAAE,MAL0B;EAKlB;EAC1BC,OAAO,EAAE,CANmC,CAMhC;AANgC,CAAhD;;IASMC,Y;;;;EAKF;;;;;;;;EAQA,SAAA,YAAA,CAAYC,OAAZ,EAAiCC,gBAAjC,EAA2DC,MAA3D,EAA0F;IAAA,IAAA,KAAA;IAAA,eAAA,CAAA,IAAA,EAAA,YAAA,CAAA;IACtF,KAAA,GAAA,0BAAA,CAAA,IAAA,EAAA,eAAA,CAAA,YAAA,CAAA,CAAA,IAAA,CAAA,IAAA,EAAA,aAAA,CAAA,CAAA,CAAA,EACOF,OADP,EAAA;MAEIG,WAAW,EAAE,KAFjB,CAEwB;IAFxB,CAAA,CAAA,CAAA,CAAA;;IADsF,eAAA,CAAA,sBAAA,CAAA,KAAA,CAAA,EAAA,UAAA,EAiB/E,UAACC,SAAD,EAAoBC,SAApB,EAA2C;MAClD,IAAMC,IAGL,GAAG;QACAC,UAAU,EAAEH;MADZ,CAHJ;MAOA,IAAIC,SAAJ,EAAe;QACXC,IAAI,CAACE,UAALF,GAAkBD,SAAlBC;MACH;MAED,OAAO,KAAA,CAAKG,GAAL,CAASC,IAAT,CAAc;QACjBC,GAAG,EAAE,KAAA,CAAKV,gBAAL,CAAsBW,QADV;QAEjBN,IAAI,EAAJA;MAFiB,CAAd,CAAP;IAIH,CAjCyF,CAAA;IAMtF,KAAA,CAAKJ,MAAL,GAAcA,MAAM,IAAIV,uBAAxB;IACA,KAAA,CAAKS,gBAAL,GAAwBA,gBAAxB;IAPsF,OAAA,KAAA;EAQzF;EAED;;;;;;;;;EAvBuBV,U;AAiD3B,eAAeQ,YAAf","sourcesContent":["/**\n * @flow\n * @file Multiput upload base class\n * @author Box\n */\nimport BaseUpload from './BaseUpload';\nimport type { MultiputConfig } from '../../common/types/upload';\nimport type { APIOptions } from '../../common/types/api';\n\nconst DEFAULT_MULTIPUT_CONFIG: MultiputConfig = {\n    digestReadahead: 5, // How many parts past those currently uploading to precompute digest for\n    initialRetryDelayMs: 5000, // Base for exponential backoff on retries\n    maxRetryDelayMs: 60000, // Upper bound for time between retries\n    parallelism: 4, // Maximum number of parts to upload at a time\n    requestTimeoutMs: 120000, // Idle timeout on part upload, overall request timeout on other requests\n    retries: 5, // How many times to retry requests such as upload part or commit. Note that total number of attempts will be retries + 1 in worst case where all attempts fail.\n};\n\nclass BaseMultiput extends BaseUpload {\n    config: MultiputConfig;\n\n    sessionEndpoints: Object;\n\n    /**\n     * [constructor]\n     *\n     * @param {Options} options\n     * @param {Object} sessionEndpoints\n     * @param {MultiputConfig} [config]\n     * @return {void}\n     */\n    constructor(options: APIOptions, sessionEndpoints: Object, config?: MultiputConfig): void {\n        super({\n            ...options,\n            shouldRetry: false, // disable XHR retries as there is already retry logic\n        });\n\n        this.config = config || DEFAULT_MULTIPUT_CONFIG;\n        this.sessionEndpoints = sessionEndpoints;\n    }\n\n    /**\n     * POST log event\n     *\n     * @param {string} eventType\n     * @param {string} [eventInfo]\n     * @return {Promise}\n     */\n    logEvent = (eventType: string, eventInfo?: string) => {\n        const data: {\n            event_info?: string,\n            event_type: string,\n        } = {\n            event_type: eventType,\n        };\n\n        if (eventInfo) {\n            data.event_info = eventInfo;\n        }\n\n        return this.xhr.post({\n            url: this.sessionEndpoints.logEvent,\n            data,\n        });\n    };\n}\n\nexport default BaseMultiput;\n"]},"metadata":{},"sourceType":"module"}