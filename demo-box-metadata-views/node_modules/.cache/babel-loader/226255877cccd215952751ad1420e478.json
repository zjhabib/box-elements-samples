{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Helper for the box folder api\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport flatten from '../utils/flatten';\nimport { FOLDER_FIELDS_TO_FETCH } from '../utils/fields';\nimport { getBadItemError } from '../utils/error';\nimport Item from './Item';\nimport FileAPI from './File';\nimport WebLinkAPI from './WebLink';\nimport { CACHE_PREFIX_FOLDER, ERROR_CODE_FETCH_FOLDER, ERROR_CODE_CREATE_FOLDER, FIELD_REPRESENTATIONS, X_REP_HINT_HEADER_DIMENSIONS_DEFAULT } from '../constants';\nvar Folder = /*#__PURE__*/\nfunction (_Item) {\n  _inherits(Folder, _Item);\n  function Folder() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, Folder);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Folder)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"folderSuccessHandler\", function (_ref) {\n      var data = _ref.data;\n      if (_this.isDestroyed()) {\n        return;\n      }\n      var item_collection = data.item_collection;\n      if (!item_collection) {\n        throw getBadItemError();\n      }\n      var entries = item_collection.entries,\n        total_count = item_collection.total_count,\n        limit = item_collection.limit,\n        offset = item_collection.offset;\n      if (!Array.isArray(entries) || typeof total_count !== 'number' || typeof limit !== 'number' || typeof offset !== 'number') {\n        throw getBadItemError();\n      }\n      var flattened = flatten(entries, new Folder(_this.options), new FileAPI(_this.options), new WebLinkAPI(_this.options));\n      _this.itemCache = (_this.itemCache || []).concat(flattened);\n      _this.getCache().set(_this.key, _objectSpread({}, data, {\n        item_collection: _objectSpread({}, item_collection, {\n          entries: _this.itemCache\n        })\n      }));\n      _this.finish();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"folderDetailsSuccessHandler\", function (_ref2) {\n      var data = _ref2.data;\n      if (_this.isDestroyed()) {\n        return;\n      }\n      var cachedEntry = _this.getCache().get(_this.key);\n      var updatedCacheEntry = _objectSpread({}, cachedEntry, {}, data);\n      _this.getCache().set(_this.key, updatedCacheEntry);\n      _this.successCallback(updatedCacheEntry);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"createSuccessHandler\", function (_ref3) {\n      var data = _ref3.data;\n      var childId = data.id;\n      if (_this.isDestroyed() || !childId) {\n        return;\n      }\n      var childKey = _this.getCacheKey(childId);\n      var cache = _this.getCache();\n      var parent = cache.get(_this.key);\n      if (!parent) {\n        _this.successCallback(data);\n        return;\n      }\n      var item_collection = parent.item_collection;\n      if (!item_collection) {\n        throw getBadItemError();\n      }\n      var total_count = item_collection.total_count,\n        entries = item_collection.entries;\n      if (!Array.isArray(entries) || typeof total_count !== 'number') {\n        throw getBadItemError();\n      }\n      cache.set(childKey, data);\n      item_collection.entries = [childKey].concat(entries);\n      item_collection.total_count = total_count + 1;\n      _this.successCallback(data);\n    });\n    return _this;\n  }\n  _createClass(Folder, [{\n    key: \"getCacheKey\",\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {number}\n     */\n\n    /**\n     * @property {number}\n     */\n\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {string}\n     */\n\n    /**\n     * @property {Array}\n     */\n\n    /**\n     * @property {Function}\n     */\n\n    /**\n     * @property {Function}\n     */\n\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id folder id\n     * @return {string} key\n     */\n    value: function getCacheKey(id) {\n      return \"\".concat(CACHE_PREFIX_FOLDER).concat(id);\n    }\n    /**\n     * Base URL for folder api\n     *\n     * @param {string} [id] optional file id\n     * @return {string} base url for files\n     */\n  }, {\n    key: \"getUrl\",\n    value: function getUrl(id) {\n      var suffix = id ? \"/\".concat(id) : '';\n      return \"\".concat(this.getBaseApiUrl(), \"/folders\").concat(suffix);\n    }\n    /**\n     * Tells if a folder has its items all loaded\n     *\n     * @return {boolean} if items are loaded\n     */\n  }, {\n    key: \"isLoaded\",\n    value: function isLoaded() {\n      var cache = this.getCache();\n      return cache.has(this.key);\n    }\n    /**\n     * Composes and returns the results\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      if (this.isDestroyed()) {\n        return;\n      }\n      var cache = this.getCache();\n      var folder = cache.get(this.key);\n      var id = folder.id,\n        name = folder.name,\n        permissions = folder.permissions,\n        path_collection = folder.path_collection,\n        item_collection = folder.item_collection;\n      if (!item_collection || !path_collection) {\n        throw getBadItemError();\n      }\n      var entries = item_collection.entries,\n        offset = item_collection.offset,\n        total_count = item_collection.total_count;\n      if (!Array.isArray(entries) || typeof total_count !== 'number') {\n        throw getBadItemError();\n      }\n      var collection = {\n        id: id,\n        name: name,\n        offset: offset,\n        percentLoaded: 100,\n        permissions: permissions,\n        boxItem: folder,\n        breadcrumbs: path_collection.entries,\n        items: entries.map(function (key) {\n          return cache.get(key);\n        }),\n        sortBy: this.sortBy,\n        sortDirection: this.sortDirection,\n        totalCount: total_count\n      };\n      this.successCallback(collection);\n    }\n    /**\n     * Handles the folder fetch response\n     *\n     * @param {Object} response\n     * @return {void}\n     */\n  }, {\n    key: \"folderRequest\",\n    /**\n     * Does the network request for fetching a folder\n     *\n     * @param {Array<String>} fields Array of field strings\n     * @return {Promise}\n     */\n    value: function folderRequest() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        fields = _ref4.fields,\n        noPagination = _ref4.noPagination;\n      var successHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.folderSuccessHandler;\n      if (this.isDestroyed()) {\n        return Promise.reject();\n      }\n      var requestFields = fields || FOLDER_FIELDS_TO_FETCH;\n      this.errorCode = ERROR_CODE_FETCH_FOLDER;\n      var params = {\n        fields: requestFields.toString()\n      };\n      if (!noPagination) {\n        params = _objectSpread({}, params, {\n          direction: this.sortDirection.toLowerCase(),\n          limit: this.limit,\n          offset: this.offset,\n          fields: requestFields.toString(),\n          sort: this.sortBy.toLowerCase()\n        });\n      }\n      return this.xhr.get({\n        url: this.getUrl(this.id),\n        params: params,\n        headers: requestFields.includes(FIELD_REPRESENTATIONS) ? {\n          'X-Rep-Hints': X_REP_HINT_HEADER_DIMENSIONS_DEFAULT\n        } : {}\n      }).then(successHandler).catch(this.errorHandler);\n    }\n    /**\n     * Gets a box folder properties. If you want to get the items, you should use `getFolder`\n     *\n     * @param {string} id - Folder id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {Object} options - Options\n     * @returns {void}\n     */\n  }, {\n    key: \"getFolderFields\",\n    value: function getFolderFields(id, successCallback, errorCallback) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      if (this.isDestroyed()) {\n        return;\n      } // Save references\n\n      this.id = id;\n      this.key = this.getCacheKey(id);\n      this.successCallback = successCallback;\n      this.errorCallback = errorCallback;\n      this.folderRequest(_objectSpread({}, options, {\n        noPagination: true\n      }), this.folderDetailsSuccessHandler);\n    }\n    /**\n     * Gets a box folder and its items\n     *\n     * @param {string} id - Folder id\n     * @param {number} limit - maximum number of items to retrieve\n     * @param {number} offset - starting index from which to retrieve items\n     * @param {string} sortBy - sort by field\n     * @param {string} sortDirection - sort direction\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.fields] - Optionally include specific fields\n     * @param {boolean|void} [options.forceFetch] - Optionally Bypasses the cache\n     * @param {boolean|void} [options.refreshCache] - Optionally Updates the cache\n     * @return {void}\n     */\n  }, {\n    key: \"getFolder\",\n    value: function getFolder(id, limit, offset, sortBy, sortDirection, successCallback, errorCallback) {\n      var options = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};\n      if (this.isDestroyed()) {\n        return;\n      } // Save references\n\n      this.id = id;\n      this.key = this.getCacheKey(id);\n      this.limit = limit;\n      this.offset = offset;\n      this.sortBy = sortBy;\n      this.sortDirection = sortDirection;\n      this.successCallback = successCallback;\n      this.errorCallback = errorCallback; // Clear the cache if needed\n\n      if (options.forceFetch) {\n        this.getCache().unset(this.key);\n      } // Return the Cache value if it exists\n\n      if (this.isLoaded()) {\n        this.finish();\n        return;\n      } // Make the XHR request\n\n      this.folderRequest(options);\n    }\n    /**\n     * API to rename an Item\n     *\n     * @param {string} id - parent folder id\n     * @param {string} name - new folder name\n     * @param {Function} successCallback - success callback\n     * @param {Function} errorCallback - error callback\n     * @return {void}\n     */\n  }, {\n    key: \"folderCreateRequest\",\n    /**\n     * Does the network request for fetching a folder\n     *\n     * @return {void}\n     */\n    value: function folderCreateRequest(name) {\n      if (this.isDestroyed()) {\n        return Promise.reject();\n      }\n      this.errorCode = ERROR_CODE_CREATE_FOLDER;\n      var url = \"\".concat(this.getUrl(), \"?fields=\").concat(FOLDER_FIELDS_TO_FETCH.toString());\n      return this.xhr.post({\n        url: url,\n        data: {\n          name: name,\n          parent: {\n            id: this.id\n          }\n        }\n      }).then(this.createSuccessHandler).catch(this.errorHandler);\n    }\n    /**\n     * API to create a folder\n     *\n     * @param {string} id - parent folder id\n     * @param {string} name - new folder name\n     * @param {Function} successCallback - success callback\n     * @param {Function} errorCallback - error callback\n     * @return {void}\n     */\n  }, {\n    key: \"create\",\n    value: function create(id, name, successCallback) {\n      var errorCallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n      if (this.isDestroyed()) {\n        return;\n      }\n      this.id = id;\n      this.key = this.getCacheKey(id);\n      this.successCallback = successCallback;\n      this.errorCallback = errorCallback;\n      this.folderCreateRequest(name);\n    }\n  }]);\n  return Folder;\n}(Item);\nexport default Folder;","map":{"version":3,"sources":["../../src/api/Folder.js"],"names":["noop","flatten","FOLDER_FIELDS_TO_FETCH","getBadItemError","Item","FileAPI","WebLinkAPI","CACHE_PREFIX_FOLDER","ERROR_CODE_FETCH_FOLDER","ERROR_CODE_CREATE_FOLDER","FIELD_REPRESENTATIONS","X_REP_HINT_HEADER_DIMENSIONS_DEFAULT","Folder","id","suffix","getBaseApiUrl","cache","getCache","has","key","isDestroyed","folder","get","name","permissions","path_collection","item_collection","entries","offset","total_count","Array","isArray","collection","percentLoaded","boxItem","breadcrumbs","items","map","sortBy","sortDirection","totalCount","successCallback","data","limit","flattened","options","itemCache","concat","set","finish","cachedEntry","updatedCacheEntry","fields","noPagination","successHandler","folderSuccessHandler","Promise","reject","requestFields","errorCode","params","toString","direction","toLowerCase","sort","xhr","url","getUrl","headers","includes","then","catch","errorHandler","errorCallback","getCacheKey","folderRequest","folderDetailsSuccessHandler","forceFetch","unset","isLoaded","childId","childKey","parent","post","createSuccessHandler","folderCreateRequest"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Helper for the box folder api\n * @author Box\n */\n\nimport noop from 'lodash/noop';\nimport flatten from '../utils/flatten';\nimport { FOLDER_FIELDS_TO_FETCH } from '../utils/fields';\nimport { getBadItemError } from '../utils/error';\nimport Item from './Item';\nimport FileAPI from './File';\nimport WebLinkAPI from './WebLink';\nimport {\n    CACHE_PREFIX_FOLDER,\n    ERROR_CODE_FETCH_FOLDER,\n    ERROR_CODE_CREATE_FOLDER,\n    FIELD_REPRESENTATIONS,\n    X_REP_HINT_HEADER_DIMENSIONS_DEFAULT,\n} from '../constants';\nimport type { RequestOptions, ElementsErrorCallback } from '../common/types/api';\nimport type {\n    SortBy,\n    SortDirection,\n    FlattenedBoxItem,\n    FlattenedBoxItemCollection,\n    Collection,\n    BoxItem,\n    BoxItemCollection,\n} from '../common/types/core';\nimport type APICache from '../utils/Cache';\n\nclass Folder extends Item {\n    /**\n     * @property {string}\n     */\n    id: string;\n\n    /**\n     * @property {string}\n     */\n    key: string;\n\n    /**\n     * @property {number}\n     */\n    limit: number;\n\n    /**\n     * @property {number}\n     */\n    offset: number;\n\n    /**\n     * @property {string}\n     */\n    sortBy: SortBy;\n\n    /**\n     * @property {string}\n     */\n    sortDirection: SortDirection;\n\n    /**\n     * @property {Array}\n     */\n    itemCache: string[];\n\n    /**\n     * @property {Function}\n     */\n    successCallback: Function;\n\n    /**\n     * @property {Function}\n     */\n    errorCallback: ElementsErrorCallback;\n\n    /**\n     * Creates a key for the cache\n     *\n     * @param {string} id folder id\n     * @return {string} key\n     */\n    getCacheKey(id: string): string {\n        return `${CACHE_PREFIX_FOLDER}${id}`;\n    }\n\n    /**\n     * Base URL for folder api\n     *\n     * @param {string} [id] optional file id\n     * @return {string} base url for files\n     */\n    getUrl(id?: string): string {\n        const suffix: string = id ? `/${id}` : '';\n        return `${this.getBaseApiUrl()}/folders${suffix}`;\n    }\n\n    /**\n     * Tells if a folder has its items all loaded\n     *\n     * @return {boolean} if items are loaded\n     */\n    isLoaded(): boolean {\n        const cache: APICache = this.getCache();\n        return cache.has(this.key);\n    }\n\n    /**\n     * Composes and returns the results\n     *\n     * @return {void}\n     */\n    finish(): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const cache: APICache = this.getCache();\n        const folder: FlattenedBoxItem = cache.get(this.key);\n        const { id, name, permissions, path_collection, item_collection }: FlattenedBoxItem = folder;\n        if (!item_collection || !path_collection) {\n            throw getBadItemError();\n        }\n\n        const { entries, offset, total_count }: FlattenedBoxItemCollection = item_collection;\n        if (!Array.isArray(entries) || typeof total_count !== 'number') {\n            throw getBadItemError();\n        }\n\n        const collection: Collection = {\n            id,\n            name,\n            offset,\n            percentLoaded: 100,\n            permissions,\n            boxItem: folder,\n            breadcrumbs: path_collection.entries,\n            items: entries.map((key: string) => cache.get(key)),\n            sortBy: this.sortBy,\n            sortDirection: this.sortDirection,\n            totalCount: total_count,\n        };\n        this.successCallback(collection);\n    }\n\n    /**\n     * Handles the folder fetch response\n     *\n     * @param {Object} response\n     * @return {void}\n     */\n    folderSuccessHandler = ({ data }: { data: BoxItem }): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const { item_collection }: BoxItem = data;\n        if (!item_collection) {\n            throw getBadItemError();\n        }\n\n        const { entries, total_count, limit, offset }: BoxItemCollection = item_collection;\n        if (\n            !Array.isArray(entries) ||\n            typeof total_count !== 'number' ||\n            typeof limit !== 'number' ||\n            typeof offset !== 'number'\n        ) {\n            throw getBadItemError();\n        }\n\n        const flattened: string[] = flatten(\n            entries,\n            new Folder(this.options),\n            new FileAPI(this.options),\n            new WebLinkAPI(this.options),\n        );\n        this.itemCache = (this.itemCache || []).concat(flattened);\n\n        this.getCache().set(this.key, {\n            ...data,\n            item_collection: { ...item_collection, entries: this.itemCache },\n        });\n\n        this.finish();\n    };\n\n    /**\n     * Handles a request for folder details\n     *\n     * @param {Object} data - XHR response data\n     * @returns {void}\n     */\n    folderDetailsSuccessHandler = ({ data }: { data: BoxItem }): void => {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        const cachedEntry = this.getCache().get(this.key);\n        const updatedCacheEntry = { ...cachedEntry, ...data };\n\n        this.getCache().set(this.key, updatedCacheEntry);\n        this.successCallback(updatedCacheEntry);\n    };\n\n    /**\n     * Does the network request for fetching a folder\n     *\n     * @param {Array<String>} fields Array of field strings\n     * @return {Promise}\n     */\n    folderRequest(\n        { fields, noPagination }: RequestOptions = {},\n        successHandler?: Function = this.folderSuccessHandler,\n    ): Promise<any> {\n        if (this.isDestroyed()) {\n            return Promise.reject();\n        }\n\n        const requestFields = fields || FOLDER_FIELDS_TO_FETCH;\n\n        this.errorCode = ERROR_CODE_FETCH_FOLDER;\n        let params = { fields: requestFields.toString() };\n        if (!noPagination) {\n            params = {\n                ...params,\n                direction: this.sortDirection.toLowerCase(),\n                limit: this.limit,\n                offset: this.offset,\n                fields: requestFields.toString(),\n                sort: this.sortBy.toLowerCase(),\n            };\n        }\n\n        return this.xhr\n            .get({\n                url: this.getUrl(this.id),\n                params,\n                headers: requestFields.includes(FIELD_REPRESENTATIONS)\n                    ? {\n                          'X-Rep-Hints': X_REP_HINT_HEADER_DIMENSIONS_DEFAULT,\n                      }\n                    : {},\n            })\n            .then(successHandler)\n            .catch(this.errorHandler);\n    }\n\n    /**\n     * Gets a box folder properties. If you want to get the items, you should use `getFolder`\n     *\n     * @param {string} id - Folder id\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {Object} options - Options\n     * @returns {void}\n     */\n    getFolderFields(\n        id: string,\n        successCallback: Function,\n        errorCallback: Function,\n        options: RequestOptions = {},\n    ): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Save references\n        this.id = id;\n        this.key = this.getCacheKey(id);\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        this.folderRequest({ ...options, noPagination: true }, this.folderDetailsSuccessHandler);\n    }\n\n    /**\n     * Gets a box folder and its items\n     *\n     * @param {string} id - Folder id\n     * @param {number} limit - maximum number of items to retrieve\n     * @param {number} offset - starting index from which to retrieve items\n     * @param {string} sortBy - sort by field\n     * @param {string} sortDirection - sort direction\n     * @param {Function} successCallback - Function to call with results\n     * @param {Function} errorCallback - Function to call with errors\n     * @param {boolean|void} [options.fields] - Optionally include specific fields\n     * @param {boolean|void} [options.forceFetch] - Optionally Bypasses the cache\n     * @param {boolean|void} [options.refreshCache] - Optionally Updates the cache\n     * @return {void}\n     */\n    getFolder(\n        id: string,\n        limit: number,\n        offset: number,\n        sortBy: SortBy,\n        sortDirection: SortDirection,\n        successCallback: Function,\n        errorCallback: Function,\n        options: RequestOptions = {},\n    ): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        // Save references\n        this.id = id;\n        this.key = this.getCacheKey(id);\n        this.limit = limit;\n        this.offset = offset;\n        this.sortBy = sortBy;\n        this.sortDirection = sortDirection;\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n\n        // Clear the cache if needed\n        if (options.forceFetch) {\n            this.getCache().unset(this.key);\n        }\n\n        // Return the Cache value if it exists\n        if (this.isLoaded()) {\n            this.finish();\n            return;\n        }\n\n        // Make the XHR request\n        this.folderRequest(options);\n    }\n\n    /**\n     * API to rename an Item\n     *\n     * @param {string} id - parent folder id\n     * @param {string} name - new folder name\n     * @param {Function} successCallback - success callback\n     * @param {Function} errorCallback - error callback\n     * @return {void}\n     */\n    createSuccessHandler = ({ data }: { data: BoxItem }): void => {\n        const { id: childId } = data;\n        if (this.isDestroyed() || !childId) {\n            return;\n        }\n\n        const childKey: string = this.getCacheKey(childId);\n        const cache: APICache = this.getCache();\n        const parent: FlattenedBoxItem = cache.get(this.key);\n\n        if (!parent) {\n            this.successCallback(data);\n            return;\n        }\n\n        const { item_collection }: FlattenedBoxItem = parent;\n        if (!item_collection) {\n            throw getBadItemError();\n        }\n\n        const { total_count, entries }: FlattenedBoxItemCollection = item_collection;\n        if (!Array.isArray(entries) || typeof total_count !== 'number') {\n            throw getBadItemError();\n        }\n\n        cache.set(childKey, data);\n        item_collection.entries = [childKey].concat(entries);\n        item_collection.total_count = total_count + 1;\n        this.successCallback(data);\n    };\n\n    /**\n     * Does the network request for fetching a folder\n     *\n     * @return {void}\n     */\n    folderCreateRequest(name: string): Promise<void> {\n        if (this.isDestroyed()) {\n            return Promise.reject();\n        }\n\n        this.errorCode = ERROR_CODE_CREATE_FOLDER;\n        const url = `${this.getUrl()}?fields=${FOLDER_FIELDS_TO_FETCH.toString()}`;\n        return this.xhr\n            .post({\n                url,\n                data: {\n                    name,\n                    parent: {\n                        id: this.id,\n                    },\n                },\n            })\n            .then(this.createSuccessHandler)\n            .catch(this.errorHandler);\n    }\n\n    /**\n     * API to create a folder\n     *\n     * @param {string} id - parent folder id\n     * @param {string} name - new folder name\n     * @param {Function} successCallback - success callback\n     * @param {Function} errorCallback - error callback\n     * @return {void}\n     */\n    create(id: string, name: string, successCallback: Function, errorCallback: Function = noop): void {\n        if (this.isDestroyed()) {\n            return;\n        }\n\n        this.id = id;\n        this.key = this.getCacheKey(id);\n        this.successCallback = successCallback;\n        this.errorCallback = errorCallback;\n        this.folderCreateRequest(name);\n    }\n}\n\nexport default Folder;\n"]},"metadata":{},"sourceType":"module"}