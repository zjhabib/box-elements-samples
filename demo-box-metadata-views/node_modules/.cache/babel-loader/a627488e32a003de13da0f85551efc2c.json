{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\n/**\n * \n * @file Utility functions for uploads\n * @author Box\n */\nimport getProp from 'lodash/get';\nvar DEFAULT_API_OPTIONS = {};\n/**\n * Returns true if file contains API options\n *\n * @param {UploadFile | UploadFileWithAPIOptions} item\n * @returns {boolean}\n */\n\nfunction doesFileContainAPIOptions(file) {\n  // $FlowFixMe UploadFileWithAPIOptions has `file` and `options` properties\n  return !!(file.options && file.file);\n}\n/**\n * Returns true if item contains API options\n *\n * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} item\n * @returns {boolean}\n */\n\nfunction doesDataTransferItemContainAPIOptions(item) {\n  // $FlowFixMe UploadDataTransferItemWithAPIOptions has `item` and `options` properties\n  return !!(item.options && item.item);\n}\n/**\n * Converts UploadFile or UploadFileWithAPIOptions to UploadFile\n *\n * @param {UploadFile | UploadFileWithAPIOptions} file\n * @returns {UploadFile}\n */\n\nfunction getFile(file) {\n  if (doesFileContainAPIOptions(file)) {\n    return file.file;\n  }\n  return file;\n}\n/**\n * Converts DataTransferItem or UploadDataTransferItemWithAPIOptions to DataTransferItem\n *\n * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} item\n * @returns {DataTransferItem}\n */\n\nfunction getDataTransferItem(item) {\n  if (doesDataTransferItemContainAPIOptions(item)) {\n    return item.item;\n  }\n  return item;\n}\n/**\n * Get API Options from file\n *\n * @param {UploadFile | UploadFileWithAPIOptions} file\n * @returns {UploadItemAPIOptions}\n */\n\nfunction getFileAPIOptions(file) {\n  if (doesFileContainAPIOptions(file)) {\n    return file.options || DEFAULT_API_OPTIONS;\n  }\n  return DEFAULT_API_OPTIONS;\n}\n/**\n * Get API Options from item\n *\n * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} item\n * @returns {UploadItemAPIOptions}\n */\n\nfunction getDataTransferItemAPIOptions(item) {\n  if (doesDataTransferItemContainAPIOptions(item)) {\n    return item.options || DEFAULT_API_OPTIONS;\n  }\n  return DEFAULT_API_OPTIONS;\n}\n/**\n * Returns true if the given object is a Date instance encoding a valid date\n * (i.e. new Date('this is not a timestamp') should return false).\n *\n * Code adapted from\n * http://stackoverflow.com/questions/1353684/detecting-an-invalid-date-date-instance-in-javascript\n *\n * @param {Date} date\n * @return {boolean}\n */\n\nfunction isValidDateObject(date) {\n  return Object.prototype.toString.call(date) === '[object Date]' && !Number.isNaN(date.getTime());\n}\n/**\n * Remove milliseconds from date time string\n *\n * @param {Date} date\n * @return {string}\n */\n\nfunction toISOStringNoMS(date) {\n  return date.toISOString().replace(/\\.[0-9]{3}/, '');\n}\n/**\n * Returns the file's last modified date as an ISO string with no MS component (e.g.\n * '2017-04-18T17:14:27Z'), or null if no such date can be extracted from the file object.\n * (Nothing on the Internet guarantees that the file object has this info.)\n *\n * @param {UploadFile} file\n * @return {?string}\n */\n\nfunction getFileLastModifiedAsISONoMSIfPossible(file) {\n  // The compatibility chart at https://developer.mozilla.org/en-US/docs/Web/API/File/lastModified#Browser_compatibility\n  // is not up to date as of 12-13-2018. Edge & ie11 do not support lastModified, but support lastModifiedDate.\n  var lastModified = file.lastModified || file.lastModifiedDate;\n  if (lastModified && (typeof lastModified === 'string' || typeof lastModified === 'number' || lastModified instanceof Date)) {\n    var lastModifiedDate = new Date(lastModified);\n    if (isValidDateObject(lastModifiedDate)) {\n      return toISOStringNoMS(lastModifiedDate);\n    }\n  }\n  return null;\n}\n/**\n * If maybeJson is valid JSON string, return the result of calling JSON.parse\n * on it.  Otherwise, return null.\n *\n * @param {string} maybeJson\n * @return {?Object}\n */\n\nfunction tryParseJson(maybeJson) {\n  try {\n    return JSON.parse(maybeJson);\n  } catch (e) {\n    return null;\n  }\n}\n/**\n * Get bounded exponential backoff retry delay\n *\n * @param {number} initialRetryDelay\n * @param {number} maxRetryDelay\n * @param {number} retryNum - Current retry number (first retry will have value of 0).\n * @return {number}\n */\n\nfunction getBoundedExpBackoffRetryDelay(initialRetryDelay, maxRetryDelay, retryNum) {\n  var delay = initialRetryDelay * Math.pow(retryNum, 2);\n  return delay > maxRetryDelay ? maxRetryDelay : delay;\n}\n/**\n * Get entry from dataTransferItem\n *\n * @param {DataTransferItem} item\n * @returns {FileSystemFileEntry}\n */\n\nfunction getEntryFromDataTransferItem(item) {\n  var entry =\n  // $FlowFixMe\n  item.webkitGetAsEntry || item.mozGetAsEntry || item.getAsEntry;\n  return entry.call(item);\n}\n/**\n * Check if a dataTransferItem is a folder\n *\n * @param {UploadDataTransferItemWithAPIOptions | DataTransferItem} itemData\n * @returns {boolean}\n */\n\nfunction isDataTransferItemAFolder(itemData) {\n  var item = getDataTransferItem(itemData);\n  var entry = getEntryFromDataTransferItem(item);\n  if (!entry) {\n    return false;\n  }\n  return entry.isDirectory;\n}\n/**\n * Get file from FileSystemFileEntry\n *\n * @param {FileSystemFileEntry} entry\n * @returns {Promise<UploadFile>}\n */\n\nfunction getFileFromEntry(entry) {\n  return new Promise(function (resolve) {\n    entry.file(function (file) {\n      resolve(file);\n    });\n  });\n}\n/**\n * Get file from DataTransferItem or UploadDataTransferItemWithAPIOptions\n *\n * @param {UploadDataTransferItemWithAPIOptions | DataTransferItem} itemData\n * @returns {Promise<UploadFile | UploadFileWithAPIOptions | null>}\n */\n\nfunction getFileFromDataTransferItem(_x) {\n  return _getFileFromDataTransferItem.apply(this, arguments);\n}\n/**\n * Generates file id based on file properties\n *\n * When folderId or uploadInitTimestamp is missing from file options, file name is returned as file id.\n * Otherwise, fileName_folderId_uploadInitTimestamp is used as file id.\n *\n * @param {UploadFileWithAPIOptions | UploadFile} file\n * @param {string} rootFolderId\n * @returns {string}\n */\n\nfunction _getFileFromDataTransferItem() {\n  _getFileFromDataTransferItem = _asyncToGenerator( /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(itemData) {\n    var item, entry, file;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            item = getDataTransferItem(itemData);\n            entry = getEntryFromDataTransferItem(item);\n            if (entry) {\n              _context.next = 4;\n              break;\n            }\n            return _context.abrupt(\"return\", null);\n          case 4:\n            _context.next = 6;\n            return getFileFromEntry(entry);\n          case 6:\n            file = _context.sent;\n            if (!doesDataTransferItemContainAPIOptions(itemData)) {\n              _context.next = 9;\n              break;\n            }\n            return _context.abrupt(\"return\", {\n              file: file,\n              options: getDataTransferItemAPIOptions(itemData)\n            });\n          case 9:\n            return _context.abrupt(\"return\", file);\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _getFileFromDataTransferItem.apply(this, arguments);\n}\nfunction getFileId(file, rootFolderId) {\n  if (!doesFileContainAPIOptions(file)) {\n    return file.name;\n  }\n  var fileWithOptions = file;\n  var folderId = getProp(fileWithOptions, 'options.folderId', rootFolderId);\n  var uploadInitTimestamp = getProp(fileWithOptions, 'options.uploadInitTimestamp', Date.now());\n  var fileName = fileWithOptions.file.webkitRelativePath || fileWithOptions.file.name;\n  return \"\".concat(fileName, \"_\").concat(folderId, \"_\").concat(uploadInitTimestamp);\n}\n/**\n * Generates item id based on item properties\n *\n * When item options including folderId or uploadInitTimestamp are missing, item name is returned as item id.\n * Otherwise, item properties are used as item id.\n * E.g., folder1_0_123124124\n *\n * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} itemData\n * @param {string} rootFolderId\n * @returns {string}\n */\n\nfunction getDataTransferItemId(itemData, rootFolderId) {\n  var item = getDataTransferItem(itemData);\n  var _getEntryFromDataTran = getEntryFromDataTransferItem(item),\n    name = _getEntryFromDataTran.name;\n  if (!doesDataTransferItemContainAPIOptions(itemData)) {\n    return name;\n  }\n  var _getDataTransferItemA = getDataTransferItemAPIOptions(itemData),\n    _getDataTransferItemA2 = _getDataTransferItemA.folderId,\n    folderId = _getDataTransferItemA2 === void 0 ? rootFolderId : _getDataTransferItemA2,\n    _getDataTransferItemA3 = _getDataTransferItemA.uploadInitTimestamp,\n    uploadInitTimestamp = _getDataTransferItemA3 === void 0 ? Date.now() : _getDataTransferItemA3;\n  return \"\".concat(name, \"_\").concat(folderId, \"_\").concat(uploadInitTimestamp);\n}\n/**\n * Multiput uploads require the use of crypto, which is only supported in secure contexts\n */\n\nfunction isMultiputSupported() {\n  var cryptoObj = window.crypto || window.msCrypto;\n  return window.location.protocol === 'https:' && cryptoObj && cryptoObj.subtle;\n}\nexport { DEFAULT_API_OPTIONS, doesDataTransferItemContainAPIOptions, doesFileContainAPIOptions, getBoundedExpBackoffRetryDelay, getDataTransferItem, getDataTransferItemAPIOptions, getDataTransferItemId, getEntryFromDataTransferItem, getFile, getFileAPIOptions, getFileFromDataTransferItem, getFileFromEntry, getFileId, getFileLastModifiedAsISONoMSIfPossible, isDataTransferItemAFolder, isMultiputSupported, toISOStringNoMS, tryParseJson };","map":{"version":3,"sources":["../../src/utils/uploads.js"],"names":["getProp","DEFAULT_API_OPTIONS","doesFileContainAPIOptions","file","options","doesDataTransferItemContainAPIOptions","item","getFile","getDataTransferItem","getFileAPIOptions","getDataTransferItemAPIOptions","isValidDateObject","date","Object","prototype","toString","call","Number","isNaN","getTime","toISOStringNoMS","toISOString","replace","getFileLastModifiedAsISONoMSIfPossible","lastModified","lastModifiedDate","Date","tryParseJson","maybeJson","JSON","parse","e","getBoundedExpBackoffRetryDelay","initialRetryDelay","maxRetryDelay","retryNum","delay","getEntryFromDataTransferItem","entry","webkitGetAsEntry","mozGetAsEntry","getAsEntry","isDataTransferItemAFolder","itemData","isDirectory","getFileFromEntry","Promise","resolve","getFileFromDataTransferItem","getFileId","rootFolderId","name","fileWithOptions","folderId","uploadInitTimestamp","now","fileName","webkitRelativePath","getDataTransferItemId","isMultiputSupported","cryptoObj","window","crypto","msCrypto","location","protocol","subtle"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Utility functions for uploads\n * @author Box\n */\nimport getProp from 'lodash/get';\n\nimport type {\n    UploadFile,\n    UploadFileWithAPIOptions,\n    UploadDataTransferItemWithAPIOptions,\n    UploadItemAPIOptions,\n    FileSystemFileEntry,\n} from '../common/types/upload';\n\nconst DEFAULT_API_OPTIONS = {};\n\n/**\n * Returns true if file contains API options\n *\n * @param {UploadFile | UploadFileWithAPIOptions} item\n * @returns {boolean}\n */\nfunction doesFileContainAPIOptions(file: UploadFile | UploadFileWithAPIOptions): boolean {\n    // $FlowFixMe UploadFileWithAPIOptions has `file` and `options` properties\n    return !!(file.options && file.file);\n}\n\n/**\n * Returns true if item contains API options\n *\n * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} item\n * @returns {boolean}\n */\nfunction doesDataTransferItemContainAPIOptions(item: DataTransferItem | UploadDataTransferItemWithAPIOptions): boolean {\n    // $FlowFixMe UploadDataTransferItemWithAPIOptions has `item` and `options` properties\n    return !!(item.options && item.item);\n}\n\n/**\n * Converts UploadFile or UploadFileWithAPIOptions to UploadFile\n *\n * @param {UploadFile | UploadFileWithAPIOptions} file\n * @returns {UploadFile}\n */\nfunction getFile(file: UploadFile | UploadFileWithAPIOptions): UploadFile {\n    if (doesFileContainAPIOptions(file)) {\n        return ((file: any): UploadFileWithAPIOptions).file;\n    }\n\n    return ((file: any): UploadFile);\n}\n\n/**\n * Converts DataTransferItem or UploadDataTransferItemWithAPIOptions to DataTransferItem\n *\n * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} item\n * @returns {DataTransferItem}\n */\nfunction getDataTransferItem(item: DataTransferItem | UploadDataTransferItemWithAPIOptions): DataTransferItem {\n    if (doesDataTransferItemContainAPIOptions(item)) {\n        return ((item: any): UploadDataTransferItemWithAPIOptions).item;\n    }\n\n    return ((item: any): DataTransferItem);\n}\n\n/**\n * Get API Options from file\n *\n * @param {UploadFile | UploadFileWithAPIOptions} file\n * @returns {UploadItemAPIOptions}\n */\nfunction getFileAPIOptions(file: UploadFile | UploadFileWithAPIOptions): UploadItemAPIOptions {\n    if (doesFileContainAPIOptions(file)) {\n        return ((file: any): UploadFileWithAPIOptions).options || DEFAULT_API_OPTIONS;\n    }\n\n    return DEFAULT_API_OPTIONS;\n}\n\n/**\n * Get API Options from item\n *\n * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} item\n * @returns {UploadItemAPIOptions}\n */\nfunction getDataTransferItemAPIOptions(\n    item: DataTransferItem | UploadDataTransferItemWithAPIOptions,\n): UploadItemAPIOptions {\n    if (doesDataTransferItemContainAPIOptions(item)) {\n        return ((item: any): UploadDataTransferItemWithAPIOptions).options || DEFAULT_API_OPTIONS;\n    }\n\n    return DEFAULT_API_OPTIONS;\n}\n\n/**\n * Returns true if the given object is a Date instance encoding a valid date\n * (i.e. new Date('this is not a timestamp') should return false).\n *\n * Code adapted from\n * http://stackoverflow.com/questions/1353684/detecting-an-invalid-date-date-instance-in-javascript\n *\n * @param {Date} date\n * @return {boolean}\n */\nfunction isValidDateObject(date: Date): boolean {\n    return Object.prototype.toString.call(date) === '[object Date]' && !Number.isNaN(date.getTime());\n}\n\n/**\n * Remove milliseconds from date time string\n *\n * @param {Date} date\n * @return {string}\n */\nfunction toISOStringNoMS(date: Date): string {\n    return date.toISOString().replace(/\\.[0-9]{3}/, '');\n}\n\n/**\n * Returns the file's last modified date as an ISO string with no MS component (e.g.\n * '2017-04-18T17:14:27Z'), or null if no such date can be extracted from the file object.\n * (Nothing on the Internet guarantees that the file object has this info.)\n *\n * @param {UploadFile} file\n * @return {?string}\n */\nfunction getFileLastModifiedAsISONoMSIfPossible(file: UploadFile): ?string {\n    // The compatibility chart at https://developer.mozilla.org/en-US/docs/Web/API/File/lastModified#Browser_compatibility\n    // is not up to date as of 12-13-2018. Edge & ie11 do not support lastModified, but support lastModifiedDate.\n    const lastModified = file.lastModified || file.lastModifiedDate;\n    if (\n        lastModified &&\n        (typeof lastModified === 'string' || typeof lastModified === 'number' || lastModified instanceof Date)\n    ) {\n        const lastModifiedDate = new Date(lastModified);\n        if (isValidDateObject(lastModifiedDate)) {\n            return toISOStringNoMS(lastModifiedDate);\n        }\n    }\n\n    return null;\n}\n\n/**\n * If maybeJson is valid JSON string, return the result of calling JSON.parse\n * on it.  Otherwise, return null.\n *\n * @param {string} maybeJson\n * @return {?Object}\n */\nfunction tryParseJson(maybeJson: string): ?Object {\n    try {\n        return JSON.parse(maybeJson);\n    } catch (e) {\n        return null;\n    }\n}\n\n/**\n * Get bounded exponential backoff retry delay\n *\n * @param {number} initialRetryDelay\n * @param {number} maxRetryDelay\n * @param {number} retryNum - Current retry number (first retry will have value of 0).\n * @return {number}\n */\nfunction getBoundedExpBackoffRetryDelay(initialRetryDelay: number, maxRetryDelay: number, retryNum: number) {\n    const delay = initialRetryDelay * retryNum ** 2;\n    return delay > maxRetryDelay ? maxRetryDelay : delay;\n}\n\n/**\n * Get entry from dataTransferItem\n *\n * @param {DataTransferItem} item\n * @returns {FileSystemFileEntry}\n */\nfunction getEntryFromDataTransferItem(item: DataTransferItem): FileSystemFileEntry {\n    const entry =\n        // $FlowFixMe\n        item.webkitGetAsEntry || item.mozGetAsEntry || item.getAsEntry;\n\n    return entry.call(item);\n}\n\n/**\n * Check if a dataTransferItem is a folder\n *\n * @param {UploadDataTransferItemWithAPIOptions | DataTransferItem} itemData\n * @returns {boolean}\n */\nfunction isDataTransferItemAFolder(itemData: UploadDataTransferItemWithAPIOptions | DataTransferItem): boolean {\n    const item = getDataTransferItem(itemData);\n    const entry = getEntryFromDataTransferItem(((item: any): DataTransferItem));\n    if (!entry) {\n        return false;\n    }\n\n    return entry.isDirectory;\n}\n\n/**\n * Get file from FileSystemFileEntry\n *\n * @param {FileSystemFileEntry} entry\n * @returns {Promise<UploadFile>}\n */\nfunction getFileFromEntry(entry: FileSystemFileEntry): Promise<UploadFile> {\n    return new Promise(resolve => {\n        entry.file(file => {\n            resolve(file);\n        });\n    });\n}\n\n/**\n * Get file from DataTransferItem or UploadDataTransferItemWithAPIOptions\n *\n * @param {UploadDataTransferItemWithAPIOptions | DataTransferItem} itemData\n * @returns {Promise<UploadFile | UploadFileWithAPIOptions | null>}\n */\nasync function getFileFromDataTransferItem(\n    itemData: UploadDataTransferItemWithAPIOptions | DataTransferItem,\n): Promise<UploadFile | UploadFileWithAPIOptions | null> {\n    const item = getDataTransferItem(itemData);\n    const entry = getEntryFromDataTransferItem(((item: any): DataTransferItem));\n    if (!entry) {\n        return null;\n    }\n\n    const file = await getFileFromEntry(entry);\n\n    if (doesDataTransferItemContainAPIOptions(itemData)) {\n        return {\n            file: ((file: any): UploadFile),\n            options: getDataTransferItemAPIOptions(itemData),\n        };\n    }\n\n    return file;\n}\n\n/**\n * Generates file id based on file properties\n *\n * When folderId or uploadInitTimestamp is missing from file options, file name is returned as file id.\n * Otherwise, fileName_folderId_uploadInitTimestamp is used as file id.\n *\n * @param {UploadFileWithAPIOptions | UploadFile} file\n * @param {string} rootFolderId\n * @returns {string}\n */\nfunction getFileId(file: UploadFileWithAPIOptions | UploadFile, rootFolderId: string): string {\n    if (!doesFileContainAPIOptions(file)) {\n        return ((file: any): UploadFile).name;\n    }\n\n    const fileWithOptions = ((file: any): UploadFileWithAPIOptions);\n    const folderId = getProp(fileWithOptions, 'options.folderId', rootFolderId);\n    const uploadInitTimestamp = getProp(fileWithOptions, 'options.uploadInitTimestamp', Date.now());\n    const fileName = fileWithOptions.file.webkitRelativePath || fileWithOptions.file.name;\n\n    return `${fileName}_${folderId}_${uploadInitTimestamp}`;\n}\n\n/**\n * Generates item id based on item properties\n *\n * When item options including folderId or uploadInitTimestamp are missing, item name is returned as item id.\n * Otherwise, item properties are used as item id.\n * E.g., folder1_0_123124124\n *\n * @param {DataTransferItem | UploadDataTransferItemWithAPIOptions} itemData\n * @param {string} rootFolderId\n * @returns {string}\n */\nfunction getDataTransferItemId(\n    itemData: DataTransferItem | UploadDataTransferItemWithAPIOptions,\n    rootFolderId: string,\n): string {\n    const item = getDataTransferItem(itemData);\n    const { name } = getEntryFromDataTransferItem(item);\n    if (!doesDataTransferItemContainAPIOptions(itemData)) {\n        return name;\n    }\n\n    const { folderId = rootFolderId, uploadInitTimestamp = Date.now() } = getDataTransferItemAPIOptions(itemData);\n\n    return `${name}_${folderId}_${uploadInitTimestamp}`;\n}\n\n/**\n * Multiput uploads require the use of crypto, which is only supported in secure contexts\n */\nfunction isMultiputSupported(): boolean {\n    const cryptoObj = window.crypto || window.msCrypto;\n    return window.location.protocol === 'https:' && cryptoObj && cryptoObj.subtle;\n}\n\nexport {\n    DEFAULT_API_OPTIONS,\n    doesDataTransferItemContainAPIOptions,\n    doesFileContainAPIOptions,\n    getBoundedExpBackoffRetryDelay,\n    getDataTransferItem,\n    getDataTransferItemAPIOptions,\n    getDataTransferItemId,\n    getEntryFromDataTransferItem,\n    getFile,\n    getFileAPIOptions,\n    getFileFromDataTransferItem,\n    getFileFromEntry,\n    getFileId,\n    getFileLastModifiedAsISONoMSIfPossible,\n    isDataTransferItemAFolder,\n    isMultiputSupported,\n    toISOStringNoMS,\n    tryParseJson,\n};\n"]},"metadata":{},"sourceType":"module"}