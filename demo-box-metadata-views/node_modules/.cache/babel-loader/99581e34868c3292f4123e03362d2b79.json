{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Metadata sidebar component\n * @author Box\n */\nimport * as React from 'react';\nimport flow from 'lodash/flow';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport { FormattedMessage } from 'react-intl';\nimport API from '../../api';\nimport EmptyContent from '../../features/metadata-instance-editor/EmptyContent';\nimport InlineError from '../../components/inline-error/InlineError';\nimport Instances from '../../features/metadata-instance-editor/Instances';\nimport LoadingIndicator from '../../components/loading-indicator/LoadingIndicator';\nimport LoadingIndicatorWrapper from '../../components/loading-indicator/LoadingIndicatorWrapper';\nimport messages from '../common/messages';\nimport SidebarContent from './SidebarContent';\nimport TemplateDropdown from '../../features/metadata-instance-editor/TemplateDropdown';\nimport { normalizeTemplates } from '../../features/metadata-instance-editor/metadataUtil';\nimport { EVENT_JS_READY } from '../common/logger/constants';\nimport { isUserCorrectableError } from '../../utils/error';\nimport { mark } from '../../utils/performance';\nimport { withAPIContext } from '../common/api-context';\nimport { withErrorBoundary } from '../common/error-boundary';\nimport { withLogger } from '../common/logger';\nimport { FIELD_IS_EXTERNALLY_OWNED, FIELD_PERMISSIONS, FIELD_PERMISSIONS_CAN_UPLOAD, IS_ERROR_DISPLAYED, ORIGIN_METADATA_SIDEBAR, SIDEBAR_VIEW_METADATA } from '../../constants';\nimport './MetadataSidebar.scss';\nvar MARK_NAME_JS_READY = \"\".concat(ORIGIN_METADATA_SIDEBAR, \"_\").concat(EVENT_JS_READY);\nmark(MARK_NAME_JS_READY);\nvar MetadataSidebar = /*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(MetadataSidebar, _React$PureComponent);\n  function MetadataSidebar(props) {\n    var _this;\n    _classCallCheck(this, MetadataSidebar);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MetadataSidebar).call(this, props));\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      isLoading: false\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onApiError\", function (error, code) {\n      var newState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var onError = _this.props.onError;\n      var status = error.status;\n      var isValidError = isUserCorrectableError(status);\n      _this.setState(_objectSpread({\n        error: messages.sidebarMetadataEditingErrorContent,\n        isLoading: false\n      }, newState));\n      onError(error, code, _defineProperty({\n        error: error\n      }, IS_ERROR_DISPLAYED, isValidError));\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onRemove\", function (id) {\n      var api = _this.props.api;\n      var file = _this.state.file;\n      var editor = _this.getEditor(id);\n      if (!editor || !file) {\n        return;\n      }\n      api.getMetadataAPI(false).deleteMetadata(file, editor.template, function () {\n        return _this.onRemoveSuccessHandler(editor);\n      }, _this.onApiError);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onAddSuccessHandler\", function (editor) {\n      var _this$state$editors = _this.state.editors,\n        editors = _this$state$editors === void 0 ? [] : _this$state$editors;\n      var clone = editors.slice(0);\n      clone.push(editor);\n      _this.setState({\n        editors: clone,\n        isLoading: false\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onAdd\", function (template) {\n      var api = _this.props.api;\n      var file = _this.state.file;\n      if (!file) {\n        return;\n      }\n      _this.setState({\n        isLoading: true\n      });\n      api.getMetadataAPI(false).createMetadata(file, template, _this.onAddSuccessHandler, _this.onApiError);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onSave\", function (id, ops) {\n      var api = _this.props.api;\n      var file = _this.state.file;\n      var oldEditor = _this.getEditor(id);\n      if (!oldEditor || !file) {\n        return;\n      }\n      api.getMetadataAPI(false).updateMetadata(file, oldEditor.template, ops, function (newEditor) {\n        _this.replaceEditor(oldEditor, newEditor);\n      }, function (error, code) {\n        _this.onSaveErrorHandler(oldEditor, error, code);\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onModification\", function (id, isDirty) {\n      var oldEditor = _this.getEditor(id);\n      if (!oldEditor) {\n        return;\n      }\n      var newEditor = _objectSpread({}, oldEditor, {\n        isDirty: isDirty\n      }); // shallow clone suffices for isDirty setting\n\n      _this.replaceEditor(oldEditor, newEditor);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"fetchMetadataErrorCallback\", function (e, code) {\n      _this.onApiError(e, code, {\n        editors: undefined,\n        error: messages.sidebarMetadataFetchingErrorContent,\n        templates: undefined\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"fetchMetadataSuccessCallback\", function (_ref) {\n      var editors = _ref.editors,\n        templates = _ref.templates;\n      var _this$props = _this.props,\n        selectedTemplateKey = _this$props.selectedTemplateKey,\n        templateFilters = _this$props.templateFilters;\n      _this.setState({\n        editors: editors.slice(0),\n        // cloned for potential editing\n        error: undefined,\n        isLoading: false,\n        templates: normalizeTemplates(templates, selectedTemplateKey, templateFilters)\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"fetchFileErrorCallback\", function (e, code) {\n      _this.onApiError(e, code, {\n        error: messages.sidebarFileFetchingErrorContent,\n        file: undefined\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"fetchFileSuccessCallback\", function (file) {\n      var currentFile = _this.state.file;\n      var currentCanUpload = getProp(currentFile, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n      var newCanUpload = getProp(file, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n      var shouldFetchMetadata = !currentFile || currentCanUpload !== newCanUpload;\n      var callback = shouldFetchMetadata ? _this.fetchMetadata : noop;\n      _this.setState({\n        file: file\n      }, callback);\n    });\n    var logger = _this.props.logger;\n    logger.onReadyMetric({\n      endMarkName: MARK_NAME_JS_READY\n    });\n    return _this;\n  }\n  _createClass(MetadataSidebar, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.fetchFile();\n    }\n    /**\n     * Common error callback\n     *\n     * @param {Error} error - API error\n     * @param {string} code - error code\n     * @param {Object} [newState] - optional state to set\n     * @return {void}\n     */\n  }, {\n    key: \"canEdit\",\n    /**\n     * Checks upload permission\n     *\n     * @return {boolean} - true if metadata can be edited\n     */\n    value: function canEdit() {\n      var file = this.state.file;\n      return getProp(file, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n    }\n    /**\n     * Finds the editor we are editing\n     *\n     * @param {number} id - instance id\n     * @return {Object} editor instance\n     */\n  }, {\n    key: \"getEditor\",\n    value: function getEditor(id) {\n      var _this$state$editors2 = this.state.editors,\n        editors = _this$state$editors2 === void 0 ? [] : _this$state$editors2;\n      return editors.find(function (_ref2) {\n        var instance = _ref2.instance;\n        return instance.id === id;\n      });\n    }\n    /**\n     * Instance remove success handler\n     *\n     * @param {Object} editor - the editor to remove\n     * @return {void}\n     */\n  }, {\n    key: \"onRemoveSuccessHandler\",\n    value: function onRemoveSuccessHandler(editor) {\n      var _this$state$editors3 = this.state.editors,\n        editors = _this$state$editors3 === void 0 ? [] : _this$state$editors3;\n      var clone = editors.slice(0);\n      clone.splice(editors.indexOf(editor), 1);\n      this.setState({\n        editors: clone\n      });\n    }\n    /**\n     * Instance remove handler\n     *\n     * @param {string} id - instance id\n     * @return {void}\n     */\n  }, {\n    key: \"replaceEditor\",\n    /**\n     * Instance save success handler\n     *\n     * @param {Object} oldEditor - prior editor\n     * @param {Object} newEditor - updated editor\n     * @return {void}\n     */\n    value: function replaceEditor(oldEditor, newEditor) {\n      var _this$state$editors4 = this.state.editors,\n        editors = _this$state$editors4 === void 0 ? [] : _this$state$editors4;\n      var clone = editors.slice(0);\n      clone.splice(editors.indexOf(oldEditor), 1, newEditor);\n      this.setState({\n        editors: clone\n      });\n    }\n    /**\n     * Instance save error handler\n     *\n     * @param {Object} oldEditor - prior editor\n     * @param {Object} error - api error\n     * @param {string} code - error code\n     * @return {void}\n     */\n  }, {\n    key: \"onSaveErrorHandler\",\n    value: function onSaveErrorHandler(oldEditor, error, code) {\n      var clone = _objectSpread({}, oldEditor, {\n        hasError: true\n      }); // shallow clone suffices for hasError setting\n\n      this.replaceEditor(oldEditor, clone);\n      this.onApiError(error, code);\n    }\n    /**\n     * Instance save handler\n     *\n     * @param {string} id - instance id\n     * @param {Array} ops - json patch ops\n     * @return {void}\n     */\n  }, {\n    key: \"fetchMetadata\",\n    /**\n     * Fetches the metadata editors\n     *\n     * @return {void}\n     */\n    value: function fetchMetadata() {\n      var _this$props2 = this.props,\n        api = _this$props2.api,\n        isFeatureEnabled = _this$props2.isFeatureEnabled;\n      var file = this.state.file;\n      if (!file) {\n        return;\n      }\n      api.getMetadataAPI(false).getMetadata(file, this.fetchMetadataSuccessCallback, this.fetchMetadataErrorCallback, isFeatureEnabled, {\n        refreshCache: true\n      });\n    }\n    /**\n     * Handles a failed file fetch\n     *\n     * @private\n     * @param {Error} e - API error\n     * @param {string} code - error code\n     * @return {void}\n     */\n  }, {\n    key: \"fetchFile\",\n    /**\n     * Fetches a file with the fields needed for metadata sidebar\n     *\n     * @return {void}\n     */\n    value: function fetchFile() {\n      var _this$props3 = this.props,\n        api = _this$props3.api,\n        fileId = _this$props3.fileId;\n      api.getFileAPI().getFile(fileId, this.fetchFileSuccessCallback, this.fetchFileErrorCallback, {\n        fields: [FIELD_IS_EXTERNALLY_OWNED, FIELD_PERMISSIONS],\n        refreshCache: true // see implications in file success callback\n      });\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.fetchMetadata();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state = this.state,\n        editors = _this$state.editors,\n        file = _this$state.file,\n        error = _this$state.error,\n        isLoading = _this$state.isLoading,\n        templates = _this$state.templates;\n      var _this$props4 = this.props,\n        elementId = _this$props4.elementId,\n        selectedTemplateKey = _this$props4.selectedTemplateKey;\n      var showEditor = !!file && !!templates && !!editors;\n      var showLoadingIndicator = !error && !showEditor;\n      var canEdit = this.canEdit();\n      var showTemplateDropdown = showEditor && canEdit;\n      var showEmptyContent = showEditor && editors.length === 0;\n      return React.createElement(SidebarContent, {\n        actions: showTemplateDropdown ? React.createElement(TemplateDropdown, {\n          hasTemplates: templates && templates.length !== 0,\n          isDropdownBusy: false,\n          onAdd: this.onAdd // $FlowFixMe checked via showTemplateDropdown & showEditor\n          ,\n\n          templates: templates // $FlowFixMe checked via showTemplateDropdown & showEditor\n          ,\n\n          usedTemplates: editors.map(function (editor) {\n            return editor.template;\n          })\n        }) : null,\n        className: \"bcs-metadata\",\n        elementId: elementId,\n        sidebarView: SIDEBAR_VIEW_METADATA,\n        title: React.createElement(FormattedMessage, messages.sidebarMetadataTitle)\n      }, error && React.createElement(InlineError, {\n        title: React.createElement(FormattedMessage, messages.error)\n      }, React.createElement(FormattedMessage, error)), showLoadingIndicator && React.createElement(LoadingIndicator, null), showEditor && React.createElement(LoadingIndicatorWrapper, {\n        className: \"metadata-instance-editor\",\n        isLoading: isLoading\n      }, showEmptyContent ? React.createElement(EmptyContent, {\n        canAdd: canEdit\n      }) : React.createElement(Instances, {\n        editors: editors,\n        onModification: this.onModification,\n        onRemove: this.onRemove,\n        onSave: this.onSave,\n        selectedTemplateKey: selectedTemplateKey\n      })));\n    }\n  }]);\n  return MetadataSidebar;\n}(React.PureComponent);\n_defineProperty(MetadataSidebar, \"defaultProps\", {\n  isFeatureEnabled: true\n});\nexport { MetadataSidebar as MetadataSidebarComponent };\nexport default flow([withLogger(ORIGIN_METADATA_SIDEBAR), withErrorBoundary(ORIGIN_METADATA_SIDEBAR), withAPIContext])(MetadataSidebar);","map":{"version":3,"sources":["../../../src/elements/content-sidebar/MetadataSidebar.js"],"names":["React","flow","getProp","noop","FormattedMessage","API","EmptyContent","InlineError","Instances","LoadingIndicator","LoadingIndicatorWrapper","messages","SidebarContent","TemplateDropdown","normalizeTemplates","EVENT_JS_READY","isUserCorrectableError","mark","withAPIContext","withErrorBoundary","withLogger","FIELD_IS_EXTERNALLY_OWNED","FIELD_PERMISSIONS","FIELD_PERMISSIONS_CAN_UPLOAD","IS_ERROR_DISPLAYED","ORIGIN_METADATA_SIDEBAR","SIDEBAR_VIEW_METADATA","MARK_NAME_JS_READY","MetadataSidebar","PureComponent","isLoading","isFeatureEnabled","props","logger","onReadyMetric","endMarkName","fetchFile","error","code","newState","onError","status","isValidError","setState","sidebarMetadataEditingErrorContent","file","state","id","editors","find","instance","editor","clone","slice","splice","indexOf","api","getEditor","getMetadataAPI","deleteMetadata","template","onRemoveSuccessHandler","onApiError","push","createMetadata","onAddSuccessHandler","oldEditor","newEditor","hasError","replaceEditor","ops","updateMetadata","onSaveErrorHandler","isDirty","e","undefined","sidebarMetadataFetchingErrorContent","templates","selectedTemplateKey","templateFilters","getMetadata","fetchMetadataSuccessCallback","fetchMetadataErrorCallback","refreshCache","sidebarFileFetchingErrorContent","currentFile","currentCanUpload","newCanUpload","shouldFetchMetadata","callback","fetchMetadata","fileId","getFileAPI","getFile","fetchFileSuccessCallback","fetchFileErrorCallback","fields","elementId","showEditor","showLoadingIndicator","canEdit","showTemplateDropdown","showEmptyContent","length","onAdd","map","sidebarMetadataTitle","onModification","onRemove","onSave","MetadataSidebarComponent"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Metadata sidebar component\n * @author Box\n */\n\nimport * as React from 'react';\nimport flow from 'lodash/flow';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport { FormattedMessage } from 'react-intl';\nimport type { MessageDescriptor } from 'react-intl';\nimport API from '../../api';\nimport EmptyContent from '../../features/metadata-instance-editor/EmptyContent';\nimport InlineError from '../../components/inline-error/InlineError';\nimport Instances from '../../features/metadata-instance-editor/Instances';\nimport LoadingIndicator from '../../components/loading-indicator/LoadingIndicator';\nimport LoadingIndicatorWrapper from '../../components/loading-indicator/LoadingIndicatorWrapper';\nimport messages from '../common/messages';\nimport SidebarContent from './SidebarContent';\nimport TemplateDropdown from '../../features/metadata-instance-editor/TemplateDropdown';\nimport { normalizeTemplates } from '../../features/metadata-instance-editor/metadataUtil';\nimport { EVENT_JS_READY } from '../common/logger/constants';\nimport { isUserCorrectableError } from '../../utils/error';\nimport { mark } from '../../utils/performance';\nimport { withAPIContext } from '../common/api-context';\nimport { withErrorBoundary } from '../common/error-boundary';\nimport { withLogger } from '../common/logger';\nimport {\n    FIELD_IS_EXTERNALLY_OWNED,\n    FIELD_PERMISSIONS,\n    FIELD_PERMISSIONS_CAN_UPLOAD,\n    IS_ERROR_DISPLAYED,\n    ORIGIN_METADATA_SIDEBAR,\n    SIDEBAR_VIEW_METADATA,\n} from '../../constants';\nimport type { WithLoggerProps } from '../../common/types/logging';\nimport type { ElementsXhrError, ErrorContextProps, JSONPatchOperations } from '../../common/types/api';\nimport type { MetadataEditor, MetadataTemplate } from '../../common/types/metadata';\nimport type { BoxItem } from '../../common/types/core';\nimport './MetadataSidebar.scss';\n\ntype ExternalProps = {\n    isFeatureEnabled: boolean,\n    selectedTemplateKey?: string,\n    templateFilters?: Array<string> | string,\n};\n\ntype PropsWithoutContext = {\n    elementId: string,\n    fileId: string,\n    hasSidebarInitialized?: boolean,\n} & ExternalProps;\n\ntype Props = {\n    api: API,\n} & PropsWithoutContext &\n    ErrorContextProps &\n    WithLoggerProps;\n\ntype State = {\n    editors?: Array<MetadataEditor>,\n    error?: MessageDescriptor,\n    file?: BoxItem,\n    isLoading: boolean,\n    templates?: Array<MetadataTemplate>,\n};\n\nconst MARK_NAME_JS_READY = `${ORIGIN_METADATA_SIDEBAR}_${EVENT_JS_READY}`;\n\nmark(MARK_NAME_JS_READY);\n\nclass MetadataSidebar extends React.PureComponent<Props, State> {\n    state = { isLoading: false };\n\n    static defaultProps = {\n        isFeatureEnabled: true,\n    };\n\n    constructor(props: Props) {\n        super(props);\n        const { logger } = this.props;\n        logger.onReadyMetric({\n            endMarkName: MARK_NAME_JS_READY,\n        });\n    }\n\n    componentDidMount() {\n        this.fetchFile();\n    }\n\n    /**\n     * Common error callback\n     *\n     * @param {Error} error - API error\n     * @param {string} code - error code\n     * @param {Object} [newState] - optional state to set\n     * @return {void}\n     */\n    onApiError = (error: ElementsXhrError, code: string, newState: Object = {}) => {\n        const { onError }: Props = this.props;\n        const { status } = error;\n        const isValidError = isUserCorrectableError(status);\n        this.setState({\n            error: messages.sidebarMetadataEditingErrorContent,\n            isLoading: false,\n            ...newState,\n        });\n        onError(error, code, {\n            error,\n            [IS_ERROR_DISPLAYED]: isValidError,\n        });\n    };\n\n    /**\n     * Checks upload permission\n     *\n     * @return {boolean} - true if metadata can be edited\n     */\n    canEdit(): boolean {\n        const { file }: State = this.state;\n        return getProp(file, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n    }\n\n    /**\n     * Finds the editor we are editing\n     *\n     * @param {number} id - instance id\n     * @return {Object} editor instance\n     */\n    getEditor(id: string): ?MetadataEditor {\n        const { editors = [] }: State = this.state;\n        return editors.find(({ instance }) => instance.id === id);\n    }\n\n    /**\n     * Instance remove success handler\n     *\n     * @param {Object} editor - the editor to remove\n     * @return {void}\n     */\n    onRemoveSuccessHandler(editor: MetadataEditor): void {\n        const { editors = [] }: State = this.state;\n        const clone = editors.slice(0);\n        clone.splice(editors.indexOf(editor), 1);\n        this.setState({ editors: clone });\n    }\n\n    /**\n     * Instance remove handler\n     *\n     * @param {string} id - instance id\n     * @return {void}\n     */\n    onRemove = (id: string): void => {\n        const { api }: Props = this.props;\n        const { file }: State = this.state;\n        const editor = this.getEditor(id);\n\n        if (!editor || !file) {\n            return;\n        }\n\n        api.getMetadataAPI(false).deleteMetadata(\n            file,\n            editor.template,\n            () => this.onRemoveSuccessHandler(editor),\n            this.onApiError,\n        );\n    };\n\n    /**\n     * Instance add success handler\n     *\n     * @param {Object} editor - instance editor\n     * @return {void}\n     */\n    onAddSuccessHandler = (editor: MetadataEditor): void => {\n        const { editors = [] }: State = this.state;\n        const clone = editors.slice(0);\n        clone.push(editor);\n        this.setState({ editors: clone, isLoading: false });\n    };\n\n    /**\n     * Instance add handler\n     *\n     * @param {Object} template - instance template\n     * @return {void}\n     */\n    onAdd = (template: MetadataTemplate) => {\n        const { api }: Props = this.props;\n        const { file }: State = this.state;\n\n        if (!file) {\n            return;\n        }\n\n        this.setState({ isLoading: true });\n        api.getMetadataAPI(false).createMetadata(file, template, this.onAddSuccessHandler, this.onApiError);\n    };\n\n    /**\n     * Instance save success handler\n     *\n     * @param {Object} oldEditor - prior editor\n     * @param {Object} newEditor - updated editor\n     * @return {void}\n     */\n    replaceEditor(oldEditor: MetadataEditor, newEditor: MetadataEditor): void {\n        const { editors = [] }: State = this.state;\n        const clone = editors.slice(0);\n        clone.splice(editors.indexOf(oldEditor), 1, newEditor);\n        this.setState({ editors: clone });\n    }\n\n    /**\n     * Instance save error handler\n     *\n     * @param {Object} oldEditor - prior editor\n     * @param {Object} error - api error\n     * @param {string} code - error code\n     * @return {void}\n     */\n    onSaveErrorHandler(oldEditor: MetadataEditor, error: ElementsXhrError, code: string): void {\n        const clone: MetadataEditor = { ...oldEditor, hasError: true }; // shallow clone suffices for hasError setting\n        this.replaceEditor(oldEditor, clone);\n        this.onApiError(error, code);\n    }\n\n    /**\n     * Instance save handler\n     *\n     * @param {string} id - instance id\n     * @param {Array} ops - json patch ops\n     * @return {void}\n     */\n    onSave = (id: string, ops: JSONPatchOperations): void => {\n        const { api }: Props = this.props;\n        const { file }: State = this.state;\n        const oldEditor = this.getEditor(id);\n\n        if (!oldEditor || !file) {\n            return;\n        }\n\n        api.getMetadataAPI(false).updateMetadata(\n            file,\n            oldEditor.template,\n            ops,\n            (newEditor: MetadataEditor) => {\n                this.replaceEditor(oldEditor, newEditor);\n            },\n            (error: ElementsXhrError, code: string) => {\n                this.onSaveErrorHandler(oldEditor, error, code);\n            },\n        );\n    };\n\n    /**\n     * Instance dirty handler\n     *\n     * @param {string} id - instance id\n     * @param {boolean} isDirty - instance dirty state\n     * @return {void}\n     */\n    onModification = (id: string, isDirty: boolean) => {\n        const oldEditor = this.getEditor(id);\n        if (!oldEditor) {\n            return;\n        }\n        const newEditor = { ...oldEditor, isDirty }; // shallow clone suffices for isDirty setting\n        this.replaceEditor(oldEditor, newEditor);\n    };\n\n    /**\n     * Handles a failed metadata fetch\n     *\n     * @private\n     * @param {Error} e - API error\n     * @param {string} code - error code\n     * @return {void}\n     */\n    fetchMetadataErrorCallback = (e: ElementsXhrError, code: string) => {\n        this.onApiError(e, code, {\n            editors: undefined,\n            error: messages.sidebarMetadataFetchingErrorContent,\n            templates: undefined,\n        });\n    };\n\n    /**\n     * Handles a successful metadata fetch\n     *\n     * @param {Object} metadata - instances and templates\n     * @return {void}\n     */\n    fetchMetadataSuccessCallback = ({\n        editors,\n        templates,\n    }: {\n        editors: Array<MetadataEditor>,\n        templates: Array<MetadataTemplate>,\n    }) => {\n        const { selectedTemplateKey, templateFilters } = this.props;\n        this.setState({\n            editors: editors.slice(0), // cloned for potential editing\n            error: undefined,\n            isLoading: false,\n            templates: normalizeTemplates(templates, selectedTemplateKey, templateFilters),\n        });\n    };\n\n    /**\n     * Fetches the metadata editors\n     *\n     * @return {void}\n     */\n    fetchMetadata(): void {\n        const { api, isFeatureEnabled }: Props = this.props;\n        const { file }: State = this.state;\n\n        if (!file) {\n            return;\n        }\n\n        api.getMetadataAPI(false).getMetadata(\n            file,\n            this.fetchMetadataSuccessCallback,\n            this.fetchMetadataErrorCallback,\n            isFeatureEnabled,\n            { refreshCache: true },\n        );\n    }\n\n    /**\n     * Handles a failed file fetch\n     *\n     * @private\n     * @param {Error} e - API error\n     * @param {string} code - error code\n     * @return {void}\n     */\n    fetchFileErrorCallback = (e: ElementsXhrError, code: string) => {\n        this.onApiError(e, code, { error: messages.sidebarFileFetchingErrorContent, file: undefined });\n    };\n\n    /**\n     * Handles a successful file fetch.\n     * Can be called multiple times when refreshing caches.\n     * On file load we should fetch metadata, but we shouldn't need to fetch\n     * if the file permissions haven't changed from a prior file fetch.\n     * Metadata editors mostly care about upload permission.\n     *\n     * @param {Object} file - the Box file\n     * @return {void}\n     */\n    fetchFileSuccessCallback = (file: BoxItem) => {\n        const { file: currentFile }: State = this.state;\n        const currentCanUpload = getProp(currentFile, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n        const newCanUpload = getProp(file, FIELD_PERMISSIONS_CAN_UPLOAD, false);\n        const shouldFetchMetadata = !currentFile || currentCanUpload !== newCanUpload;\n        const callback = shouldFetchMetadata ? this.fetchMetadata : noop;\n        this.setState({ file }, callback);\n    };\n\n    /**\n     * Fetches a file with the fields needed for metadata sidebar\n     *\n     * @return {void}\n     */\n    fetchFile(): void {\n        const { api, fileId }: Props = this.props;\n        api.getFileAPI().getFile(fileId, this.fetchFileSuccessCallback, this.fetchFileErrorCallback, {\n            fields: [FIELD_IS_EXTERNALLY_OWNED, FIELD_PERMISSIONS],\n            refreshCache: true, // see implications in file success callback\n        });\n    }\n\n    refresh(): void {\n        this.fetchMetadata();\n    }\n\n    render() {\n        const { editors, file, error, isLoading, templates }: State = this.state;\n        const { elementId, selectedTemplateKey }: Props = this.props;\n        const showEditor = !!file && !!templates && !!editors;\n        const showLoadingIndicator = !error && !showEditor;\n        const canEdit = this.canEdit();\n        const showTemplateDropdown = showEditor && canEdit;\n        const showEmptyContent = showEditor && ((editors: any): Array<MetadataEditor>).length === 0;\n\n        return (\n            <SidebarContent\n                actions={\n                    showTemplateDropdown ? (\n                        <TemplateDropdown\n                            hasTemplates={templates && templates.length !== 0}\n                            isDropdownBusy={false}\n                            onAdd={this.onAdd}\n                            // $FlowFixMe checked via showTemplateDropdown & showEditor\n                            templates={templates}\n                            // $FlowFixMe checked via showTemplateDropdown & showEditor\n                            usedTemplates={editors.map(editor => editor.template)}\n                        />\n                    ) : null\n                }\n                className=\"bcs-metadata\"\n                elementId={elementId}\n                sidebarView={SIDEBAR_VIEW_METADATA}\n                title={<FormattedMessage {...messages.sidebarMetadataTitle} />}\n            >\n                {error && (\n                    <InlineError title={<FormattedMessage {...messages.error} />}>\n                        <FormattedMessage {...error} />\n                    </InlineError>\n                )}\n                {showLoadingIndicator && <LoadingIndicator />}\n                {showEditor && (\n                    <LoadingIndicatorWrapper className=\"metadata-instance-editor\" isLoading={isLoading}>\n                        {showEmptyContent ? (\n                            <EmptyContent canAdd={canEdit} />\n                        ) : (\n                            <Instances\n                                editors={editors}\n                                onModification={this.onModification}\n                                onRemove={this.onRemove}\n                                onSave={this.onSave}\n                                selectedTemplateKey={selectedTemplateKey}\n                            />\n                        )}\n                    </LoadingIndicatorWrapper>\n                )}\n            </SidebarContent>\n        );\n    }\n}\n\nexport type MetadataSidebarProps = ExternalProps;\nexport { MetadataSidebar as MetadataSidebarComponent };\nexport default flow([withLogger(ORIGIN_METADATA_SIDEBAR), withErrorBoundary(ORIGIN_METADATA_SIDEBAR), withAPIContext])(\n    MetadataSidebar,\n);\n"]},"metadata":{},"sourceType":"module"}