{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * \n * @file An example of a token managing service\n * @author Box\n */\nimport { TYPED_ID_FOLDER_PREFIX, TYPED_ID_FILE_PREFIX } from '../constants';\nvar error = new Error('Bad id or auth token. ID should be typed id like file_123 or folder_123! Token should be a string or function.');\nvar TokenService = /*#__PURE__*/\nfunction () {\n  function TokenService() {\n    _classCallCheck(this, TokenService);\n  }\n  _createClass(TokenService, null, [{\n    key: \"getToken\",\n    /**\n     * Function to fetch a single token. The user supplied token can either\n     * itself be a simple token or instead be a function that returns a promise.\n     * This promise then resolves to either a string/null/undefined token or\n     * a read/write token pair.\n     *\n     * @private\n     * @param {string} id - box item typed id\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    value: function () {\n      var _getToken = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(id, tokenOrTokenFunction) {\n        var token;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(tokenOrTokenFunction !== null && tokenOrTokenFunction !== undefined && typeof tokenOrTokenFunction !== 'string' && typeof tokenOrTokenFunction !== 'function' || !id.startsWith(TYPED_ID_FOLDER_PREFIX) && !id.startsWith(TYPED_ID_FILE_PREFIX))) {\n                  _context.next = 2;\n                  break;\n                }\n                throw error;\n              case 2:\n                if (!(!tokenOrTokenFunction || typeof tokenOrTokenFunction === 'string')) {\n                  _context.next = 4;\n                  break;\n                }\n                return _context.abrupt(\"return\", tokenOrTokenFunction);\n              case 4:\n                _context.next = 6;\n                return tokenOrTokenFunction(id);\n              case 6:\n                token = _context.sent;\n                if (!(!token || typeof token === 'string' || _typeof(token) === 'object' && (token.read || token.write))) {\n                  _context.next = 9;\n                  break;\n                }\n                return _context.abrupt(\"return\", token);\n              case 9:\n                throw error;\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      function getToken(_x, _x2) {\n        return _getToken.apply(this, arguments);\n      }\n      return getToken;\n    }()\n    /**\n     * Gets a string read token.\n     * Defaults to a simple token string.\n     *\n     * @public\n     * @param {string} id - box item typed id\n     * @param {Token} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n  }, {\n    key: \"getReadToken\",\n    value: function () {\n      var _getReadToken = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(id, tokenOrTokenFunction) {\n        var token;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return TokenService.getToken(id, tokenOrTokenFunction);\n              case 2:\n                token = _context2.sent;\n                if (!(token && _typeof(token) === 'object')) {\n                  _context2.next = 5;\n                  break;\n                }\n                return _context2.abrupt(\"return\", token.read);\n              case 5:\n                return _context2.abrupt(\"return\", token);\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n      function getReadToken(_x3, _x4) {\n        return _getReadToken.apply(this, arguments);\n      }\n      return getReadToken;\n    }()\n    /**\n     * Gets read tokens.\n     *\n     * @public\n     * @param {string|string[]} id - box item typed id(s)\n     * @param {Token} tokenOrTokenFunction - Token to use or token generation function\n     * @return {Promise} Promise that resolves with id to token map\n     */\n  }, {\n    key: \"getReadTokens\",\n    value: function () {\n      var _getReadTokens = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(id, tokenOrTokenFunction) {\n        var ids, promises, tokens, tokenMap;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                ids = Array.isArray(id) ? id : [id];\n                promises = ids.map(function (typedId) {\n                  return TokenService.getReadToken(typedId, tokenOrTokenFunction);\n                });\n                _context3.next = 4;\n                return Promise.all(promises);\n              case 4:\n                tokens = _context3.sent;\n                tokenMap = {};\n                tokens.forEach(function (token, index) {\n                  tokenMap[ids[index]] = token;\n                });\n                return _context3.abrupt(\"return\", Promise.resolve(tokenMap));\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      function getReadTokens(_x5, _x6) {\n        return _getReadTokens.apply(this, arguments);\n      }\n      return getReadTokens;\n    }()\n    /**\n     * Gets a string write token.\n     * Defaults to either the read token or a simple token string.\n     *\n     * @public\n     * @param {string} id - box item typed id\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n  }, {\n    key: \"getWriteToken\",\n    value: function () {\n      var _getWriteToken = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(id, tokenOrTokenFunction) {\n        var token;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return TokenService.getToken(id, tokenOrTokenFunction);\n              case 2:\n                token = _context4.sent;\n                if (!(token && _typeof(token) === 'object')) {\n                  _context4.next = 5;\n                  break;\n                }\n                return _context4.abrupt(\"return\", token.write || token.read);\n              case 5:\n                return _context4.abrupt(\"return\", token);\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      function getWriteToken(_x7, _x8) {\n        return _getWriteToken.apply(this, arguments);\n      }\n      return getWriteToken;\n    }()\n    /**\n     * Function to fetch and cache multiple tokens. The user supplied token can either\n     * itself be a simple token or instead be a function that returns a promise.\n     * This promise then resolves signifying requested tokens were cached.\n     *\n     * This function however does not return tokens as it is expected to only be used\n     * by the token generator to cache all tokens that may be needed in the future.\n     *\n     * @public\n     * @param {Array<string>} idd - box item typed ids\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise<TokenMap>} that resolves to a token map\n     */\n  }, {\n    key: \"cacheTokens\",\n    value: function () {\n      var _cacheTokens = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(ids, tokenOrTokenFunction) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(tokenOrTokenFunction !== null && tokenOrTokenFunction !== undefined && typeof tokenOrTokenFunction !== 'string' && typeof tokenOrTokenFunction !== 'function' || !ids.every(function (itemId) {\n                  return itemId.startsWith(TYPED_ID_FOLDER_PREFIX) || itemId.startsWith(TYPED_ID_FILE_PREFIX);\n                }))) {\n                  _context5.next = 2;\n                  break;\n                }\n                throw error;\n              case 2:\n                if (!(typeof tokenOrTokenFunction === 'function')) {\n                  _context5.next = 5;\n                  break;\n                }\n                _context5.next = 5;\n                return tokenOrTokenFunction(ids);\n              case 5:\n                return _context5.abrupt(\"return\", Promise.resolve());\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n      function cacheTokens(_x9, _x10) {\n        return _cacheTokens.apply(this, arguments);\n      }\n      return cacheTokens;\n    }()\n  }]);\n  return TokenService;\n}();\nexport default TokenService;","map":{"version":3,"sources":["../../src/utils/TokenService.js"],"names":["TYPED_ID_FOLDER_PREFIX","TYPED_ID_FILE_PREFIX","error","Error","TokenService","id","tokenOrTokenFunction","undefined","startsWith","token","read","write","getToken","ids","Array","isArray","promises","map","typedId","getReadToken","tokens","Promise","all","tokenMap","forEach","index","resolve","every","itemId"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAMA,SAASA,sBAAT,EAAiCC,oBAAjC,QAA6D,cAA7D;AAGA,IAAMC,KAAK,GAAG,IAAIC,KAAJ,CACV,gHADU,CAAd;IAIMC,Y;;;;;;;IACF;;;;;;;;;;;;;gDAWsBC,E,EAAYC,oB;;;;;;sBAKzBA,oBAAoB,KAAK,IAAzBA,IACGA,oBAAoB,KAAKC,SAD5BD,IAEG,OAAOA,oBAAP,KAAgC,QAFnCA,IAGG,OAAOA,oBAAP,KAAgC,UAHpC,IAIC,CAACD,EAAE,CAACG,UAAHH,CAAcL,sBAAdK,CAAD,IAA0C,CAACA,EAAE,CAACG,UAAHH,CAAcJ,oBAAdI,C;;;;sBAEtCH,K;;sBAIN,CAACI,oBAAD,IAAyB,OAAOA,oBAAP,KAAgC,Q;;;;iDAClDA,oB;;;uBAKSA,oBAAoB,CAACD,EAAD,C;;gBAAlCI,K;sBACF,CAACA,KAAD,IAAU,OAAOA,KAAP,KAAiB,QAA3B,IAAwC,OAAA,CAAOA,KAAP,CAAA,KAAiB,QAAjB,KAA8BA,KAAK,CAACC,IAAND,IAAcA,KAAK,CAACE,KAAlD,C;;;;iDACjCF,K;;sBAGLP,K;;;;;;;;;;;;;IAGV;;;;;;;;;;;;;iDAS0BG,E,EAAYC,oB;;;;;;;uBACAF,YAAY,CAACQ,QAAbR,CAAsBC,EAAtBD,EAA0BE,oBAA1BF,C;;gBAA5BK,K;sBACFA,KAAK,IAAI,OAAA,CAAOA,KAAP,CAAA,KAAiB,Q;;;;kDACnBA,KAAK,CAACC,I;;kDAGVD,K;;;;;;;;;;;;;IAGX;;;;;;;;;;;;iDAQ2BJ,E,EAAuBC,oB;;;;;;gBACxCO,G,GAAgBC,KAAK,CAACC,OAAND,CAAcT,EAAdS,CAAAA,GAAoBT,EAApBS,GAAyB,CAACT,EAAD,C;gBACzCW,Q,GAA+B,GAAG,CAACC,GAAJ,CAAQ,UAACC,OAAD,EAAA;kBAAA,OACzCd,YAAY,CAACe,YAAbf,CAA0Bc,OAA1Bd,EAAmCE,oBAAnCF,CADyC;gBAAA,CAAR,C;;uBAGHiB,OAAO,CAACC,GAARD,CAAYL,QAAZK,C;;gBAA5BD,M;gBACAG,Q,GAAW,CAAA,C;gBACjBH,MAAM,CAACI,OAAPJ,CAAe,UAACX,KAAD,EAAQgB,KAAR,EAAkB;kBAC7BF,QAAQ,CAACV,GAAG,CAACY,KAAD,CAAJ,CAARF,GAAuBd,KAAvBc;gBACH,CAFDH,CAAAA;kDAGOC,OAAO,CAACK,OAARL,CAAgBE,QAAhBF,C;;;;;;;;;;;;;IAGX;;;;;;;;;;;;;iDAS2BhB,E,EAAYC,oB;;;;;;;uBACDF,YAAY,CAACQ,QAAbR,CAAsBC,EAAtBD,EAA0BE,oBAA1BF,C;;gBAA5BK,K;sBACFA,KAAK,IAAI,OAAA,CAAOA,KAAP,CAAA,KAAiB,Q;;;;kDACnBA,KAAK,CAACE,KAANF,IAAeA,KAAK,CAACC,I;;kDAGzBD,K;;;;;;;;;;;;;IAGX;;;;;;;;;;;;;;;;;iDAayBI,G,EAAoBP,oB;;;;;sBAKpCA,oBAAoB,KAAK,IAAzBA,IACGA,oBAAoB,KAAKC,SAD5BD,IAEG,OAAOA,oBAAP,KAAgC,QAFnCA,IAGG,OAAOA,oBAAP,KAAgC,UAHpC,IAIA,CAAC,GAAG,CAACqB,KAAJ,CAAU,UAAA,MAAM,EAAA;kBAAA,OAAIC,MAAM,CAACpB,UAAPoB,CAAkB5B,sBAAlB4B,CAAAA,IAA6CA,MAAM,CAACpB,UAAPoB,CAAkB3B,oBAAlB2B,CAAjD;gBAAA,CAAhB,C;;;;sBAEK1B,K;;sBAKN,OAAOI,oBAAP,KAAgC,U;;;;;uBAC1BA,oBAAoB,CAACO,GAAD,C;;kDAGvBQ,OAAO,CAACK,OAARL,CAAAA,C;;;;;;;;;;;;;;;;AAIf,eAAejB,YAAf","sourcesContent":["/**\n * @flow\n * @file An example of a token managing service\n * @author Box\n */\n\nimport { TYPED_ID_FOLDER_PREFIX, TYPED_ID_FILE_PREFIX } from '../constants';\nimport type { Token, TokenLiteral } from '../common/types/core';\n\nconst error = new Error(\n    'Bad id or auth token. ID should be typed id like file_123 or folder_123! Token should be a string or function.',\n);\n\nclass TokenService {\n    /**\n     * Function to fetch a single token. The user supplied token can either\n     * itself be a simple token or instead be a function that returns a promise.\n     * This promise then resolves to either a string/null/undefined token or\n     * a read/write token pair.\n     *\n     * @private\n     * @param {string} id - box item typed id\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        // Make sure we are getting typed ids\n        // Tokens should either be null or undefined or string or functions\n        // Anything else is not supported and throw error\n        if (\n            (tokenOrTokenFunction !== null &&\n                tokenOrTokenFunction !== undefined &&\n                typeof tokenOrTokenFunction !== 'string' &&\n                typeof tokenOrTokenFunction !== 'function') ||\n            (!id.startsWith(TYPED_ID_FOLDER_PREFIX) && !id.startsWith(TYPED_ID_FILE_PREFIX))\n        ) {\n            throw error;\n        }\n\n        // Token is a simple string or null or undefined\n        if (!tokenOrTokenFunction || typeof tokenOrTokenFunction === 'string') {\n            return tokenOrTokenFunction;\n        }\n\n        // Token is a function which returns a promise.\n        // Promise on resolution returns a string/null/undefined token or token pair.\n        const token = await tokenOrTokenFunction(id);\n        if (!token || typeof token === 'string' || (typeof token === 'object' && (token.read || token.write))) {\n            return token;\n        }\n\n        throw error;\n    }\n\n    /**\n     * Gets a string read token.\n     * Defaults to a simple token string.\n     *\n     * @public\n     * @param {string} id - box item typed id\n     * @param {Token} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getReadToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        const token: TokenLiteral = await TokenService.getToken(id, tokenOrTokenFunction);\n        if (token && typeof token === 'object') {\n            return token.read;\n        }\n\n        return token;\n    }\n\n    /**\n     * Gets read tokens.\n     *\n     * @public\n     * @param {string|string[]} id - box item typed id(s)\n     * @param {Token} tokenOrTokenFunction - Token to use or token generation function\n     * @return {Promise} Promise that resolves with id to token map\n     */\n    static async getReadTokens(id: string | string[], tokenOrTokenFunction: Token): Promise<Object> {\n        const ids: string[] = Array.isArray(id) ? id : [id];\n        const promises: Promise<?string>[] = ids.map((typedId: string) =>\n            TokenService.getReadToken(typedId, tokenOrTokenFunction),\n        );\n        const tokens: (?string)[] = await Promise.all(promises);\n        const tokenMap = {};\n        tokens.forEach((token, index) => {\n            tokenMap[ids[index]] = token;\n        });\n        return Promise.resolve(tokenMap);\n    }\n\n    /**\n     * Gets a string write token.\n     * Defaults to either the read token or a simple token string.\n     *\n     * @public\n     * @param {string} id - box item typed id\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise} that resolves to a token\n     */\n    static async getWriteToken(id: string, tokenOrTokenFunction: Token): Promise<?string> {\n        const token: TokenLiteral = await TokenService.getToken(id, tokenOrTokenFunction);\n        if (token && typeof token === 'object') {\n            return token.write || token.read;\n        }\n\n        return token;\n    }\n\n    /**\n     * Function to fetch and cache multiple tokens. The user supplied token can either\n     * itself be a simple token or instead be a function that returns a promise.\n     * This promise then resolves signifying requested tokens were cached.\n     *\n     * This function however does not return tokens as it is expected to only be used\n     * by the token generator to cache all tokens that may be needed in the future.\n     *\n     * @public\n     * @param {Array<string>} idd - box item typed ids\n     * @param {string} tokenOrTokenFunction - Optional token or token function\n     * @return {Promise<TokenMap>} that resolves to a token map\n     */\n    static async cacheTokens(ids: Array<string>, tokenOrTokenFunction: Token): Promise<void> {\n        // Make sure we are getting typed ids\n        // Tokens should either be null or undefined or string or functions\n        // Anything else is not supported and throw error\n        if (\n            (tokenOrTokenFunction !== null &&\n                tokenOrTokenFunction !== undefined &&\n                typeof tokenOrTokenFunction !== 'string' &&\n                typeof tokenOrTokenFunction !== 'function') ||\n            !ids.every(itemId => itemId.startsWith(TYPED_ID_FOLDER_PREFIX) || itemId.startsWith(TYPED_ID_FILE_PREFIX))\n        ) {\n            throw error;\n        }\n\n        // Only need to fetch and cache multiple tokens when the user supplied token was a\n        // token function. This function should internally cache the tokens for future use.\n        if (typeof tokenOrTokenFunction === 'function') {\n            await tokenOrTokenFunction(ids);\n        }\n\n        return Promise.resolve();\n    }\n}\n\nexport default TokenService;\n"]},"metadata":{},"sourceType":"module"}