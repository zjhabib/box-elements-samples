{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Recursively create folder and upload files\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport { getFileFromEntry } from '../../utils/uploads';\nimport FolderAPI from '../Folder';\nimport { STATUS_COMPLETE, STATUS_ERROR, ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED, ERROR_CODE_ITEM_NAME_IN_USE } from '../../constants';\nvar FolderUploadNode = /*#__PURE__*/\nfunction () {\n  /**\n   * [constructor]\n   *\n   * @param {string} name\n   * @param {Function} addFilesToUploadQueue\n   * @param {Function} addFolderToUploadQueue\n   * @returns {void}\n   */\n  function FolderUploadNode(_name, addFilesToUploadQueue, addFolderToUploadQueue, fileAPIOptions, baseAPIOptions, _entry) {\n    var _this = this;\n    _classCallCheck(this, FolderUploadNode);\n    _defineProperty(this, \"files\", []);\n    _defineProperty(this, \"folders\", {});\n    _defineProperty(this, \"uploadChildFolders\", /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(errorCallback) {\n        var folders, promises;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // $FlowFixMe\n                folders = Object.values(_this.folders);\n                promises = folders.map(function (folder) {\n                  return folder.upload(_this.folderId, errorCallback);\n                });\n                _context.next = 4;\n                return Promise.all(promises);\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    _defineProperty(this, \"createAndUploadFolder\", /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(errorCallback, isRoot) {\n        var errorEncountered, errorCode, data, folderObject;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _this.buildCurrentFolderFromEntry();\n              case 2:\n                errorEncountered = false;\n                errorCode = '';\n                _context2.prev = 4;\n                _context2.next = 7;\n                return _this.createFolder();\n              case 7:\n                data = _context2.sent;\n                _this.folderId = data.id;\n                _context2.next = 14;\n                break;\n              case 11:\n                _context2.prev = 11;\n                _context2.t0 = _context2[\"catch\"](4);\n\n                // @TODO: Handle 429\n                if (_context2.t0.code === ERROR_CODE_ITEM_NAME_IN_USE) {\n                  _this.folderId = _context2.t0.context_info.conflicts[0].id;\n                } else if (isRoot) {\n                  errorCallback(_context2.t0);\n                } else {\n                  // If this is a child folder of the folder being uploaded, this errorCallback will set\n                  // an error message on the root folder being uploaded. Set a generic messages saying that a\n                  // child has caused the error. The child folder will be tagged with the error message in\n                  // the call to this.addFolderToUploadQueue below\n                  errorEncountered = true;\n                  errorCode = _context2.t0.code;\n                  errorCallback({\n                    code: ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED\n                  });\n                }\n              case 14:\n                if (!isRoot) {\n                  _context2.next = 16;\n                  break;\n                }\n                return _context2.abrupt(\"return\");\n              case 16:\n                folderObject = {\n                  extension: '',\n                  name: _this.name,\n                  status: STATUS_COMPLETE,\n                  isFolder: true,\n                  size: 1,\n                  progress: 100\n                };\n                if (errorEncountered) {\n                  folderObject.status = STATUS_ERROR;\n                  folderObject.error = {\n                    code: errorCode\n                  };\n                }\n                _this.addFolderToUploadQueue(folderObject);\n              case 19:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[4, 11]]);\n      }));\n      return function (_x2, _x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    _defineProperty(this, \"getFormattedFiles\", function () {\n      return _this.files.map(function (file) {\n        return {\n          file: file,\n          options: _objectSpread({}, _this.fileAPIOptions, {\n            folderId: _this.folderId,\n            uploadInitTimestamp: Date.now()\n          })\n        };\n      });\n    });\n    _defineProperty(this, \"createFolderUploadNodesFromEntries\", /*#__PURE__*/\n    function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(entries) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return Promise.all(entries.map( /*#__PURE__*/\n                function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee3(entry) {\n                    var isFile, name, file;\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            isFile = entry.isFile, name = entry.name;\n                            if (!isFile) {\n                              _context3.next = 7;\n                              break;\n                            }\n                            _context3.next = 4;\n                            return getFileFromEntry(entry);\n                          case 4:\n                            file = _context3.sent;\n                            _this.files.push(file);\n                            return _context3.abrupt(\"return\");\n                          case 7:\n                            _this.folders[name] = new FolderUploadNode(name, _this.addFilesToUploadQueue, _this.addFolderToUploadQueue, _this.fileAPIOptions, _objectSpread({}, _this.baseAPIOptions, {}, _this.fileAPIOptions), entry);\n                          case 8:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n                  return function (_x5) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }()));\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n      return function (_x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }());\n    _defineProperty(this, \"readEntry\", function (reader, resolve) {\n      reader.readEntries( /*#__PURE__*/\n      function () {\n        var _ref5 = _asyncToGenerator( /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee5(entries) {\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  if (entries.length) {\n                    _context5.next = 3;\n                    break;\n                  }\n                  resolve();\n                  return _context5.abrupt(\"return\");\n                case 3:\n                  _context5.next = 5;\n                  return _this.createFolderUploadNodesFromEntries(entries);\n                case 5:\n                  _this.readEntry(reader, resolve);\n                case 6:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5);\n        }));\n        return function (_x6) {\n          return _ref5.apply(this, arguments);\n        };\n      }(), noop);\n    });\n    _defineProperty(this, \"buildCurrentFolderFromEntry\", function () {\n      if (!_this.entry) {\n        return Promise.resolve();\n      }\n      return new Promise(function (resolve) {\n        // $FlowFixMe entry is not empty\n        var reader = _this.entry.createReader();\n        _this.readEntry(reader, resolve);\n      });\n    });\n    _defineProperty(this, \"getFolderId\", function () {\n      return _this.folderId;\n    });\n    this.name = _name;\n    this.addFilesToUploadQueue = addFilesToUploadQueue;\n    this.addFolderToUploadQueue = addFolderToUploadQueue;\n    this.fileAPIOptions = fileAPIOptions;\n    this.baseAPIOptions = baseAPIOptions;\n    this.entry = _entry;\n  }\n  /**\n   * Upload a folder\n   *\n   * @public\n   * @param {string} parentFolderId\n   * @param {Function} errorCallback\n   * @param {boolean} isRoot\n   * @returns {Promise}\n   */\n\n  _createClass(FolderUploadNode, [{\n    key: \"upload\",\n    value: function () {\n      var _upload = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(parentFolderId, errorCallback) {\n        var isRoot,\n          _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                isRoot = _args6.length > 2 && _args6[2] !== undefined ? _args6[2] : false;\n                this.parentFolderId = parentFolderId;\n                _context6.next = 4;\n                return this.createAndUploadFolder(errorCallback, isRoot);\n              case 4:\n                if (!this.getFolderId()) {\n                  _context6.next = 8;\n                  break;\n                }\n                this.addFilesToUploadQueue(this.getFormattedFiles(), noop, true);\n                _context6.next = 8;\n                return this.uploadChildFolders(errorCallback);\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n      function upload(_x7, _x8) {\n        return _upload.apply(this, arguments);\n      }\n      return upload;\n    }()\n    /**\n     * Upload all child folders\n     *\n     * @private\n     * @param {Function} errorCallback\n     * @returns {Promise}\n     */\n  }, {\n    key: \"createFolder\",\n    /**\n     * Promisify create folder\n     *\n     * @private\n     * @returns {Promise}\n     */\n    value: function createFolder() {\n      var _this2 = this;\n      var folderAPI = new FolderAPI(_objectSpread({}, this.baseAPIOptions, {\n        id: \"folder_\".concat(this.parentFolderId)\n      }));\n      return new Promise(function (resolve, reject) {\n        folderAPI.create(_this2.parentFolderId, _this2.name, resolve, reject);\n      });\n    }\n    /**\n     * Create FolderUploadNode instances from entries\n     *\n     * @private\n     * @param {Array<FileSystemFileEntry>} entries\n     * @returns {Promise<any>}\n     */\n  }]);\n\n  return FolderUploadNode;\n}();\nexport default FolderUploadNode;","map":{"version":3,"sources":["../../../src/api/uploads/FolderUploadNode.js"],"names":["noop","getFileFromEntry","FolderAPI","STATUS_COMPLETE","STATUS_ERROR","ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED","ERROR_CODE_ITEM_NAME_IN_USE","FolderUploadNode","name","addFilesToUploadQueue","addFolderToUploadQueue","fileAPIOptions","baseAPIOptions","entry","parentFolderId","errorCallback","isRoot","createAndUploadFolder","getFolderId","getFormattedFiles","uploadChildFolders","folders","Object","values","promises","map","folder","upload","folderId","Promise","all","buildCurrentFolderFromEntry","errorEncountered","errorCode","data","createFolder","id","code","context_info","conflicts","folderObject","extension","status","isFolder","size","progress","error","files","file","options","uploadInitTimestamp","Date","now","folderAPI","resolve","reject","create","entries","isFile","push","reader","readEntries","length","createFolderUploadNodesFromEntries","readEntry","createReader"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Recursively create folder and upload files\n * @author Box\n */\nimport noop from 'lodash/noop';\nimport { getFileFromEntry } from '../../utils/uploads';\nimport FolderAPI from '../Folder';\nimport {\n    STATUS_COMPLETE,\n    STATUS_ERROR,\n    ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED,\n    ERROR_CODE_ITEM_NAME_IN_USE,\n} from '../../constants';\nimport type {\n    UploadFileWithAPIOptions,\n    FileSystemFileEntry,\n    FolderUploadItem,\n    DirectoryReader,\n} from '../../common/types/upload';\n\nclass FolderUploadNode {\n    addFolderToUploadQueue: Function;\n\n    files: Array<File> = [];\n\n    folderId: string;\n\n    folders: Object = {};\n\n    name: string;\n\n    parentFolderId: string;\n\n    addFilesToUploadQueue: Function;\n\n    fileAPIOptions: Object;\n\n    baseAPIOptions: Object;\n\n    entry: ?FileSystemFileEntry;\n\n    /**\n     * [constructor]\n     *\n     * @param {string} name\n     * @param {Function} addFilesToUploadQueue\n     * @param {Function} addFolderToUploadQueue\n     * @returns {void}\n     */\n    constructor(\n        name: string,\n        addFilesToUploadQueue: Function,\n        addFolderToUploadQueue: Function,\n        fileAPIOptions: Object,\n        baseAPIOptions: Object,\n        entry?: FileSystemFileEntry,\n    ) {\n        this.name = name;\n        this.addFilesToUploadQueue = addFilesToUploadQueue;\n        this.addFolderToUploadQueue = addFolderToUploadQueue;\n        this.fileAPIOptions = fileAPIOptions;\n        this.baseAPIOptions = baseAPIOptions;\n        this.entry = entry;\n    }\n\n    /**\n     * Upload a folder\n     *\n     * @public\n     * @param {string} parentFolderId\n     * @param {Function} errorCallback\n     * @param {boolean} isRoot\n     * @returns {Promise}\n     */\n    async upload(parentFolderId: string, errorCallback: Function, isRoot: boolean = false) {\n        this.parentFolderId = parentFolderId;\n\n        await this.createAndUploadFolder(errorCallback, isRoot);\n\n        // Check if folder was successfully created before we attempt to upload its contents.\n        if (this.getFolderId()) {\n            this.addFilesToUploadQueue(this.getFormattedFiles(), noop, true);\n            await this.uploadChildFolders(errorCallback);\n        }\n    }\n\n    /**\n     * Upload all child folders\n     *\n     * @private\n     * @param {Function} errorCallback\n     * @returns {Promise}\n     */\n    uploadChildFolders = async (errorCallback: Function) => {\n        // $FlowFixMe\n        const folders: Array<FolderUploadNode> = Object.values(this.folders);\n        const promises = folders.map(folder => folder.upload(this.folderId, errorCallback));\n\n        await Promise.all(promises);\n    };\n\n    /**\n     * Create folder and add it to the upload queue\n     *\n     * @private\n     * @param {Function} errorCallback\n     * @param {boolean} isRoot\n     * @returns {Promise}\n     */\n    createAndUploadFolder = async (errorCallback: Function, isRoot: boolean) => {\n        await this.buildCurrentFolderFromEntry();\n\n        let errorEncountered = false;\n        let errorCode = '';\n        try {\n            const data = await this.createFolder();\n            this.folderId = data.id;\n        } catch (error) {\n            // @TODO: Handle 429\n            if (error.code === ERROR_CODE_ITEM_NAME_IN_USE) {\n                this.folderId = error.context_info.conflicts[0].id;\n            } else if (isRoot) {\n                errorCallback(error);\n            } else {\n                // If this is a child folder of the folder being uploaded, this errorCallback will set\n                // an error message on the root folder being uploaded. Set a generic messages saying that a\n                // child has caused the error. The child folder will be tagged with the error message in\n                // the call to this.addFolderToUploadQueue below\n                errorEncountered = true;\n                errorCode = error.code;\n                errorCallback({ code: ERROR_CODE_UPLOAD_CHILD_FOLDER_FAILED });\n            }\n        }\n\n        // The root folder has already been added to the upload queue in ContentUploader\n        if (isRoot) {\n            return;\n        }\n\n        const folderObject: FolderUploadItem = {\n            extension: '',\n            name: this.name,\n            status: STATUS_COMPLETE,\n            isFolder: true,\n            size: 1,\n            progress: 100,\n        };\n\n        if (errorEncountered) {\n            folderObject.status = STATUS_ERROR;\n            folderObject.error = { code: errorCode };\n        }\n\n        this.addFolderToUploadQueue(folderObject);\n    };\n\n    /**\n     * Format files to Array<UploadFileWithAPIOptions> for upload\n     *\n     * @private\n     * @returns {Array<UploadFileWithAPIOptions>}\n     */\n    getFormattedFiles = (): Array<UploadFileWithAPIOptions> =>\n        this.files.map((file: File) => ({\n            file,\n            options: {\n                ...this.fileAPIOptions,\n                folderId: this.folderId,\n                uploadInitTimestamp: Date.now(),\n            },\n        }));\n\n    /**\n     * Promisify create folder\n     *\n     * @private\n     * @returns {Promise}\n     */\n    createFolder(): Promise<any> {\n        const folderAPI = new FolderAPI({\n            ...this.baseAPIOptions,\n            id: `folder_${this.parentFolderId}`,\n        });\n        return new Promise((resolve, reject) => {\n            folderAPI.create(this.parentFolderId, this.name, resolve, reject);\n        });\n    }\n\n    /**\n     * Create FolderUploadNode instances from entries\n     *\n     * @private\n     * @param {Array<FileSystemFileEntry>} entries\n     * @returns {Promise<any>}\n     */\n    createFolderUploadNodesFromEntries = async (entries: Array<FileSystemFileEntry>): Promise<any> => {\n        await Promise.all(\n            entries.map(async entry => {\n                const { isFile, name } = entry;\n\n                if (isFile) {\n                    const file = await getFileFromEntry(entry);\n                    this.files.push(file);\n                    return;\n                }\n\n                this.folders[name] = new FolderUploadNode(\n                    name,\n                    this.addFilesToUploadQueue,\n                    this.addFolderToUploadQueue,\n                    this.fileAPIOptions,\n                    {\n                        ...this.baseAPIOptions,\n                        ...this.fileAPIOptions,\n                    },\n                    entry,\n                );\n            }),\n        );\n    };\n\n    /**\n     * Recursively read an entry\n     *\n     * @private\n     * @param {DirectoryReader} reader\n     * @param {Function} resolve\n     * @returns {void}\n     */\n    readEntry = (reader: DirectoryReader, resolve: Function) => {\n        reader.readEntries(async entries => {\n            // Quit recursing when there are no remaining entries.\n            if (!entries.length) {\n                resolve();\n                return;\n            }\n\n            await this.createFolderUploadNodesFromEntries(entries);\n\n            this.readEntry(reader, resolve);\n        }, noop);\n    };\n\n    /**\n     * Build current folder from entry\n     *\n     * @private\n     * @returns {Promise<any>}\n     */\n    buildCurrentFolderFromEntry = (): Promise<any> => {\n        if (!this.entry) {\n            return Promise.resolve();\n        }\n\n        return new Promise(resolve => {\n            // $FlowFixMe entry is not empty\n            const reader = this.entry.createReader();\n\n            this.readEntry(reader, resolve);\n        });\n    };\n\n    /**\n     * Returns the folderId\n     * @returns {string}\n     */\n    getFolderId = (): string => {\n        return this.folderId;\n    };\n}\n\nexport default FolderUploadNode;\n"]},"metadata":{},"sourceType":"module"}