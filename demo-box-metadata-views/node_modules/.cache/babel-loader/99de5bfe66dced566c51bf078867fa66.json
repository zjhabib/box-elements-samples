{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport { matchPath } from 'react-router-dom';\nimport { getBadUserError } from '../../utils/error';\nexport default function withSidebarAnnotations(WrappedComponent) {\n  var WithSidebarAnnotations = /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(WithSidebarAnnotations, _React$Component);\n    function WithSidebarAnnotations(props) {\n      var _this;\n      _classCallCheck(this, WithSidebarAnnotations);\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(WithSidebarAnnotations).call(this, props));\n      _defineProperty(_assertThisInitialized(_this), \"sidebarPanels\", React.createRef());\n      _defineProperty(_assertThisInitialized(_this), \"redirectDeeplinkedAnnotation\", function () {\n        var _this$props = _this.props,\n          file = _this$props.file,\n          getAnnotationsPath = _this$props.getAnnotationsPath,\n          getAnnotationsMatchPath = _this$props.getAnnotationsMatchPath,\n          history = _this$props.history,\n          location = _this$props.location;\n        var match = getAnnotationsMatchPath(location);\n        var annotationId = getProp(match, 'params.annotationId');\n        var currentFileVersionId = getProp(file, 'file_version.id');\n        var fileVersionId = getProp(match, 'params.fileVersionId');\n        if (fileVersionId && fileVersionId !== currentFileVersionId) {\n          history.replace(getAnnotationsPath(currentFileVersionId, annotationId));\n        }\n      });\n      _defineProperty(_assertThisInitialized(_this), \"updateActiveAnnotation\", function () {\n        var _this$props2 = _this.props,\n          _this$props2$annotato = _this$props2.annotatorState,\n          activeAnnotationFileVersionId = _this$props2$annotato.activeAnnotationFileVersionId,\n          activeAnnotationId = _this$props2$annotato.activeAnnotationId,\n          file = _this$props2.file,\n          getAnnotationsMatchPath = _this$props2.getAnnotationsMatchPath,\n          getAnnotationsPath = _this$props2.getAnnotationsPath,\n          history = _this$props2.history,\n          location = _this$props2.location;\n        var match = getAnnotationsMatchPath(location);\n        var currentFileVersionId = getProp(file, 'file_version.id');\n        var defaultFileVersionId = activeAnnotationFileVersionId || currentFileVersionId;\n        var fileVersionId = getProp(match, 'params.fileVersionId', defaultFileVersionId);\n        var newLocationState = activeAnnotationId ? {\n          open: true\n        } : location.state; // Update the location pathname and open state if transitioning to an active annotation id, force the sidebar open\n\n        history.push({\n          pathname: getAnnotationsPath(fileVersionId, activeAnnotationId),\n          state: newLocationState\n        });\n      });\n      _defineProperty(_assertThisInitialized(_this), \"updateActiveVersion\", function () {\n        var _this$props3 = _this.props,\n          api = _this$props3.api,\n          file = _this$props3.file,\n          fileId = _this$props3.fileId,\n          getAnnotationsMatchPath = _this$props3.getAnnotationsMatchPath,\n          getAnnotationsPath = _this$props3.getAnnotationsPath,\n          history = _this$props3.history,\n          location = _this$props3.location,\n          onVersionChange = _this$props3.onVersionChange;\n        var feedAPI = api.getFeedAPI(false);\n        var match = getAnnotationsMatchPath(location);\n        var currentFileVersionId = getProp(file, 'file_version.id');\n        var fileVersionId = getProp(match, 'params.fileVersionId');\n        var _ref = feedAPI.getCachedItems(fileId) || {},\n          _ref$items = _ref.items,\n          feedItems = _ref$items === void 0 ? [] : _ref$items;\n        var version = feedItems.filter(function (item) {\n          return item.type === 'file_version';\n        }).find(function (item) {\n          return item.id === fileVersionId;\n        });\n        if (version) {\n          onVersionChange(version, {\n            currentVersionId: currentFileVersionId,\n            updateVersionToCurrent: function updateVersionToCurrent() {\n              return history.push(getAnnotationsPath(currentFileVersionId));\n            }\n          });\n        }\n      });\n      _this.redirectDeeplinkedAnnotation();\n      return _this;\n    }\n    _createClass(WithSidebarAnnotations, [{\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        var _this$props4 = this.props,\n          annotatorState = _this$props4.annotatorState,\n          fileId = _this$props4.fileId,\n          getAnnotationsMatchPath = _this$props4.getAnnotationsMatchPath,\n          location = _this$props4.location,\n          onVersionChange = _this$props4.onVersionChange;\n        var prevAnnotatorState = prevProps.annotatorState,\n          prevFileId = prevProps.fileId,\n          prevLocation = prevProps.location;\n        var activeAnnotationId = annotatorState.activeAnnotationId,\n          annotation = annotatorState.annotation;\n        var prevActiveAnnotationId = prevAnnotatorState.activeAnnotationId,\n          prevAnnotation = prevAnnotatorState.annotation;\n        var match = getAnnotationsMatchPath(location);\n        var prevMatch = getAnnotationsMatchPath(prevLocation);\n        var fileVersionId = getProp(match, 'params.fileVersionId');\n        var hasActiveAnnotationChanged = prevActiveAnnotationId !== activeAnnotationId;\n        var isAnnotationsPath = !!match;\n        var isTransitioningToAnnotationPath = activeAnnotationId && !isAnnotationsPath;\n        var prevFileVersionId = getProp(prevMatch, 'params.fileVersionId');\n        if (annotation && prevAnnotation !== annotation) {\n          this.addAnnotation();\n        } // Active annotation id changed. If location is currently an annotation path or\n        // if location is not currently an annotation path but the active annotation id\n        // transitioned from falsy to truthy, update the location accordingly\n\n        if (hasActiveAnnotationChanged && (isAnnotationsPath || isTransitioningToAnnotationPath)) {\n          this.updateActiveAnnotation();\n        }\n        if (fileVersionId && prevFileVersionId !== fileVersionId) {\n          this.updateActiveVersion();\n        }\n        if (prevFileId !== fileId) {\n          // If the file id has changed, reset the current version id since the previous (possibly versioned)\n          // location is no longer active\n          onVersionChange(null);\n        }\n      }\n    }, {\n      key: \"addAnnotation\",\n      value: function addAnnotation() {\n        var _this$props5 = this.props,\n          _this$props5$annotato = _this$props5.annotatorState,\n          action = _this$props5$annotato.action,\n          annotation = _this$props5$annotato.annotation,\n          _this$props5$annotato2 = _this$props5$annotato.meta;\n        _this$props5$annotato2 = _this$props5$annotato2 === void 0 ? {} : _this$props5$annotato2;\n        var requestId = _this$props5$annotato2.requestId,\n          api = _this$props5.api,\n          currentUser = _this$props5.currentUser,\n          file = _this$props5.file,\n          fileId = _this$props5.fileId,\n          isOpen = _this$props5.isOpen,\n          location = _this$props5.location;\n        if (!requestId) {\n          return;\n        } // TODO: need to address in follow on -- currentUser may be undefined here but is never fetched for sure until ActivitySidebar\n\n        if (!currentUser) {\n          throw getBadUserError();\n        }\n        var feedAPI = api.getFeedAPI(false);\n        var pathname = getProp(location, 'pathname', '');\n        var isActivity = matchPath(pathname, '/activity');\n        var isPending = action === 'create_start';\n        var _ref2 = feedAPI.getCachedItems(fileId) || {},\n          hasItems = _ref2.items;\n        var current = this.sidebarPanels.current; // If there are existing items in the cache for this file, then patch the cache with the new annotation\n        // If there are no cache entry for feeditems, then it is assumed that it has not yet been fetched.\n\n        if (hasItems) {\n          feedAPI.addAnnotation(file, currentUser, annotation, requestId, isPending);\n        } // If the activity sidebar is currently open, then force it to refresh with the updated data\n\n        if (current && isActivity && isOpen) {\n          current.refresh(false);\n        }\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        return React.createElement(WrappedComponent, _extends({\n          ref: this.sidebarPanels\n        }, this.props));\n      }\n    }]);\n    return WithSidebarAnnotations;\n  }(React.Component);\n  _defineProperty(WithSidebarAnnotations, \"defaultProps\", {\n    annotatorState: {},\n    getAnnotationsMatchPath: noop,\n    getAnnotationsPath: noop,\n    onVersionChange: noop\n  });\n  var displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  WithSidebarAnnotations.displayName = \"WithSidebarAnnotations(\".concat(displayName, \")\");\n  return WithSidebarAnnotations;\n}","map":{"version":3,"sources":["../../../src/elements/content-sidebar/withSidebarAnnotations.js"],"names":["React","getProp","noop","matchPath","getBadUserError","withSidebarAnnotations","WrappedComponent","WithSidebarAnnotations","Component","annotatorState","getAnnotationsMatchPath","getAnnotationsPath","onVersionChange","createRef","props","redirectDeeplinkedAnnotation","file","history","location","match","annotationId","currentFileVersionId","fileVersionId","replace","prevProps","fileId","prevAnnotatorState","prevFileId","prevLocation","activeAnnotationId","annotation","prevActiveAnnotationId","prevAnnotation","prevMatch","hasActiveAnnotationChanged","isAnnotationsPath","isTransitioningToAnnotationPath","prevFileVersionId","addAnnotation","updateActiveAnnotation","updateActiveVersion","action","meta","requestId","api","currentUser","isOpen","feedAPI","getFeedAPI","pathname","isActivity","isPending","items","hasItems","getCachedItems","current","sidebarPanels","refresh","activeAnnotationFileVersionId","defaultFileVersionId","newLocationState","open","state","push","feedItems","version","filter","item","type","find","id","currentVersionId","updateVersionToCurrent","displayName","name"],"mappings":"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","sourcesContent":["// @flow\nimport * as React from 'react';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport { matchPath, type ContextRouter } from 'react-router-dom';\nimport { getBadUserError } from '../../utils/error';\nimport type { WithAnnotatorContextProps } from '../common/annotator-context';\nimport type { BoxItem, User } from '../../common/types/core';\n\ntype Props = {\n    ...ContextRouter,\n    currentUser?: User,\n    file: BoxItem,\n    fileId: string,\n    isOpen: boolean,\n    onVersionChange: Function,\n} & WithAnnotatorContextProps;\n\ntype SidebarPanelsRefType = {\n    refresh: (shouldRefreshCache?: boolean) => void,\n};\n\nexport default function withSidebarAnnotations(\n    WrappedComponent: React.ComponentType<Props>,\n): React.ComponentType<Props> {\n    class WithSidebarAnnotations extends React.Component<Props> {\n        static defaultProps = {\n            annotatorState: {},\n            getAnnotationsMatchPath: noop,\n            getAnnotationsPath: noop,\n            onVersionChange: noop,\n        };\n\n        static displayName: ?string;\n\n        props: Props;\n\n        sidebarPanels: { current: SidebarPanelsRefType | null } = React.createRef();\n\n        constructor(props) {\n            super(props);\n\n            this.redirectDeeplinkedAnnotation();\n        }\n\n        redirectDeeplinkedAnnotation = () => {\n            const { file, getAnnotationsPath, getAnnotationsMatchPath, history, location } = this.props;\n            const match = getAnnotationsMatchPath(location);\n            const annotationId = getProp(match, 'params.annotationId');\n            const currentFileVersionId = getProp(file, 'file_version.id');\n            const fileVersionId = getProp(match, 'params.fileVersionId');\n\n            if (fileVersionId && fileVersionId !== currentFileVersionId) {\n                history.replace(getAnnotationsPath(currentFileVersionId, annotationId));\n            }\n        };\n\n        componentDidUpdate(prevProps: Props) {\n            const { annotatorState, fileId, getAnnotationsMatchPath, location, onVersionChange }: Props = this.props;\n            const { annotatorState: prevAnnotatorState, fileId: prevFileId, location: prevLocation }: Props = prevProps;\n            const { activeAnnotationId, annotation } = annotatorState;\n            const { activeAnnotationId: prevActiveAnnotationId, annotation: prevAnnotation } = prevAnnotatorState;\n\n            const match = getAnnotationsMatchPath(location);\n            const prevMatch = getAnnotationsMatchPath(prevLocation);\n            const fileVersionId = getProp(match, 'params.fileVersionId');\n            const hasActiveAnnotationChanged = prevActiveAnnotationId !== activeAnnotationId;\n            const isAnnotationsPath = !!match;\n            const isTransitioningToAnnotationPath = activeAnnotationId && !isAnnotationsPath;\n            const prevFileVersionId = getProp(prevMatch, 'params.fileVersionId');\n\n            if (annotation && prevAnnotation !== annotation) {\n                this.addAnnotation();\n            }\n\n            // Active annotation id changed. If location is currently an annotation path or\n            // if location is not currently an annotation path but the active annotation id\n            // transitioned from falsy to truthy, update the location accordingly\n            if (hasActiveAnnotationChanged && (isAnnotationsPath || isTransitioningToAnnotationPath)) {\n                this.updateActiveAnnotation();\n            }\n\n            if (fileVersionId && prevFileVersionId !== fileVersionId) {\n                this.updateActiveVersion();\n            }\n\n            if (prevFileId !== fileId) {\n                // If the file id has changed, reset the current version id since the previous (possibly versioned)\n                // location is no longer active\n                onVersionChange(null);\n            }\n        }\n\n        addAnnotation() {\n            const {\n                annotatorState: { action, annotation, meta: { requestId } = {} },\n                api,\n                currentUser,\n                file,\n                fileId,\n                isOpen,\n                location,\n            } = this.props;\n\n            if (!requestId) {\n                return;\n            }\n\n            // TODO: need to address in follow on -- currentUser may be undefined here but is never fetched for sure until ActivitySidebar\n            if (!currentUser) {\n                throw getBadUserError();\n            }\n\n            const feedAPI = api.getFeedAPI(false);\n            const pathname = getProp(location, 'pathname', '');\n            const isActivity = matchPath(pathname, '/activity');\n            const isPending = action === 'create_start';\n            const { items: hasItems } = feedAPI.getCachedItems(fileId) || {};\n            const { current } = this.sidebarPanels;\n\n            // If there are existing items in the cache for this file, then patch the cache with the new annotation\n            // If there are no cache entry for feeditems, then it is assumed that it has not yet been fetched.\n            if (hasItems) {\n                feedAPI.addAnnotation(file, currentUser, annotation, requestId, isPending);\n            }\n\n            // If the activity sidebar is currently open, then force it to refresh with the updated data\n            if (current && isActivity && isOpen) {\n                current.refresh(false);\n            }\n        }\n\n        updateActiveAnnotation = () => {\n            const {\n                annotatorState: { activeAnnotationFileVersionId, activeAnnotationId },\n                file,\n                getAnnotationsMatchPath,\n                getAnnotationsPath,\n                history,\n                location,\n            } = this.props;\n            const match = getAnnotationsMatchPath(location);\n            const currentFileVersionId = getProp(file, 'file_version.id');\n            const defaultFileVersionId = activeAnnotationFileVersionId || currentFileVersionId;\n            const fileVersionId = getProp(match, 'params.fileVersionId', defaultFileVersionId);\n            const newLocationState = activeAnnotationId ? { open: true } : location.state;\n\n            // Update the location pathname and open state if transitioning to an active annotation id, force the sidebar open\n            history.push({\n                pathname: getAnnotationsPath(fileVersionId, activeAnnotationId),\n                state: newLocationState,\n            });\n        };\n\n        updateActiveVersion = () => {\n            const {\n                api,\n                file,\n                fileId,\n                getAnnotationsMatchPath,\n                getAnnotationsPath,\n                history,\n                location,\n                onVersionChange,\n            } = this.props;\n            const feedAPI = api.getFeedAPI(false);\n            const match = getAnnotationsMatchPath(location);\n            const currentFileVersionId = getProp(file, 'file_version.id');\n            const fileVersionId = getProp(match, 'params.fileVersionId');\n            const { items: feedItems = [] } = feedAPI.getCachedItems(fileId) || {};\n            const version = feedItems\n                .filter(item => item.type === 'file_version')\n                .find(item => item.id === fileVersionId);\n\n            if (version) {\n                onVersionChange(version, {\n                    currentVersionId: currentFileVersionId,\n                    updateVersionToCurrent: () => history.push(getAnnotationsPath(currentFileVersionId)),\n                });\n            }\n        };\n\n        render() {\n            return <WrappedComponent ref={this.sidebarPanels} {...this.props} />;\n        }\n    }\n\n    const displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    WithSidebarAnnotations.displayName = `WithSidebarAnnotations(${displayName})`;\n\n    return WithSidebarAnnotations;\n}\n"]},"metadata":{},"sourceType":"module"}