{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file File for some simple dom utilities\n * @author Box\n */\nimport * as React from 'react';\nimport scrollIntoViewIfNeeded from 'scroll-into-view-if-needed';\nimport { KEYS, OVERLAY_WRAPPER_CLASS } from '../constants';\nimport './domPolyfill';\n/**\n * Checks if an html element is some type of input-able\n * element or text area type where characters can be typed.\n *\n * @param {HTMLElement|null} element - the dom element to check\n * @return {boolean} true if its one of the above elements\n */\n\nexport function isInputElement(element) {\n  if (!element || !(element instanceof HTMLElement)) {\n    return false;\n  }\n  var tag = element.tagName.toLowerCase();\n  return tag === 'input' || tag === 'select' || tag === 'textarea' || tag === 'div' && !!element.getAttribute('contenteditable');\n}\n/**\n * Checks if an html element is some kind of element\n * that the user would want to keep their focus on.\n *\n * @param {HTMLElement|null} element - the dom element to check\n * @return {boolean} true if its one of the above elements\n */\n\nexport function isFocusableElement(element) {\n  if (!element || !(element instanceof HTMLElement)) {\n    return false;\n  }\n  var tag = element.tagName.toLowerCase(); // Box React UI sensitive checks\n\n  var isCheckbox = element.classList.contains('checkbox-pointer-target') || (element.parentElement instanceof HTMLElement ? element.parentElement.classList.contains('checkbox-label') : false);\n  var isButton = element.classList.contains('btn-content') || element.parentElement instanceof HTMLElement && element.parentElement.classList.contains('btn') || element.parentElement instanceof HTMLElement && element.parentElement.classList.contains('bdl-Button') || false;\n  return isInputElement(element) || tag === 'button' || tag === 'a' || tag === 'option' || isCheckbox || isButton;\n}\n/**\n * Checks if a keyboard event is intended to activate an element.\n *\n * @param {SyntheticKeyboardEvent<HTMLElement>} event - The keyboard event\n * @returns {boolean} true if the event is intended to activate the element\n */\n\nexport function isActivateKey(event) {\n  return event.key === KEYS.enter || event.key === KEYS.space;\n}\n/**\n * Checks if a mouse event is an unmodified left click.\n *\n * @param {SyntheticMouseEvent<HTMLElement>} event - The mouse event\n * @returns {boolean} true if the event is an unmodified left click\n */\n\nexport function isLeftClick(event) {\n  return event.button === 0 && !event.altKey && !event.ctrlKey && !event.metaKey && !event.shiftKey;\n}\n/**\n * Focuses a DOM element if it exists.\n *\n * @param {HTMLElement} root - the root dom element to search\n * @param {string} selector - the query selector\n * @param {boolean|void} [focusRoot] - if root should be focused\n * @return {void}\n */\n\nexport function focus(root, selector) {\n  var focusRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!root) {\n    return;\n  }\n  if (!selector) {\n    root.focus();\n    return;\n  }\n  var element = root.querySelector(selector);\n  if (element && typeof element.focus === 'function') {\n    element.focus();\n  } else if (focusRoot) {\n    root.focus();\n  }\n}\n/**\n * Scrolls the container / modal / wrapper instead of the body\n *\n * @param {HTMLElement} itemEl - the base dom element to search\n * @param {Object} options - scroll into view options to override\n * @return {void}\n */\n\nexport function scrollIntoView(itemEl) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // @NOTE: breaks encapsulation but alternative is unknown child ref\n  if (itemEl) {\n    var parentEl = itemEl.closest(\".body, .modal, .\".concat(OVERLAY_WRAPPER_CLASS));\n    scrollIntoViewIfNeeded(itemEl, _objectSpread({\n      scrollMode: 'if-needed',\n      boundary: parentEl\n    }, options));\n  }\n}\n/**\n *\n * A React hook that tells you if an element (passed in as a ref) has content that overflows its container,\n * i.e., if the text is wider than the box around it.\n *\n * @param {{ current: null | HTMLElement }} contentRef\n * @return {boolean}\n */\n\nexport function useIsContentOverflowed(contentRef) {\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    isContentOverflowed = _React$useState2[0],\n    setIsContentOverflowed = _React$useState2[1]; // This function should be set as the ref prop for the measured component.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  React.useLayoutEffect(function () {\n    var current = contentRef.current;\n    if (!current) {\n      return;\n    }\n    var offsetWidth = current.offsetWidth,\n      scrollWidth = current.scrollWidth;\n    var willOverflow = offsetWidth < scrollWidth;\n    if (willOverflow !== isContentOverflowed) {\n      setIsContentOverflowed(willOverflow);\n    }\n  });\n  return isContentOverflowed;\n}","map":{"version":3,"sources":["../../src/utils/dom.js"],"names":["React","scrollIntoViewIfNeeded","KEYS","OVERLAY_WRAPPER_CLASS","isInputElement","element","HTMLElement","tag","tagName","toLowerCase","getAttribute","isFocusableElement","isCheckbox","classList","contains","parentElement","isButton","isActivateKey","event","key","enter","space","isLeftClick","button","altKey","ctrlKey","metaKey","shiftKey","focus","root","selector","focusRoot","querySelector","scrollIntoView","itemEl","options","parentEl","closest","scrollMode","boundary","useIsContentOverflowed","contentRef","isContentOverflowed","setIsContentOverflowed","useState","useLayoutEffect","current","offsetWidth","scrollWidth","willOverflow"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAKA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,OAAOC,sBAAP,MAAmC,4BAAnC;AAEA,SAASC,IAAT,EAAeC,qBAAf,QAA4C,cAA5C;AACA,OAAO,eAAP;AAEA;;;;;;;;AAOA,OAAO,SAASC,cAAT,CAAwBC,OAAxB,EAA4E;EAC/E,IAAI,CAACA,OAAD,IAAY,EAAEA,OAAO,YAAYC,WAArB,CAAhB,EAAmD;IAC/C,OAAO,KAAP;EACH;EAED,IAAMC,GAAG,GAAGF,OAAO,CAACG,OAARH,CAAgBI,WAAhBJ,CAAAA,CAAZ;EACA,OACIE,GAAG,KAAK,OAARA,IACAA,GAAG,KAAK,QADRA,IAEAA,GAAG,KAAK,UAFRA,IAGCA,GAAG,KAAK,KAARA,IAAiB,CAAC,CAACF,OAAO,CAACK,YAARL,CAAqB,iBAArBA,CAJxB;AAMH;AAED;;;;;;;;AAOA,OAAO,SAASM,kBAAT,CAA4BN,OAA5B,EAAgF;EACnF,IAAI,CAACA,OAAD,IAAY,EAAEA,OAAO,YAAYC,WAArB,CAAhB,EAAmD;IAC/C,OAAO,KAAP;EACH;EAED,IAAMC,GAAG,GAAGF,OAAO,CAACG,OAARH,CAAgBI,WAAhBJ,CAAAA,CAAZ,CALmF,CAOnF;;EACA,IAAMO,UAAU,GACZP,OAAO,CAACQ,SAARR,CAAkBS,QAAlBT,CAA2B,yBAA3BA,CAAAA,KACCA,OAAO,CAACU,aAARV,YAAiCC,WAAjCD,GACKA,OAAO,CAACU,aAARV,CAAsBQ,SAAtBR,CAAgCS,QAAhCT,CAAyC,gBAAzCA,CADLA,GAEK,KAHNA,CADJ;EAMA,IAAMW,QAAQ,GACVX,OAAO,CAACQ,SAARR,CAAkBS,QAAlBT,CAA2B,aAA3BA,CAAAA,IACCA,OAAO,CAACU,aAARV,YAAiCC,WAAjCD,IAAgDA,OAAO,CAACU,aAARV,CAAsBQ,SAAtBR,CAAgCS,QAAhCT,CAAyC,KAAzCA,CADjDA,IAECA,OAAO,CAACU,aAARV,YAAiCC,WAAjCD,IAAgDA,OAAO,CAACU,aAARV,CAAsBQ,SAAtBR,CAAgCS,QAAhCT,CAAyC,YAAzCA,CAFjDA,IAGA,KAJJ;EAMA,OAAOD,cAAc,CAACC,OAAD,CAAdD,IAA2BG,GAAG,KAAK,QAAnCH,IAA+CG,GAAG,KAAK,GAAvDH,IAA8DG,GAAG,KAAK,QAAtEH,IAAkFQ,UAAlFR,IAAgGY,QAAvG;AACH;AAED;;;;;;;AAMA,OAAO,SAASC,aAAT,CAAuBC,KAAvB,EAAmE;EACtE,OAAOA,KAAK,CAACC,GAAND,KAAchB,IAAI,CAACkB,KAAnBF,IAA4BA,KAAK,CAACC,GAAND,KAAchB,IAAI,CAACmB,KAAtD;AACH;AAED;;;;;;;AAMA,OAAO,SAASC,WAAT,CAAqBJ,KAArB,EAA8D;EACjE,OAAOA,KAAK,CAACK,MAANL,KAAiB,CAAjBA,IAAsB,CAACA,KAAK,CAACM,MAA7BN,IAAuC,CAACA,KAAK,CAACO,OAA9CP,IAAyD,CAACA,KAAK,CAACQ,OAAhER,IAA2E,CAACA,KAAK,CAACS,QAAzF;AACH;AAED;;;;;;;;;AAQA,OAAO,SAASC,KAAT,CAAeC,IAAf,EAAmCC,QAAnC,EAAuF;EAAA,IAAjCC,SAAiC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAZ,IAAY;EAC1F,IAAI,CAACF,IAAL,EAAW;IACP;EACH;EAED,IAAI,CAACC,QAAL,EAAe;IACXD,IAAI,CAACD,KAALC,CAAAA,CAAAA;IACA;EACH;EAED,IAAMxB,OAAO,GAAGwB,IAAI,CAACG,aAALH,CAAmBC,QAAnBD,CAAhB;EACA,IAAIxB,OAAO,IAAI,OAAOA,OAAO,CAACuB,KAAf,KAAyB,UAAxC,EAAoD;IAChDvB,OAAO,CAACuB,KAARvB,CAAAA,CAAAA;EACH,CAFD,MAEO,IAAI0B,SAAJ,EAAe;IAClBF,IAAI,CAACD,KAALC,CAAAA,CAAAA;EACH;AACJ;AAED;;;;;;;;AAOA,OAAO,SAASI,cAAT,CAAwBC,MAAxB,EAA2E;EAAA,IAA7BC,OAA6B,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAV,CAAA,CAAU;;EAC9E;EACA,IAAID,MAAJ,EAAY;IACR,IAAME,QAAQ,GAAGF,MAAM,CAACG,OAAPH,CAAAA,kBAAAA,CAAAA,MAAAA,CAAkC/B,qBAAlC+B,CAAAA,CAAjB;IACAjC,sBAAsB,CAACiC,MAAD,EAAA,aAAA,CAAA;MAClBI,UAAU,EAAE,WADM;MAElBC,QAAQ,EAAEH;IAFQ,CAAA,EAGfD,OAHe,CAAA,CAAtBlC;EAKH;AACJ;AAED;;;;;;;;;AAQA,OAAO,SAASuC,sBAAT,CAAgCC,UAAhC,EAAsF;EAAA,IAAA,eAAA,GACnCzC,KAAK,CAAC4C,QAAN5C,CAAwB,KAAxBA,CADmC;IAAA,gBAAA,GAAA,cAAA,CAAA,eAAA,EAAA,CAAA,CAAA;IAClF0C,mBADkF,GAAA,gBAAA,CAAA,CAAA,CAAA;IAC7DC,sBAD6D,GAAA,gBAAA,CAAA,CAAA,CAAA,CAAA,CAGzF;EACA;;EACA3C,KAAK,CAAC6C,eAAN7C,CAAsB,YAAM;IAAA,IAChB8C,OADgB,GACJL,UADI,CAChBK,OADgB;IAExB,IAAI,CAACA,OAAL,EAAc;MACV;IACH;IAJuB,IAKhBC,WALgB,GAKaD,OALb,CAKhBC,WALgB;MAKHC,WALG,GAKaF,OALb,CAKHE,WALG;IAMxB,IAAMC,YAAY,GAAGF,WAAW,GAAGC,WAAnC;IACA,IAAIC,YAAY,KAAKP,mBAArB,EAA0C;MACtCC,sBAAsB,CAACM,YAAD,CAAtBN;IACH;EACJ,CAVD3C,CAAAA;EAYA,OAAO0C,mBAAP;AACH","sourcesContent":["/**\n * @flow\n * @file File for some simple dom utilities\n * @author Box\n */\nimport * as React from 'react';\nimport scrollIntoViewIfNeeded from 'scroll-into-view-if-needed';\n\nimport { KEYS, OVERLAY_WRAPPER_CLASS } from '../constants';\nimport './domPolyfill';\n\n/**\n * Checks if an html element is some type of input-able\n * element or text area type where characters can be typed.\n *\n * @param {HTMLElement|null} element - the dom element to check\n * @return {boolean} true if its one of the above elements\n */\nexport function isInputElement(element: HTMLElement | EventTarget | null): boolean {\n    if (!element || !(element instanceof HTMLElement)) {\n        return false;\n    }\n\n    const tag = element.tagName.toLowerCase();\n    return (\n        tag === 'input' ||\n        tag === 'select' ||\n        tag === 'textarea' ||\n        (tag === 'div' && !!element.getAttribute('contenteditable'))\n    );\n}\n\n/**\n * Checks if an html element is some kind of element\n * that the user would want to keep their focus on.\n *\n * @param {HTMLElement|null} element - the dom element to check\n * @return {boolean} true if its one of the above elements\n */\nexport function isFocusableElement(element: HTMLElement | EventTarget | null): boolean {\n    if (!element || !(element instanceof HTMLElement)) {\n        return false;\n    }\n\n    const tag = element.tagName.toLowerCase();\n\n    // Box React UI sensitive checks\n    const isCheckbox =\n        element.classList.contains('checkbox-pointer-target') ||\n        (element.parentElement instanceof HTMLElement\n            ? element.parentElement.classList.contains('checkbox-label')\n            : false);\n\n    const isButton =\n        element.classList.contains('btn-content') ||\n        (element.parentElement instanceof HTMLElement && element.parentElement.classList.contains('btn')) ||\n        (element.parentElement instanceof HTMLElement && element.parentElement.classList.contains('bdl-Button')) ||\n        false;\n\n    return isInputElement(element) || tag === 'button' || tag === 'a' || tag === 'option' || isCheckbox || isButton;\n}\n\n/**\n * Checks if a keyboard event is intended to activate an element.\n *\n * @param {SyntheticKeyboardEvent<HTMLElement>} event - The keyboard event\n * @returns {boolean} true if the event is intended to activate the element\n */\nexport function isActivateKey(event: SyntheticKeyboardEvent<HTMLElement>) {\n    return event.key === KEYS.enter || event.key === KEYS.space;\n}\n\n/**\n * Checks if a mouse event is an unmodified left click.\n *\n * @param {SyntheticMouseEvent<HTMLElement>} event - The mouse event\n * @returns {boolean} true if the event is an unmodified left click\n */\nexport function isLeftClick(event: SyntheticMouseEvent<HTMLElement>) {\n    return event.button === 0 && !event.altKey && !event.ctrlKey && !event.metaKey && !event.shiftKey;\n}\n\n/**\n * Focuses a DOM element if it exists.\n *\n * @param {HTMLElement} root - the root dom element to search\n * @param {string} selector - the query selector\n * @param {boolean|void} [focusRoot] - if root should be focused\n * @return {void}\n */\nexport function focus(root: ?HTMLElement, selector?: string, focusRoot: boolean = true): void {\n    if (!root) {\n        return;\n    }\n\n    if (!selector) {\n        root.focus();\n        return;\n    }\n\n    const element = root.querySelector(selector);\n    if (element && typeof element.focus === 'function') {\n        element.focus();\n    } else if (focusRoot) {\n        root.focus();\n    }\n}\n\n/**\n * Scrolls the container / modal / wrapper instead of the body\n *\n * @param {HTMLElement} itemEl - the base dom element to search\n * @param {Object} options - scroll into view options to override\n * @return {void}\n */\nexport function scrollIntoView(itemEl: ?HTMLElement, options?: Object = {}): void {\n    // @NOTE: breaks encapsulation but alternative is unknown child ref\n    if (itemEl) {\n        const parentEl = itemEl.closest(`.body, .modal, .${OVERLAY_WRAPPER_CLASS}`);\n        scrollIntoViewIfNeeded(itemEl, {\n            scrollMode: 'if-needed',\n            boundary: parentEl,\n            ...options,\n        });\n    }\n}\n\n/**\n *\n * A React hook that tells you if an element (passed in as a ref) has content that overflows its container,\n * i.e., if the text is wider than the box around it.\n *\n * @param {{ current: null | HTMLElement }} contentRef\n * @return {boolean}\n */\nexport function useIsContentOverflowed(contentRef: { current: null | HTMLElement }): boolean {\n    const [isContentOverflowed, setIsContentOverflowed] = React.useState<boolean>(false);\n\n    // This function should be set as the ref prop for the measured component.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    React.useLayoutEffect(() => {\n        const { current } = contentRef;\n        if (!current) {\n            return;\n        }\n        const { offsetWidth, scrollWidth } = current;\n        const willOverflow = offsetWidth < scrollWidth;\n        if (willOverflow !== isContentOverflowed) {\n            setIsContentOverflowed(willOverflow);\n        }\n    });\n\n    return isContentOverflowed;\n}\n"]},"metadata":{},"sourceType":"module"}