{"ast":null,"code":"/**\n * Default implementation of cellRangeRenderer used by Grid.\n * This renderer supports cell-caching while the user is scrolling.\n */\nexport default function defaultCellRangeRenderer(_ref) {\n  var cellCache = _ref.cellCache,\n    cellRenderer = _ref.cellRenderer,\n    columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,\n    columnStartIndex = _ref.columnStartIndex,\n    columnStopIndex = _ref.columnStopIndex,\n    deferredMeasurementCache = _ref.deferredMeasurementCache,\n    horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,\n    isScrolling = _ref.isScrolling,\n    isScrollingOptOut = _ref.isScrollingOptOut,\n    parent = _ref.parent,\n    rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,\n    rowStartIndex = _ref.rowStartIndex,\n    rowStopIndex = _ref.rowStopIndex,\n    styleCache = _ref.styleCache,\n    verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,\n    visibleColumnIndices = _ref.visibleColumnIndices,\n    visibleRowIndices = _ref.visibleRowIndices;\n  var renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\n  // User cannot scroll beyond these size limitations.\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\n  // See issue #576 for more.\n\n  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\n  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;\n  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\n    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\n      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\n      var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n      var style = void 0; // Cache style objects so shallow-compare doesn't re-render unnecessarily.\n\n      if (canCacheStyle && styleCache[key]) {\n        style = styleCache[key];\n      } else {\n        // In deferred mode, cells will be initially rendered before we know their size.\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\n          // Position not-yet-measured cells at top/left 0,0,\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\n          // Positioning them further to the right/bottom influences their measured size.\n          style = {\n            height: 'auto',\n            left: 0,\n            position: 'absolute',\n            top: 0,\n            width: 'auto'\n          };\n        } else {\n          style = {\n            height: rowDatum.size,\n            left: columnDatum.offset + horizontalOffsetAdjustment,\n            position: 'absolute',\n            top: rowDatum.offset + verticalOffsetAdjustment,\n            width: columnDatum.size\n          };\n          styleCache[key] = style;\n        }\n      }\n      var cellRendererParams = {\n        columnIndex: columnIndex,\n        isScrolling: isScrolling,\n        isVisible: isVisible,\n        key: key,\n        parent: parent,\n        rowIndex: rowIndex,\n        style: style\n      };\n      var renderedCell = void 0; // Avoid re-creating cells while scrolling.\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n      // If a scroll is in progress- cache and reuse cells.\n      // This cache will be thrown away once scrolling completes.\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\n      // For more info refer to issue #395\n      //\n      // If isScrollingOptOut is specified, we always cache cells.\n      // For more info refer to issue #1028\n\n      if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\n        if (!cellCache[key]) {\n          cellCache[key] = cellRenderer(cellRendererParams);\n        }\n        renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\n      } else {\n        renderedCell = cellRenderer(cellRendererParams);\n      }\n      if (renderedCell == null || renderedCell === false) {\n        continue;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        warnAboutMissingStyle(parent, renderedCell);\n      }\n      renderedCells.push(renderedCell);\n    }\n  }\n  return renderedCells;\n}\nfunction warnAboutMissingStyle(parent, renderedCell) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (renderedCell) {\n      // If the direct child is a CellMeasurer, then we should check its child\n      // See issue #611\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\n        renderedCell = renderedCell.props.children;\n      }\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\n        parent.__warnedAboutMissingStyle = true;\n        console.warn('Rendered cell should include style property for positioning.');\n      }\n    }\n  }\n}\nimport { bpfrpt_proptype_CellRangeRendererParams } from \"./types\";","map":{"version":3,"names":["defaultCellRangeRenderer","_ref","cellCache","cellRenderer","columnSizeAndPositionManager","columnStartIndex","columnStopIndex","deferredMeasurementCache","horizontalOffsetAdjustment","isScrolling","isScrollingOptOut","parent","rowSizeAndPositionManager","rowStartIndex","rowStopIndex","styleCache","verticalOffsetAdjustment","visibleColumnIndices","visibleRowIndices","renderedCells","areOffsetsAdjusted","canCacheStyle","rowIndex","rowDatum","getSizeAndPositionOfCell","columnIndex","columnDatum","isVisible","start","stop","key","concat","style","has","height","left","position","top","width","size","offset","cellRendererParams","renderedCell","process","env","NODE_ENV","warnAboutMissingStyle","push","type","__internalCellMeasurerFlag","props","children","undefined","__warnedAboutMissingStyle","console","warn","bpfrpt_proptype_CellRangeRendererParams"],"sources":["/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/react-virtualized/dist/es/Grid/defaultCellRangeRenderer.js"],"sourcesContent":["/**\n * Default implementation of cellRangeRenderer used by Grid.\n * This renderer supports cell-caching while the user is scrolling.\n */\nexport default function defaultCellRangeRenderer(_ref) {\n  var cellCache = _ref.cellCache,\n      cellRenderer = _ref.cellRenderer,\n      columnSizeAndPositionManager = _ref.columnSizeAndPositionManager,\n      columnStartIndex = _ref.columnStartIndex,\n      columnStopIndex = _ref.columnStopIndex,\n      deferredMeasurementCache = _ref.deferredMeasurementCache,\n      horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment,\n      isScrolling = _ref.isScrolling,\n      isScrollingOptOut = _ref.isScrollingOptOut,\n      parent = _ref.parent,\n      rowSizeAndPositionManager = _ref.rowSizeAndPositionManager,\n      rowStartIndex = _ref.rowStartIndex,\n      rowStopIndex = _ref.rowStopIndex,\n      styleCache = _ref.styleCache,\n      verticalOffsetAdjustment = _ref.verticalOffsetAdjustment,\n      visibleColumnIndices = _ref.visibleColumnIndices,\n      visibleRowIndices = _ref.visibleRowIndices;\n  var renderedCells = []; // Browsers have native size limits for elements (eg Chrome 33M pixels, IE 1.5M pixes).\n  // User cannot scroll beyond these size limitations.\n  // In order to work around this, ScalingCellSizeAndPositionManager compresses offsets.\n  // We should never cache styles for compressed offsets though as this can lead to bugs.\n  // See issue #576 for more.\n\n  var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();\n  var canCacheStyle = !isScrolling && !areOffsetsAdjusted;\n\n  for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {\n    var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);\n\n    for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {\n      var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);\n      var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;\n      var key = \"\".concat(rowIndex, \"-\").concat(columnIndex);\n      var style = void 0; // Cache style objects so shallow-compare doesn't re-render unnecessarily.\n\n      if (canCacheStyle && styleCache[key]) {\n        style = styleCache[key];\n      } else {\n        // In deferred mode, cells will be initially rendered before we know their size.\n        // Don't interfere with CellMeasurer's measurements by setting an invalid size.\n        if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {\n          // Position not-yet-measured cells at top/left 0,0,\n          // And give them width/height of 'auto' so they can grow larger than the parent Grid if necessary.\n          // Positioning them further to the right/bottom influences their measured size.\n          style = {\n            height: 'auto',\n            left: 0,\n            position: 'absolute',\n            top: 0,\n            width: 'auto'\n          };\n        } else {\n          style = {\n            height: rowDatum.size,\n            left: columnDatum.offset + horizontalOffsetAdjustment,\n            position: 'absolute',\n            top: rowDatum.offset + verticalOffsetAdjustment,\n            width: columnDatum.size\n          };\n          styleCache[key] = style;\n        }\n      }\n\n      var cellRendererParams = {\n        columnIndex: columnIndex,\n        isScrolling: isScrolling,\n        isVisible: isVisible,\n        key: key,\n        parent: parent,\n        rowIndex: rowIndex,\n        style: style\n      };\n      var renderedCell = void 0; // Avoid re-creating cells while scrolling.\n      // This can lead to the same cell being created many times and can cause performance issues for \"heavy\" cells.\n      // If a scroll is in progress- cache and reuse cells.\n      // This cache will be thrown away once scrolling completes.\n      // However if we are scaling scroll positions and sizes, we should also avoid caching.\n      // This is because the offset changes slightly as scroll position changes and caching leads to stale values.\n      // For more info refer to issue #395\n      //\n      // If isScrollingOptOut is specified, we always cache cells.\n      // For more info refer to issue #1028\n\n      if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {\n        if (!cellCache[key]) {\n          cellCache[key] = cellRenderer(cellRendererParams);\n        }\n\n        renderedCell = cellCache[key]; // If the user is no longer scrolling, don't cache cells.\n        // This makes dynamic cell content difficult for users and would also lead to a heavier memory footprint.\n      } else {\n        renderedCell = cellRenderer(cellRendererParams);\n      }\n\n      if (renderedCell == null || renderedCell === false) {\n        continue;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        warnAboutMissingStyle(parent, renderedCell);\n      }\n\n      renderedCells.push(renderedCell);\n    }\n  }\n\n  return renderedCells;\n}\n\nfunction warnAboutMissingStyle(parent, renderedCell) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (renderedCell) {\n      // If the direct child is a CellMeasurer, then we should check its child\n      // See issue #611\n      if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {\n        renderedCell = renderedCell.props.children;\n      }\n\n      if (renderedCell && renderedCell.props && renderedCell.props.style === undefined && parent.__warnedAboutMissingStyle !== true) {\n        parent.__warnedAboutMissingStyle = true;\n        console.warn('Rendered cell should include style property for positioning.');\n      }\n    }\n  }\n}\n\nimport { bpfrpt_proptype_CellRangeRendererParams } from \"./types\";"],"mappings":"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"},"metadata":{},"sourceType":"module"}