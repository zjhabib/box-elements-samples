{"ast":null,"code":"// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i;\n\n// node names which could be successful controls\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;\n\n// Matches bracket notation.\nvar brackets = /(\\[[^\\[\\]]*\\])/g;\n\n// serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\nfunction serialize(form, options) {\n  if (typeof options != 'object') {\n    options = {\n      hash: !!options\n    };\n  } else if (options.hash === undefined) {\n    options.hash = true;\n  }\n  var result = options.hash ? {} : '';\n  var serializer = options.serializer || (options.hash ? hash_serializer : str_serialize);\n  var elements = form && form.elements ? form.elements : [];\n\n  //Object store each radio and set if it's empty or not\n  var radio_store = Object.create(null);\n  for (var i = 0; i < elements.length; ++i) {\n    var element = elements[i];\n\n    // ingore disabled fields\n    if (!options.disabled && element.disabled || !element.name) {\n      continue;\n    }\n    // ignore anyhting that is not considered a success field\n    if (!k_r_success_contrls.test(element.nodeName) || k_r_submitter.test(element.type)) {\n      continue;\n    }\n    var key = element.name;\n    var val = element.value;\n\n    // we can't just use element.value for checkboxes cause some browsers lie to us\n    // they say \"on\" for value when the box isn't checked\n    if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n      val = undefined;\n    }\n\n    // If we want empty elements\n    if (options.empty) {\n      // for checkbox\n      if (element.type === 'checkbox' && !element.checked) {\n        val = '';\n      }\n\n      // for radio\n      if (element.type === 'radio') {\n        if (!radio_store[element.name] && !element.checked) {\n          radio_store[element.name] = false;\n        } else if (element.checked) {\n          radio_store[element.name] = true;\n        }\n      }\n\n      // if options empty is true, continue only if its radio\n      if (val == undefined && element.type == 'radio') {\n        continue;\n      }\n    } else {\n      // value-less fields are ignored unless options.empty is true\n      if (!val) {\n        continue;\n      }\n    }\n\n    // multi select boxes\n    if (element.type === 'select-multiple') {\n      val = [];\n      var selectOptions = element.options;\n      var isSelectedOptions = false;\n      for (var j = 0; j < selectOptions.length; ++j) {\n        var option = selectOptions[j];\n        var allowedEmpty = options.empty && !option.value;\n        var hasValue = option.value || allowedEmpty;\n        if (option.selected && hasValue) {\n          isSelectedOptions = true;\n\n          // If using a hash serializer be sure to add the\n          // correct notation for an array in the multi-select\n          // context. Here the name attribute on the select element\n          // might be missing the trailing bracket pair. Both names\n          // \"foo\" and \"foo[]\" should be arrays.\n          if (options.hash && key.slice(key.length - 2) !== '[]') {\n            result = serializer(result, key + '[]', option.value);\n          } else {\n            result = serializer(result, key, option.value);\n          }\n        }\n      }\n\n      // Serialize if no selected options and options.empty is true\n      if (!isSelectedOptions && options.empty) {\n        result = serializer(result, key, '');\n      }\n      continue;\n    }\n    result = serializer(result, key, val);\n  }\n\n  // Check for all empty radio buttons and serialize them with key=\"\"\n  if (options.empty) {\n    for (var key in radio_store) {\n      if (!radio_store[key]) {\n        result = serializer(result, key, '');\n      }\n    }\n  }\n  return result;\n}\nfunction parse_keys(string) {\n  var keys = [];\n  var prefix = /^([^\\[\\]]*)/;\n  var children = new RegExp(brackets);\n  var match = prefix.exec(string);\n  if (match[1]) {\n    keys.push(match[1]);\n  }\n  while ((match = children.exec(string)) !== null) {\n    keys.push(match[1]);\n  }\n  return keys;\n}\nfunction hash_assign(result, keys, value) {\n  if (keys.length === 0) {\n    result = value;\n    return result;\n  }\n  var key = keys.shift();\n  var between = key.match(/^\\[(.+?)\\]$/);\n  if (key === '[]') {\n    result = result || [];\n    if (Array.isArray(result)) {\n      result.push(hash_assign(null, keys, value));\n    } else {\n      // This might be the result of bad name attributes like \"[][foo]\",\n      // in this case the original `result` object will already be\n      // assigned to an object literal. Rather than coerce the object to\n      // an array, or cause an exception the attribute \"_values\" is\n      // assigned as an array.\n      result._values = result._values || [];\n      result._values.push(hash_assign(null, keys, value));\n    }\n    return result;\n  }\n\n  // Key is an attribute name and can be assigned directly.\n  if (!between) {\n    result[key] = hash_assign(result[key], keys, value);\n  } else {\n    var string = between[1];\n    // +var converts the variable into a number\n    // better than parseInt because it doesn't truncate away trailing\n    // letters and actually fails if whole thing is not a number\n    var index = +string;\n\n    // If the characters between the brackets is not a number it is an\n    // attribute name and can be assigned directly.\n    if (isNaN(index)) {\n      result = result || {};\n      result[string] = hash_assign(result[string], keys, value);\n    } else {\n      result = result || [];\n      result[index] = hash_assign(result[index], keys, value);\n    }\n  }\n  return result;\n}\n\n// Object/hash encoding serializer.\nfunction hash_serializer(result, key, value) {\n  var matches = key.match(brackets);\n\n  // Has brackets? Use the recursive assignment function to walk the keys,\n  // construct any missing objects in the result tree and make the assignment\n  // at the end of the chain.\n  if (matches) {\n    var keys = parse_keys(key);\n    hash_assign(result, keys, value);\n  } else {\n    // Non bracket notation can make assignments directly.\n    var existing = result[key];\n\n    // If the value has been assigned already (for instance when a radio and\n    // a checkbox have the same name attribute) convert the previous value\n    // into an array before pushing into it.\n    //\n    // NOTE: If this requirement were removed all hash creation and\n    // assignment could go through `hash_assign`.\n    if (existing) {\n      if (!Array.isArray(existing)) {\n        result[key] = [existing];\n      }\n      result[key].push(value);\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\n// urlform encoding serializer\nfunction str_serialize(result, key, value) {\n  // encode newlines as \\r\\n cause the html spec says so\n  value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n  value = encodeURIComponent(value);\n\n  // spaces should be '+' rather than '%20'.\n  value = value.replace(/%20/g, '+');\n  return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\nmodule.exports = serialize;","map":{"version":3,"names":["k_r_submitter","k_r_success_contrls","brackets","serialize","form","options","hash","undefined","result","serializer","hash_serializer","str_serialize","elements","radio_store","Object","create","i","length","element","disabled","name","test","nodeName","type","key","val","value","checked","empty","selectOptions","isSelectedOptions","j","option","allowedEmpty","hasValue","selected","slice","parse_keys","string","keys","prefix","children","RegExp","match","exec","push","hash_assign","shift","between","Array","isArray","_values","index","isNaN","matches","existing","replace","encodeURIComponent","module","exports"],"sources":["/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/form-serialize/index.js"],"sourcesContent":["// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i;\n\n// node names which could be successful controls\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;\n\n// Matches bracket notation.\nvar brackets = /(\\[[^\\[\\]]*\\])/g;\n\n// serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\nfunction serialize(form, options) {\n    if (typeof options != 'object') {\n        options = { hash: !!options };\n    }\n    else if (options.hash === undefined) {\n        options.hash = true;\n    }\n\n    var result = (options.hash) ? {} : '';\n    var serializer = options.serializer || ((options.hash) ? hash_serializer : str_serialize);\n\n    var elements = form && form.elements ? form.elements : [];\n\n    //Object store each radio and set if it's empty or not\n    var radio_store = Object.create(null);\n\n    for (var i=0 ; i<elements.length ; ++i) {\n        var element = elements[i];\n\n        // ingore disabled fields\n        if ((!options.disabled && element.disabled) || !element.name) {\n            continue;\n        }\n        // ignore anyhting that is not considered a success field\n        if (!k_r_success_contrls.test(element.nodeName) ||\n            k_r_submitter.test(element.type)) {\n            continue;\n        }\n\n        var key = element.name;\n        var val = element.value;\n\n        // we can't just use element.value for checkboxes cause some browsers lie to us\n        // they say \"on\" for value when the box isn't checked\n        if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n            val = undefined;\n        }\n\n        // If we want empty elements\n        if (options.empty) {\n            // for checkbox\n            if (element.type === 'checkbox' && !element.checked) {\n                val = '';\n            }\n\n            // for radio\n            if (element.type === 'radio') {\n                if (!radio_store[element.name] && !element.checked) {\n                    radio_store[element.name] = false;\n                }\n                else if (element.checked) {\n                    radio_store[element.name] = true;\n                }\n            }\n\n            // if options empty is true, continue only if its radio\n            if (val == undefined && element.type == 'radio') {\n                continue;\n            }\n        }\n        else {\n            // value-less fields are ignored unless options.empty is true\n            if (!val) {\n                continue;\n            }\n        }\n\n        // multi select boxes\n        if (element.type === 'select-multiple') {\n            val = [];\n\n            var selectOptions = element.options;\n            var isSelectedOptions = false;\n            for (var j=0 ; j<selectOptions.length ; ++j) {\n                var option = selectOptions[j];\n                var allowedEmpty = options.empty && !option.value;\n                var hasValue = (option.value || allowedEmpty);\n                if (option.selected && hasValue) {\n                    isSelectedOptions = true;\n\n                    // If using a hash serializer be sure to add the\n                    // correct notation for an array in the multi-select\n                    // context. Here the name attribute on the select element\n                    // might be missing the trailing bracket pair. Both names\n                    // \"foo\" and \"foo[]\" should be arrays.\n                    if (options.hash && key.slice(key.length - 2) !== '[]') {\n                        result = serializer(result, key + '[]', option.value);\n                    }\n                    else {\n                        result = serializer(result, key, option.value);\n                    }\n                }\n            }\n\n            // Serialize if no selected options and options.empty is true\n            if (!isSelectedOptions && options.empty) {\n                result = serializer(result, key, '');\n            }\n\n            continue;\n        }\n\n        result = serializer(result, key, val);\n    }\n\n    // Check for all empty radio buttons and serialize them with key=\"\"\n    if (options.empty) {\n        for (var key in radio_store) {\n            if (!radio_store[key]) {\n                result = serializer(result, key, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction parse_keys(string) {\n    var keys = [];\n    var prefix = /^([^\\[\\]]*)/;\n    var children = new RegExp(brackets);\n    var match = prefix.exec(string);\n\n    if (match[1]) {\n        keys.push(match[1]);\n    }\n\n    while ((match = children.exec(string)) !== null) {\n        keys.push(match[1]);\n    }\n\n    return keys;\n}\n\nfunction hash_assign(result, keys, value) {\n    if (keys.length === 0) {\n        result = value;\n        return result;\n    }\n\n    var key = keys.shift();\n    var between = key.match(/^\\[(.+?)\\]$/);\n\n    if (key === '[]') {\n        result = result || [];\n\n        if (Array.isArray(result)) {\n            result.push(hash_assign(null, keys, value));\n        }\n        else {\n            // This might be the result of bad name attributes like \"[][foo]\",\n            // in this case the original `result` object will already be\n            // assigned to an object literal. Rather than coerce the object to\n            // an array, or cause an exception the attribute \"_values\" is\n            // assigned as an array.\n            result._values = result._values || [];\n            result._values.push(hash_assign(null, keys, value));\n        }\n\n        return result;\n    }\n\n    // Key is an attribute name and can be assigned directly.\n    if (!between) {\n        result[key] = hash_assign(result[key], keys, value);\n    }\n    else {\n        var string = between[1];\n        // +var converts the variable into a number\n        // better than parseInt because it doesn't truncate away trailing\n        // letters and actually fails if whole thing is not a number\n        var index = +string;\n\n        // If the characters between the brackets is not a number it is an\n        // attribute name and can be assigned directly.\n        if (isNaN(index)) {\n            result = result || {};\n            result[string] = hash_assign(result[string], keys, value);\n        }\n        else {\n            result = result || [];\n            result[index] = hash_assign(result[index], keys, value);\n        }\n    }\n\n    return result;\n}\n\n// Object/hash encoding serializer.\nfunction hash_serializer(result, key, value) {\n    var matches = key.match(brackets);\n\n    // Has brackets? Use the recursive assignment function to walk the keys,\n    // construct any missing objects in the result tree and make the assignment\n    // at the end of the chain.\n    if (matches) {\n        var keys = parse_keys(key);\n        hash_assign(result, keys, value);\n    }\n    else {\n        // Non bracket notation can make assignments directly.\n        var existing = result[key];\n\n        // If the value has been assigned already (for instance when a radio and\n        // a checkbox have the same name attribute) convert the previous value\n        // into an array before pushing into it.\n        //\n        // NOTE: If this requirement were removed all hash creation and\n        // assignment could go through `hash_assign`.\n        if (existing) {\n            if (!Array.isArray(existing)) {\n                result[key] = [ existing ];\n            }\n\n            result[key].push(value);\n        }\n        else {\n            result[key] = value;\n        }\n    }\n\n    return result;\n}\n\n// urlform encoding serializer\nfunction str_serialize(result, key, value) {\n    // encode newlines as \\r\\n cause the html spec says so\n    value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n    value = encodeURIComponent(value);\n\n    // spaces should be '+' rather than '%20'.\n    value = value.replace(/%20/g, '+');\n    return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\n\nmodule.exports = serialize;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}