{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n  return _arr;\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Content Uploader component\n * @author Box\n */\n\nimport React, { Component } from 'react';\nimport classNames from 'classnames';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport uniqueid from 'lodash/uniqueId';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { getTypedFileId, getTypedFolderId } from '../../utils/file';\nimport makeResponsive from '../common/makeResponsive';\nimport Internationalize from '../common/Internationalize';\nimport FolderUpload from '../../api/uploads/FolderUpload';\nimport API from '../../api';\nimport { getDataTransferItemId, getFileId, getFileFromDataTransferItem, getFile, getFileAPIOptions, getDataTransferItemAPIOptions, isDataTransferItemAFolder, isMultiputSupported } from '../../utils/uploads';\nimport DroppableContent from './DroppableContent';\nimport UploadsManager from './UploadsManager';\nimport Footer from './Footer';\nimport { DEFAULT_ROOT, CLIENT_NAME_CONTENT_UPLOADER, DEFAULT_HOSTNAME_UPLOAD, DEFAULT_HOSTNAME_API, VIEW_ERROR, VIEW_UPLOAD_EMPTY, VIEW_UPLOAD_IN_PROGRESS, VIEW_UPLOAD_SUCCESS, STATUS_PENDING, STATUS_IN_PROGRESS, STATUS_STAGED, STATUS_COMPLETE, STATUS_ERROR, ERROR_CODE_UPLOAD_FILE_LIMIT } from '../../constants';\nimport '../common/fonts.scss';\nimport '../common/base.scss';\nvar CHUNKED_UPLOAD_MIN_SIZE_BYTES = 104857600; // 100MB\n\nvar FILE_LIMIT_DEFAULT = 100; // Upload at most 100 files at once by default\n\nvar HIDE_UPLOAD_MANAGER_DELAY_MS_DEFAULT = 8000;\nvar EXPAND_UPLOADS_MANAGER_ITEMS_NUM_THRESHOLD = 5;\nvar UPLOAD_CONCURRENCY = 6;\nvar ContentUploader = /*#__PURE__*/\nfunction (_Component) {\n  _inherits(ContentUploader, _Component);\n\n  /**\n   * [constructor]\n   *\n   * @return {ContentUploader}\n   */\n  function ContentUploader(props) {\n    var _this;\n    _classCallCheck(this, ContentUploader);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ContentUploader).call(this, props));\n    _defineProperty(_assertThisInitialized(_this), \"isAutoExpanded\", false);\n    _defineProperty(_assertThisInitialized(_this), \"getBaseAPIOptions\", function () {\n      var _this$props = _this.props,\n        token = _this$props.token,\n        sharedLink = _this$props.sharedLink,\n        sharedLinkPassword = _this$props.sharedLinkPassword,\n        apiHost = _this$props.apiHost,\n        uploadHost = _this$props.uploadHost,\n        clientName = _this$props.clientName,\n        requestInterceptor = _this$props.requestInterceptor,\n        responseInterceptor = _this$props.responseInterceptor;\n      return {\n        token: token,\n        sharedLink: sharedLink,\n        sharedLinkPassword: sharedLinkPassword,\n        apiHost: apiHost,\n        uploadHost: uploadHost,\n        clientName: clientName,\n        requestInterceptor: requestInterceptor,\n        responseInterceptor: responseInterceptor\n      };\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getNewFiles\", function (files) {\n      var rootFolderId = _this.props.rootFolderId;\n      var itemIds = _this.state.itemIds;\n      return Array.from(files).filter(function (file) {\n        return !itemIds[getFileId(file, rootFolderId)];\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"getNewDataTransferItems\", function (items) {\n      var rootFolderId = _this.props.rootFolderId;\n      var itemIds = _this.state.itemIds;\n      return Array.from(items).filter(function (item) {\n        return !itemIds[getDataTransferItemId(item, rootFolderId)];\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addFilesToUploadQueue\", function (files, itemUpdateCallback) {\n      var isRelativePathIgnored = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var _this$props2 = _this.props,\n        onBeforeUpload = _this$props2.onBeforeUpload,\n        rootFolderId = _this$props2.rootFolderId;\n      if (!files || files.length === 0) {\n        return;\n      }\n      var newFiles = _this.getNewFiles(files);\n      if (newFiles.length === 0) {\n        return;\n      }\n      var newItemIds = {};\n      newFiles.forEach(function (file) {\n        newItemIds[getFileId(file, rootFolderId)] = true;\n      });\n      clearTimeout(_this.resetItemsTimeout);\n      var firstFile = getFile(newFiles[0]);\n      _this.setState(function (state) {\n        return {\n          itemIds: _objectSpread({}, state.itemIds, {}, newItemIds)\n        };\n      }, function () {\n        onBeforeUpload(newFiles);\n        if (firstFile.webkitRelativePath && !isRelativePathIgnored) {\n          // webkitRelativePath should be ignored when the upload destination folder is known\n          _this.addFilesWithRelativePathToQueue(newFiles, itemUpdateCallback);\n        } else {\n          _this.addFilesWithoutRelativePathToQueue(newFiles, itemUpdateCallback);\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addDroppedItemsToUploadQueue\", function (droppedItems, itemUpdateCallback) {\n      if (droppedItems.items) {\n        _this.addDataTransferItemsToUploadQueue(droppedItems.items, itemUpdateCallback);\n      } else {\n        Array.from(droppedItems.files).forEach(function (file) {\n          _this.addFilesToUploadQueue([file], itemUpdateCallback);\n        });\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addDataTransferItemsToUploadQueue\", function (dataTransferItems, itemUpdateCallback) {\n      var isFolderUploadEnabled = _this.props.isFolderUploadEnabled;\n      if (!dataTransferItems || dataTransferItems.length === 0) {\n        return;\n      }\n      var folderItems = [];\n      var fileItems = [];\n      Array.from(dataTransferItems).forEach(function (item) {\n        var isDirectory = isDataTransferItemAFolder(item);\n        if (isDirectory && isFolderUploadEnabled) {\n          folderItems.push(item);\n        } else if (!isDirectory) {\n          fileItems.push(item);\n        }\n      });\n      _this.addFileDataTransferItemsToUploadQueue(fileItems, itemUpdateCallback);\n      _this.addFolderDataTransferItemsToUploadQueue(folderItems, itemUpdateCallback);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addFileDataTransferItemsToUploadQueue\", function (dataTransferItems, itemUpdateCallback) {\n      dataTransferItems.forEach( /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee(item) {\n          var file;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return getFileFromDataTransferItem(item);\n                case 2:\n                  file = _context.sent;\n                  if (file) {\n                    _context.next = 5;\n                    break;\n                  }\n                  return _context.abrupt(\"return\");\n                case 5:\n                  _this.addFilesToUploadQueue([file], itemUpdateCallback);\n                case 6:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addFolderDataTransferItemsToUploadQueue\", /*#__PURE__*/\n    function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(dataTransferItems, itemUpdateCallback) {\n        var rootFolderId, itemIds, newItems, fileAPIOptions, _fileAPIOptions$folde, folderId;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                rootFolderId = _this.props.rootFolderId;\n                itemIds = _this.state.itemIds;\n                if (!(dataTransferItems.length === 0)) {\n                  _context3.next = 4;\n                  break;\n                }\n                return _context3.abrupt(\"return\");\n              case 4:\n                newItems = _this.getNewDataTransferItems(dataTransferItems);\n                newItems.forEach(function (item) {\n                  itemIds[getDataTransferItemId(item, rootFolderId)] = true;\n                });\n                if (!(newItems.length === 0)) {\n                  _context3.next = 8;\n                  break;\n                }\n                return _context3.abrupt(\"return\");\n              case 8:\n                fileAPIOptions = getDataTransferItemAPIOptions(newItems[0]);\n                _fileAPIOptions$folde = fileAPIOptions.folderId, folderId = _fileAPIOptions$folde === void 0 ? rootFolderId : _fileAPIOptions$folde;\n                newItems.forEach( /*#__PURE__*/\n                function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/\n                  _regeneratorRuntime.mark(function _callee2(item) {\n                    var folderUpload;\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            folderUpload = _this.getFolderUploadAPI(folderId);\n                            _context2.next = 3;\n                            return folderUpload.buildFolderTreeFromDataTransferItem(item);\n                          case 3:\n                            _this.addFolderToUploadQueue(folderUpload, itemUpdateCallback, fileAPIOptions);\n                          case 4:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2);\n                  }));\n                  return function (_x4) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n      return function (_x2, _x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }());\n    _defineProperty(_assertThisInitialized(_this), \"getFolderUploadAPI\", function (folderId) {\n      var uploadBaseAPIOptions = _this.getBaseAPIOptions();\n      return new FolderUpload(_this.addFilesToUploadQueue, folderId, _this.addToQueue, uploadBaseAPIOptions);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addFolderToUploadQueue\", function (folderUpload, itemUpdateCallback, apiOptions) {\n      _this.addToQueue([\n      // $FlowFixMe no file property\n      {\n        api: folderUpload,\n        extension: '',\n        isFolder: true,\n        name: folderUpload.folder.name,\n        options: apiOptions,\n        progress: 0,\n        size: 1,\n        status: STATUS_PENDING\n      }], itemUpdateCallback);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addFilesWithoutRelativePathToQueue\", function (files, itemUpdateCallback) {\n      var itemIds = _this.state.itemIds;\n      var rootFolderId = _this.props.rootFolderId; // Convert files from the file API to upload items\n\n      var newItems = files.map(function (file) {\n        var uploadFile = getFile(file);\n        var uploadAPIOptions = getFileAPIOptions(file);\n        var name = uploadFile.name,\n          size = uploadFile.size; // Extract extension or use empty string if file has no extension\n\n        var extension = name.substr(name.lastIndexOf('.') + 1);\n        if (extension.length === name.length) {\n          extension = '';\n        }\n        var api = _this.getUploadAPI(uploadFile, uploadAPIOptions);\n        var uploadItem = {\n          api: api,\n          extension: extension,\n          file: uploadFile,\n          name: name,\n          progress: 0,\n          size: size,\n          status: STATUS_PENDING\n        };\n        if (uploadAPIOptions) {\n          uploadItem.options = uploadAPIOptions;\n        }\n        itemIds[getFileId(uploadItem, rootFolderId)] = true;\n        return uploadItem;\n      });\n      if (newItems.length === 0) {\n        return;\n      }\n      _this.setState({\n        itemIds: itemIds\n      });\n      _this.addToQueue(newItems, itemUpdateCallback);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addToQueue\", function (newItems, itemUpdateCallback) {\n      var _this$props3 = _this.props,\n        fileLimit = _this$props3.fileLimit,\n        useUploadsManager = _this$props3.useUploadsManager;\n      var _this$state = _this.state,\n        items = _this$state.items,\n        isUploadsManagerExpanded = _this$state.isUploadsManagerExpanded;\n      var updatedItems = [];\n      var prevItemsNum = items.length;\n      var totalNumOfItems = prevItemsNum + newItems.length; // Don't add more than fileLimit # of items\n\n      if (totalNumOfItems > fileLimit) {\n        updatedItems = items.concat(newItems.slice(0, fileLimit - items.length));\n        _this.setState({\n          errorCode: ERROR_CODE_UPLOAD_FILE_LIMIT\n        });\n      } else {\n        updatedItems = items.concat(newItems);\n        _this.setState({\n          errorCode: ''\n        }); // If the number of items being uploaded passes the threshold, expand the upload manager\n\n        if (prevItemsNum < EXPAND_UPLOADS_MANAGER_ITEMS_NUM_THRESHOLD && totalNumOfItems >= EXPAND_UPLOADS_MANAGER_ITEMS_NUM_THRESHOLD && useUploadsManager && !isUploadsManagerExpanded) {\n          _this.isAutoExpanded = true;\n          _this.expandUploadsManager();\n        }\n      }\n      _this.updateViewAndCollection(updatedItems, function () {\n        if (itemUpdateCallback) {\n          itemUpdateCallback();\n        }\n        var view = _this.state.view; // Automatically start upload if other files are being uploaded\n\n        if (view === VIEW_UPLOAD_IN_PROGRESS) {\n          _this.upload();\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"removeFileFromUploadQueue\", function (item) {\n      var _this$props4 = _this.props,\n        onCancel = _this$props4.onCancel,\n        useUploadsManager = _this$props4.useUploadsManager;\n      var items = _this.state.items; // Clear any error errorCode in footer\n\n      _this.setState({\n        errorCode: ''\n      });\n      var api = item.api;\n      api.cancel();\n      items.splice(items.indexOf(item), 1);\n      onCancel([item]);\n      _this.updateViewAndCollection(items, function () {\n        // Minimize uploads manager if there are no more items\n        if (useUploadsManager && !items.length) {\n          _this.minimizeUploadsManager();\n        }\n        var view = _this.state.view;\n        if (view === VIEW_UPLOAD_IN_PROGRESS) {\n          _this.upload();\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"cancel\", function () {\n      var items = _this.state.items;\n      items.forEach(function (uploadItem) {\n        var api = uploadItem.api,\n          status = uploadItem.status;\n        if (status === STATUS_IN_PROGRESS) {\n          api.cancel();\n        }\n      }); // Reset upload collection\n\n      _this.updateViewAndCollection([]);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"upload\", function () {\n      var items = _this.state.items;\n      items.forEach(function (uploadItem) {\n        if (uploadItem.status === STATUS_PENDING) {\n          _this.uploadFile(uploadItem);\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleUploadSuccess\", function (item, entries) {\n      var _this$props5 = _this.props,\n        onUpload = _this$props5.onUpload,\n        useUploadsManager = _this$props5.useUploadsManager;\n      item.progress = 100;\n      if (!item.error) {\n        item.status = STATUS_COMPLETE;\n      } // Cache Box File object of successfully uploaded item\n\n      if (entries && entries.length === 1) {\n        var _entries = _slicedToArray(entries, 1),\n          boxFile = _entries[0];\n        item.boxFile = boxFile;\n      }\n      var items = _this.state.items;\n      items[items.indexOf(item)] = item; // Broadcast that a file has been uploaded\n\n      if (useUploadsManager) {\n        onUpload(item);\n        _this.checkClearUploadItems();\n      } else {\n        onUpload(item.boxFile);\n      }\n      _this.updateViewAndCollection(items, function () {\n        var view = _this.state.view;\n        if (view === VIEW_UPLOAD_IN_PROGRESS) {\n          _this.upload();\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"resetUploadManagerExpandState\", function () {\n      _this.isAutoExpanded = false;\n      _this.setState({\n        isUploadsManagerExpanded: false\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleUploadError\", function (item, error) {\n      var _this$props6 = _this.props,\n        onError = _this$props6.onError,\n        useUploadsManager = _this$props6.useUploadsManager;\n      var file = item.file;\n      var items = _this.state.items;\n      item.status = STATUS_ERROR;\n      item.error = error;\n      var newItems = _toConsumableArray(items);\n      var index = newItems.findIndex(function (singleItem) {\n        return singleItem === item;\n      });\n      if (index !== -1) {\n        newItems[index] = item;\n      } // Broadcast that there was an error uploading a file\n\n      var errorData = useUploadsManager ? {\n        item: item,\n        error: error\n      } : {\n        file: file,\n        error: error\n      };\n      onError(errorData);\n      _this.updateViewAndCollection(newItems, function () {\n        if (useUploadsManager) {\n          _this.isAutoExpanded = true;\n          _this.expandUploadsManager();\n        }\n        var view = _this.state.view;\n        if (view === VIEW_UPLOAD_IN_PROGRESS) {\n          _this.upload();\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"handleUploadProgress\", function (item, event) {\n      if (!event.total || item.status === STATUS_COMPLETE || item.status === STATUS_STAGED) {\n        return;\n      }\n      item.progress = Math.min(Math.round(event.loaded / event.total * 100), 100);\n      item.status = item.progress === 100 ? STATUS_STAGED : STATUS_IN_PROGRESS;\n      var onProgress = _this.props.onProgress;\n      onProgress(item);\n      var items = _this.state.items;\n      items[items.indexOf(item)] = item;\n      _this.updateViewAndCollection(items);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"onClick\", function (item) {\n      var _this$props7 = _this.props,\n        chunked = _this$props7.chunked,\n        isResumableUploadsEnabled = _this$props7.isResumableUploadsEnabled,\n        onClickCancel = _this$props7.onClickCancel,\n        onClickResume = _this$props7.onClickResume,\n        onClickRetry = _this$props7.onClickRetry;\n      var status = item.status,\n        file = item.file;\n      var isChunkedUpload = chunked && !item.isFolder && file.size > CHUNKED_UPLOAD_MIN_SIZE_BYTES && isMultiputSupported();\n      var isResumable = isResumableUploadsEnabled && isChunkedUpload && item.api.sessionId;\n      switch (status) {\n        case STATUS_IN_PROGRESS:\n        case STATUS_STAGED:\n        case STATUS_COMPLETE:\n        case STATUS_PENDING:\n          _this.removeFileFromUploadQueue(item);\n          onClickCancel(item);\n          break;\n        case STATUS_ERROR:\n          if (isResumable) {\n            item.bytesUploadedOnLastResume = item.api.totalUploadedBytes;\n            _this.resumeFile(item);\n            onClickResume(item);\n          } else {\n            _this.resetFile(item);\n            _this.uploadFile(item);\n            onClickRetry(item);\n          }\n          break;\n        default:\n          break;\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"clickAllWithStatus\", function (status) {\n      var items = _this.state.items;\n      items.forEach(function (item) {\n        if (!status || item.status === status) {\n          _this.onClick(item);\n        }\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"expandUploadsManager\", function () {\n      var useUploadsManager = _this.props.useUploadsManager;\n      if (!useUploadsManager) {\n        return;\n      }\n      clearTimeout(_this.resetItemsTimeout);\n      _this.setState({\n        isUploadsManagerExpanded: true\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"minimizeUploadsManager\", function () {\n      var _this$props8 = _this.props,\n        useUploadsManager = _this$props8.useUploadsManager,\n        onMinimize = _this$props8.onMinimize;\n      if (!useUploadsManager || !onMinimize) {\n        return;\n      }\n      clearTimeout(_this.resetItemsTimeout);\n      onMinimize();\n      _this.resetUploadManagerExpandState();\n      _this.checkClearUploadItems();\n    });\n    _defineProperty(_assertThisInitialized(_this), \"checkClearUploadItems\", function () {\n      _this.resetItemsTimeout = setTimeout(_this.resetUploadsManagerItemsWhenUploadsComplete, HIDE_UPLOAD_MANAGER_DELAY_MS_DEFAULT);\n    });\n    _defineProperty(_assertThisInitialized(_this), \"toggleUploadsManager\", function () {\n      var isUploadsManagerExpanded = _this.state.isUploadsManagerExpanded;\n      if (isUploadsManagerExpanded) {\n        _this.minimizeUploadsManager();\n      } else {\n        _this.expandUploadsManager();\n      }\n    });\n    _defineProperty(_assertThisInitialized(_this), \"resetUploadsManagerItemsWhenUploadsComplete\", function () {\n      var _this$state2 = _this.state,\n        view = _this$state2.view,\n        items = _this$state2.items,\n        isUploadsManagerExpanded = _this$state2.isUploadsManagerExpanded;\n      var _this$props9 = _this.props,\n        useUploadsManager = _this$props9.useUploadsManager,\n        onCancel = _this$props9.onCancel; // Do not reset items when upload manger is expanded or there're uploads in progress\n\n      if (isUploadsManagerExpanded && useUploadsManager && !!items.length || view === VIEW_UPLOAD_IN_PROGRESS) {\n        return;\n      }\n      onCancel(items);\n      _this.setState({\n        items: [],\n        itemIds: {}\n      });\n    });\n    _defineProperty(_assertThisInitialized(_this), \"addFilesWithOptionsToUploadQueueAndStartUpload\", function (files, dataTransferItems) {\n      _this.addFilesToUploadQueue(files, _this.upload);\n      _this.addDataTransferItemsToUploadQueue(dataTransferItems, _this.upload);\n    });\n    var _rootFolderId = props.rootFolderId,\n      _token = props.token,\n      _useUploadsManager = props.useUploadsManager;\n    _this.state = {\n      view: _rootFolderId && _token || _useUploadsManager ? VIEW_UPLOAD_EMPTY : VIEW_ERROR,\n      items: [],\n      errorCode: '',\n      itemIds: {},\n      isUploadsManagerExpanded: false\n    };\n    _this.id = uniqueid('bcu_');\n    return _this;\n  }\n  /**\n   * Fetches the root folder on load\n   *\n   * @private\n   * @inheritdoc\n   * @return {void}\n   */\n\n  _createClass(ContentUploader, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.rootElement = document.getElementById(this.id);\n      this.appElement = this.rootElement;\n    }\n    /**\n     * Cancels pending uploads\n     *\n     * @private\n     * @inheritdoc\n     * @return {void}\n     */\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.cancel();\n    }\n    /**\n     * Adds new items to the queue when files prop gets updated in window view\n     *\n     * @return {void}\n     */\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this$props10 = this.props,\n        files = _this$props10.files,\n        dataTransferItems = _this$props10.dataTransferItems,\n        useUploadsManager = _this$props10.useUploadsManager;\n      var hasFiles = Array.isArray(files) && files.length > 0;\n      var hasItems = Array.isArray(dataTransferItems) && dataTransferItems.length > 0;\n      var hasUploads = hasFiles || hasItems;\n      if (!useUploadsManager || !hasUploads) {\n        return;\n      }\n      this.addFilesWithOptionsToUploadQueueAndStartUpload(files, dataTransferItems);\n    }\n    /**\n     * Create and return new instance of API creator\n     *\n     * @param {UploadItemAPIOptions} [uploadAPIOptions]\n     * @return {API}\n     */\n  }, {\n    key: \"createAPIFactory\",\n    value: function createAPIFactory(uploadAPIOptions) {\n      var rootFolderId = this.props.rootFolderId;\n      var folderId = getProp(uploadAPIOptions, 'folderId') || rootFolderId;\n      var fileId = getProp(uploadAPIOptions, 'fileId');\n      var itemFolderId = getTypedFolderId(folderId);\n      var itemFileId = fileId ? getTypedFileId(fileId) : null;\n      return new API(_objectSpread({}, this.getBaseAPIOptions(), {\n        id: itemFileId || itemFolderId\n      }, uploadAPIOptions));\n    }\n    /**\n     * Return base API options from props\n     *\n     * @private\n     * @returns {Object}\n     */\n  }, {\n    key: \"addFilesWithRelativePathToQueue\",\n    /**\n     * Converts File API to upload items and adds to upload queue for files with webkitRelativePath.\n     *\n     * @private\n     * @param {Array<UploadFileWithAPIOptions | File>} files - Files to be added to upload queue\n     * @param {Function} itemUpdateCallback - function to be invoked after items status are updated\n     * @return {void}\n     */\n    value: function addFilesWithRelativePathToQueue(files, itemUpdateCallback) {\n      if (files.length === 0) {\n        return;\n      }\n      var rootFolderId = this.props.rootFolderId;\n      var fileAPIOptions = getFileAPIOptions(files[0]);\n      var _fileAPIOptions$folde2 = fileAPIOptions.folderId,\n        folderId = _fileAPIOptions$folde2 === void 0 ? rootFolderId : _fileAPIOptions$folde2;\n      var folderUpload = this.getFolderUploadAPI(folderId); // Only 1 folder tree can be built with files having webkitRelativePath properties\n\n      folderUpload.buildFolderTreeFromWebkitRelativePath(files);\n      this.addFolderToUploadQueue(folderUpload, itemUpdateCallback, fileAPIOptions);\n    }\n    /**\n     * Get folder upload API instance\n     *\n     * @private\n     * @param {string} folderId\n     * @return {FolderUpload}\n     */\n  }, {\n    key: \"getUploadAPI\",\n    /**\n     * Returns a new API instance for the given file.\n     *\n     * @private\n     * @param {File} file - File to get a new API instance for\n     * @param {UploadItemAPIOptions} [uploadAPIOptions]\n     * @return {UploadAPI} - Instance of Upload API\n     */\n    value: function getUploadAPI(file, uploadAPIOptions) {\n      var _this$props11 = this.props,\n        chunked = _this$props11.chunked,\n        isResumableUploadsEnabled = _this$props11.isResumableUploadsEnabled,\n        isUploadFallbackLogicEnabled = _this$props11.isUploadFallbackLogicEnabled;\n      var size = file.size;\n      var factory = this.createAPIFactory(uploadAPIOptions);\n      if (chunked && size > CHUNKED_UPLOAD_MIN_SIZE_BYTES) {\n        if (isMultiputSupported()) {\n          var chunkedUploadAPI = factory.getChunkedUploadAPI();\n          if (isResumableUploadsEnabled) {\n            chunkedUploadAPI.isResumableUploadsEnabled = true;\n          }\n          if (isUploadFallbackLogicEnabled) {\n            chunkedUploadAPI.isUploadFallbackLogicEnabled = true;\n          }\n          return chunkedUploadAPI;\n        }\n        /* eslint-disable no-console */\n\n        console.warn('Chunked uploading is enabled, but not supported by your browser. You may need to enable HTTPS.');\n        /* eslint-enable no-console */\n      }\n\n      var plainUploadAPI = factory.getPlainUploadAPI();\n      if (isUploadFallbackLogicEnabled) {\n        plainUploadAPI.isUploadFallbackLogicEnabled = true;\n      }\n      return plainUploadAPI;\n    }\n    /**\n     * Removes an item from the upload queue. Cancels upload if in progress.\n     *\n     * @param {UploadItem} item - Item to remove\n     * @return {void}\n     */\n  }, {\n    key: \"uploadFile\",\n    /**\n     * Helper to upload a single file.\n     *\n     * @param {UploadItem} item - Upload item object\n     * @return {void}\n     */\n    value: function uploadFile(item) {\n      var _this2 = this;\n      var _this$props12 = this.props,\n        overwrite = _this$props12.overwrite,\n        rootFolderId = _this$props12.rootFolderId;\n      var api = item.api,\n        file = item.file,\n        options = item.options;\n      var items = this.state.items;\n      var numItemsUploading = items.filter(function (item_t) {\n        return item_t.status === STATUS_IN_PROGRESS;\n      }).length;\n      if (numItemsUploading >= UPLOAD_CONCURRENCY) {\n        return;\n      }\n      var uploadOptions = {\n        file: file,\n        folderId: options && options.folderId ? options.folderId : rootFolderId,\n        errorCallback: function errorCallback(error) {\n          return _this2.handleUploadError(item, error);\n        },\n        progressCallback: function progressCallback(event) {\n          return _this2.handleUploadProgress(item, event);\n        },\n        successCallback: function successCallback(entries) {\n          return _this2.handleUploadSuccess(item, entries);\n        },\n        overwrite: overwrite,\n        fileId: options && options.fileId ? options.fileId : null\n      };\n      item.status = STATUS_IN_PROGRESS;\n      items[items.indexOf(item)] = item;\n      api.upload(uploadOptions);\n      this.updateViewAndCollection(items);\n    }\n    /**\n     * Helper to resume uploading a single file.\n     *\n     * @param {UploadItem} item - Upload item object\n     * @return {void}\n     */\n  }, {\n    key: \"resumeFile\",\n    value: function resumeFile(item) {\n      var _this3 = this;\n      var _this$props13 = this.props,\n        overwrite = _this$props13.overwrite,\n        rootFolderId = _this$props13.rootFolderId,\n        onResume = _this$props13.onResume;\n      var api = item.api,\n        file = item.file,\n        options = item.options;\n      var items = this.state.items;\n      var numItemsUploading = items.filter(function (item_t) {\n        return item_t.status === STATUS_IN_PROGRESS;\n      }).length;\n      if (numItemsUploading >= UPLOAD_CONCURRENCY) {\n        return;\n      }\n      var resumeOptions = {\n        file: file,\n        folderId: options && options.folderId ? options.folderId : rootFolderId,\n        errorCallback: function errorCallback(error) {\n          return _this3.handleUploadError(item, error);\n        },\n        progressCallback: function progressCallback(event) {\n          return _this3.handleUploadProgress(item, event);\n        },\n        successCallback: function successCallback(entries) {\n          return _this3.handleUploadSuccess(item, entries);\n        },\n        overwrite: overwrite,\n        sessionId: api && api.sessionId ? api.sessionId : null,\n        fileId: options && options.fileId ? options.fileId : null\n      };\n      item.status = STATUS_IN_PROGRESS;\n      delete item.error;\n      items[items.indexOf(item)] = item;\n      onResume(item);\n      api.resume(resumeOptions);\n      this.updateViewAndCollection(items);\n    }\n    /**\n     * Helper to reset a file. Cancels any current upload and resets progress.\n     *\n     * @param {UploadItem} item - Upload item to reset\n     * @return {void}\n     */\n  }, {\n    key: \"resetFile\",\n    value: function resetFile(item) {\n      var api = item.api,\n        file = item.file,\n        options = item.options;\n      if (api && typeof api.cancel === 'function') {\n        api.cancel();\n      } // Reset API, progress & status\n\n      item.api = this.getUploadAPI(file, options);\n      item.progress = 0;\n      item.status = STATUS_PENDING;\n      delete item.error;\n      var items = this.state.items;\n      items[items.indexOf(item)] = item;\n      this.updateViewAndCollection(items);\n    }\n    /**\n     * Handles a successful upload.\n     *\n     * @private\n     * @param {UploadItem} item - Upload item corresponding to success event\n     * @param {BoxItem[]} entries - Successfully uploaded Box File objects\n     * @return {void}\n     */\n  }, {\n    key: \"updateViewAndCollection\",\n    /**\n     * Updates view and internal upload collection with provided items.\n     *\n     * @private\n     * @param {UploadItem[]} item - Items to update collection with\n     * @param {Function} callback\n     * @return {void}\n     */\n    value: function updateViewAndCollection(items, callback) {\n      var _this$props14 = this.props,\n        onComplete = _this$props14.onComplete,\n        useUploadsManager = _this$props14.useUploadsManager,\n        isResumableUploadsEnabled = _this$props14.isResumableUploadsEnabled;\n      var someUploadIsInProgress = items.some(function (uploadItem) {\n        return uploadItem.status !== STATUS_COMPLETE;\n      });\n      var someUploadHasFailed = items.some(function (uploadItem) {\n        return uploadItem.status === STATUS_ERROR;\n      });\n      var allItemsArePending = !items.some(function (uploadItem) {\n        return uploadItem.status !== STATUS_PENDING;\n      });\n      var noFileIsPendingOrInProgress = items.every(function (uploadItem) {\n        return uploadItem.status !== STATUS_PENDING && uploadItem.status !== STATUS_IN_PROGRESS;\n      });\n      var areAllItemsFinished = items.every(function (uploadItem) {\n        return uploadItem.status === STATUS_COMPLETE || uploadItem.status === STATUS_ERROR;\n      });\n      var uploadItemsStatus = isResumableUploadsEnabled ? areAllItemsFinished : noFileIsPendingOrInProgress;\n      var view = '';\n      if (items && items.length === 0 || allItemsArePending) {\n        view = VIEW_UPLOAD_EMPTY;\n      } else if (someUploadHasFailed && useUploadsManager) {\n        view = VIEW_ERROR;\n      } else if (someUploadIsInProgress) {\n        view = VIEW_UPLOAD_IN_PROGRESS;\n      } else {\n        view = VIEW_UPLOAD_SUCCESS;\n        if (!useUploadsManager) {\n          onComplete(cloneDeep(items.map(function (item) {\n            return item.boxFile;\n          }))); // Reset item collection after successful upload\n\n          items = [];\n        }\n      }\n      if (uploadItemsStatus && useUploadsManager) {\n        if (this.isAutoExpanded) {\n          this.resetUploadManagerExpandState();\n        } // Else manually expanded so don't close\n\n        onComplete(items);\n      }\n      var state = {\n        items: items,\n        view: view\n      };\n      if (items.length === 0) {\n        state.itemIds = {};\n        state.errorCode = '';\n      }\n      this.setState(state, callback);\n    }\n    /**\n     * Handles an upload error.\n     *\n     * @private\n     * @param {UploadItem} item - Upload item corresponding to error\n     * @param {Error} error - Upload error\n     * @return {void}\n     */\n  }, {\n    key: \"render\",\n    /**\n     * Renders the content uploader\n     *\n     * @inheritdoc\n     * @return {Component}\n     */\n    value: function render() {\n      var _this$props15 = this.props,\n        language = _this$props15.language,\n        messages = _this$props15.messages,\n        onClose = _this$props15.onClose,\n        className = _this$props15.className,\n        measureRef = _this$props15.measureRef,\n        isTouch = _this$props15.isTouch,\n        fileLimit = _this$props15.fileLimit,\n        useUploadsManager = _this$props15.useUploadsManager,\n        isResumableUploadsEnabled = _this$props15.isResumableUploadsEnabled,\n        isFolderUploadEnabled = _this$props15.isFolderUploadEnabled,\n        _this$props15$isDragg = _this$props15.isDraggingItemsToUploadsManager,\n        isDraggingItemsToUploadsManager = _this$props15$isDragg === void 0 ? false : _this$props15$isDragg;\n      var _this$state3 = this.state,\n        view = _this$state3.view,\n        items = _this$state3.items,\n        errorCode = _this$state3.errorCode,\n        isUploadsManagerExpanded = _this$state3.isUploadsManagerExpanded;\n      var isEmpty = items.length === 0;\n      var isVisible = !isEmpty || !!isDraggingItemsToUploadsManager;\n      var hasFiles = items.length !== 0;\n      var isLoading = items.some(function (item) {\n        return item.status === STATUS_IN_PROGRESS;\n      });\n      var isDone = items.every(function (item) {\n        return item.status === STATUS_COMPLETE || item.status === STATUS_STAGED;\n      });\n      var styleClassName = classNames('bcu', className, {\n        'be-app-element': !useUploadsManager,\n        be: !useUploadsManager\n      });\n      return React.createElement(Internationalize, {\n        language: language,\n        messages: messages\n      }, useUploadsManager ? React.createElement(\"div\", {\n        ref: measureRef,\n        className: styleClassName,\n        id: this.id\n      }, React.createElement(UploadsManager, {\n        isDragging: isDraggingItemsToUploadsManager,\n        isExpanded: isUploadsManagerExpanded,\n        isResumableUploadsEnabled: isResumableUploadsEnabled,\n        isVisible: isVisible,\n        items: items,\n        onItemActionClick: this.onClick,\n        onRemoveActionClick: this.removeFileFromUploadQueue,\n        onUploadsManagerActionClick: this.clickAllWithStatus,\n        toggleUploadsManager: this.toggleUploadsManager,\n        view: view\n      })) : React.createElement(\"div\", {\n        ref: measureRef,\n        className: styleClassName,\n        id: this.id\n      }, React.createElement(DroppableContent, {\n        addDataTransferItemsToUploadQueue: this.addDroppedItemsToUploadQueue,\n        addFiles: this.addFilesToUploadQueue,\n        allowedTypes: ['Files'],\n        isFolderUploadEnabled: isFolderUploadEnabled,\n        isTouch: isTouch,\n        items: items,\n        onClick: this.onClick,\n        view: view\n      }), React.createElement(Footer, {\n        errorCode: errorCode,\n        fileLimit: fileLimit,\n        hasFiles: hasFiles,\n        isLoading: isLoading,\n        onCancel: this.cancel,\n        onClose: onClose,\n        onUpload: this.upload,\n        isDone: isDone\n      })));\n    }\n  }]);\n  return ContentUploader;\n}(Component);\n_defineProperty(ContentUploader, \"defaultProps\", {\n  rootFolderId: DEFAULT_ROOT,\n  apiHost: DEFAULT_HOSTNAME_API,\n  chunked: true,\n  className: '',\n  clientName: CLIENT_NAME_CONTENT_UPLOADER,\n  fileLimit: FILE_LIMIT_DEFAULT,\n  uploadHost: DEFAULT_HOSTNAME_UPLOAD,\n  onBeforeUpload: noop,\n  onClickCancel: noop,\n  onClickResume: noop,\n  onClickRetry: noop,\n  onClose: noop,\n  onComplete: noop,\n  onError: noop,\n  onResume: noop,\n  onUpload: noop,\n  onProgress: noop,\n  overwrite: true,\n  useUploadsManager: false,\n  files: [],\n  onMinimize: noop,\n  onCancel: noop,\n  isFolderUploadEnabled: false,\n  isResumableUploadsEnabled: false,\n  isUploadFallbackLogicEnabled: false,\n  dataTransferItems: [],\n  isDraggingItemsToUploadsManager: false\n});\nexport default makeResponsive(ContentUploader);\nexport { ContentUploader as ContentUploaderComponent, CHUNKED_UPLOAD_MIN_SIZE_BYTES };","map":{"version":3,"sources":["../../../src/elements/content-uploader/ContentUploader.js"],"names":["React","Component","classNames","getProp","noop","uniqueid","cloneDeep","getTypedFileId","getTypedFolderId","makeResponsive","Internationalize","FolderUpload","API","getDataTransferItemId","getFileId","getFileFromDataTransferItem","getFile","getFileAPIOptions","getDataTransferItemAPIOptions","isDataTransferItemAFolder","isMultiputSupported","DroppableContent","UploadsManager","Footer","DEFAULT_ROOT","CLIENT_NAME_CONTENT_UPLOADER","DEFAULT_HOSTNAME_UPLOAD","DEFAULT_HOSTNAME_API","VIEW_ERROR","VIEW_UPLOAD_EMPTY","VIEW_UPLOAD_IN_PROGRESS","VIEW_UPLOAD_SUCCESS","STATUS_PENDING","STATUS_IN_PROGRESS","STATUS_STAGED","STATUS_COMPLETE","STATUS_ERROR","ERROR_CODE_UPLOAD_FILE_LIMIT","CHUNKED_UPLOAD_MIN_SIZE_BYTES","FILE_LIMIT_DEFAULT","HIDE_UPLOAD_MANAGER_DELAY_MS_DEFAULT","EXPAND_UPLOADS_MANAGER_ITEMS_NUM_THRESHOLD","UPLOAD_CONCURRENCY","ContentUploader","rootFolderId","apiHost","chunked","className","clientName","fileLimit","uploadHost","onBeforeUpload","onClickCancel","onClickResume","onClickRetry","onClose","onComplete","onError","onResume","onUpload","onProgress","overwrite","useUploadsManager","files","onMinimize","onCancel","isFolderUploadEnabled","isResumableUploadsEnabled","isUploadFallbackLogicEnabled","dataTransferItems","isDraggingItemsToUploadsManager","props","token","state","view","items","errorCode","itemIds","isUploadsManagerExpanded","id","rootElement","document","getElementById","appElement","cancel","hasFiles","Array","isArray","length","hasItems","hasUploads","addFilesWithOptionsToUploadQueueAndStartUpload","uploadAPIOptions","folderId","fileId","itemFolderId","itemFileId","getBaseAPIOptions","sharedLink","sharedLinkPassword","requestInterceptor","responseInterceptor","from","filter","file","item","itemUpdateCallback","isRelativePathIgnored","newFiles","getNewFiles","newItemIds","forEach","clearTimeout","resetItemsTimeout","firstFile","setState","webkitRelativePath","addFilesWithRelativePathToQueue","addFilesWithoutRelativePathToQueue","droppedItems","addDataTransferItemsToUploadQueue","addFilesToUploadQueue","folderItems","fileItems","isDirectory","push","addFileDataTransferItemsToUploadQueue","addFolderDataTransferItemsToUploadQueue","newItems","getNewDataTransferItems","fileAPIOptions","folderUpload","getFolderUploadAPI","buildFolderTreeFromDataTransferItem","addFolderToUploadQueue","buildFolderTreeFromWebkitRelativePath","uploadBaseAPIOptions","addToQueue","apiOptions","api","extension","isFolder","name","folder","options","progress","size","status","map","uploadFile","substr","lastIndexOf","getUploadAPI","uploadItem","updatedItems","prevItemsNum","totalNumOfItems","concat","slice","isAutoExpanded","expandUploadsManager","updateViewAndCollection","upload","factory","createAPIFactory","chunkedUploadAPI","getChunkedUploadAPI","console","warn","plainUploadAPI","getPlainUploadAPI","splice","indexOf","minimizeUploadsManager","numItemsUploading","item_t","uploadOptions","errorCallback","handleUploadError","error","progressCallback","handleUploadProgress","event","successCallback","handleUploadSuccess","entries","resumeOptions","sessionId","resume","boxFile","checkClearUploadItems","callback","someUploadIsInProgress","some","someUploadHasFailed","allItemsArePending","noFileIsPendingOrInProgress","every","areAllItemsFinished","uploadItemsStatus","resetUploadManagerExpandState","index","findIndex","singleItem","errorData","total","Math","min","round","loaded","isChunkedUpload","isResumable","removeFileFromUploadQueue","bytesUploadedOnLastResume","totalUploadedBytes","resumeFile","resetFile","onClick","setTimeout","resetUploadsManagerItemsWhenUploadsComplete","language","messages","measureRef","isTouch","isEmpty","isVisible","isLoading","isDone","styleClassName","be","clickAllWithStatus","toggleUploadsManager","addDroppedItemsToUploadQueue","ContentUploaderComponent"],"mappings":"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","sourcesContent":["/**\n * @flow\n * @file Content Uploader component\n * @author Box\n */\n\nimport 'regenerator-runtime/runtime';\nimport React, { Component } from 'react';\nimport classNames from 'classnames';\nimport getProp from 'lodash/get';\nimport noop from 'lodash/noop';\nimport uniqueid from 'lodash/uniqueId';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { getTypedFileId, getTypedFolderId } from '../../utils/file';\nimport makeResponsive from '../common/makeResponsive';\nimport Internationalize from '../common/Internationalize';\nimport FolderUpload from '../../api/uploads/FolderUpload';\nimport API from '../../api';\nimport {\n    getDataTransferItemId,\n    getFileId,\n    getFileFromDataTransferItem,\n    getFile,\n    getFileAPIOptions,\n    getDataTransferItemAPIOptions,\n    isDataTransferItemAFolder,\n    isMultiputSupported,\n} from '../../utils/uploads';\nimport DroppableContent from './DroppableContent';\nimport UploadsManager from './UploadsManager';\nimport Footer from './Footer';\nimport {\n    DEFAULT_ROOT,\n    CLIENT_NAME_CONTENT_UPLOADER,\n    DEFAULT_HOSTNAME_UPLOAD,\n    DEFAULT_HOSTNAME_API,\n    VIEW_ERROR,\n    VIEW_UPLOAD_EMPTY,\n    VIEW_UPLOAD_IN_PROGRESS,\n    VIEW_UPLOAD_SUCCESS,\n    STATUS_PENDING,\n    STATUS_IN_PROGRESS,\n    STATUS_STAGED,\n    STATUS_COMPLETE,\n    STATUS_ERROR,\n    ERROR_CODE_UPLOAD_FILE_LIMIT,\n} from '../../constants';\nimport type {\n    UploadItem,\n    UploadDataTransferItemWithAPIOptions,\n    UploadFileWithAPIOptions,\n    UploadFile,\n    UploadItemAPIOptions,\n    UploadStatus,\n} from '../../common/types/upload';\nimport type { StringMap, Token, View, BoxItem } from '../../common/types/core';\nimport '../common/fonts.scss';\nimport '../common/base.scss';\n\ntype Props = {\n    apiHost: string,\n    chunked: boolean,\n    className: string,\n    clientName: string,\n    dataTransferItems: Array<DataTransferItem | UploadDataTransferItemWithAPIOptions>,\n    fileLimit: number,\n    files?: Array<UploadFileWithAPIOptions | File>,\n    isDraggingItemsToUploadsManager?: boolean,\n    isFolderUploadEnabled: boolean,\n    isLarge: boolean,\n    isResumableUploadsEnabled: boolean,\n    isSmall: boolean,\n    isTouch: boolean,\n    isUploadFallbackLogicEnabled: boolean,\n    language?: string,\n    measureRef: Function,\n    messages?: StringMap,\n    onBeforeUpload: (file: Array<UploadFileWithAPIOptions | File>) => void,\n    onCancel: Function,\n    onClickCancel: UploadItem => void,\n    onClickResume: UploadItem => void,\n    onClickRetry: UploadItem => void,\n    onClose: Function,\n    onComplete: Function,\n    onError: Function,\n    onMinimize?: Function,\n    onProgress: Function,\n    onResume: Function,\n    onUpload: Function,\n    overwrite: boolean,\n    requestInterceptor?: Function,\n    responseInterceptor?: Function,\n    rootFolderId: string,\n    sharedLink?: string,\n    sharedLinkPassword?: string,\n    token?: Token,\n    uploadHost: string,\n    useUploadsManager?: boolean,\n};\n\ntype State = {\n    errorCode?: string,\n    isUploadsManagerExpanded: boolean,\n    itemIds: Object,\n    items: UploadItem[],\n    view: View,\n};\n\nconst CHUNKED_UPLOAD_MIN_SIZE_BYTES = 104857600; // 100MB\nconst FILE_LIMIT_DEFAULT = 100; // Upload at most 100 files at once by default\nconst HIDE_UPLOAD_MANAGER_DELAY_MS_DEFAULT = 8000;\nconst EXPAND_UPLOADS_MANAGER_ITEMS_NUM_THRESHOLD = 5;\nconst UPLOAD_CONCURRENCY = 6;\n\nclass ContentUploader extends Component<Props, State> {\n    id: string;\n\n    state: State;\n\n    props: Props;\n\n    rootElement: HTMLElement;\n\n    appElement: HTMLElement;\n\n    resetItemsTimeout: TimeoutID;\n\n    isAutoExpanded: boolean = false;\n\n    static defaultProps = {\n        rootFolderId: DEFAULT_ROOT,\n        apiHost: DEFAULT_HOSTNAME_API,\n        chunked: true,\n        className: '',\n        clientName: CLIENT_NAME_CONTENT_UPLOADER,\n        fileLimit: FILE_LIMIT_DEFAULT,\n        uploadHost: DEFAULT_HOSTNAME_UPLOAD,\n        onBeforeUpload: noop,\n        onClickCancel: noop,\n        onClickResume: noop,\n        onClickRetry: noop,\n        onClose: noop,\n        onComplete: noop,\n        onError: noop,\n        onResume: noop,\n        onUpload: noop,\n        onProgress: noop,\n        overwrite: true,\n        useUploadsManager: false,\n        files: [],\n        onMinimize: noop,\n        onCancel: noop,\n        isFolderUploadEnabled: false,\n        isResumableUploadsEnabled: false,\n        isUploadFallbackLogicEnabled: false,\n        dataTransferItems: [],\n        isDraggingItemsToUploadsManager: false,\n    };\n\n    /**\n     * [constructor]\n     *\n     * @return {ContentUploader}\n     */\n    constructor(props: Props) {\n        super(props);\n\n        const { rootFolderId, token, useUploadsManager } = props;\n        this.state = {\n            view: (rootFolderId && token) || useUploadsManager ? VIEW_UPLOAD_EMPTY : VIEW_ERROR,\n            items: [],\n            errorCode: '',\n            itemIds: {},\n            isUploadsManagerExpanded: false,\n        };\n        this.id = uniqueid('bcu_');\n    }\n\n    /**\n     * Fetches the root folder on load\n     *\n     * @private\n     * @inheritdoc\n     * @return {void}\n     */\n    componentDidMount() {\n        this.rootElement = ((document.getElementById(this.id): any): HTMLElement);\n        this.appElement = this.rootElement;\n    }\n\n    /**\n     * Cancels pending uploads\n     *\n     * @private\n     * @inheritdoc\n     * @return {void}\n     */\n    componentWillUnmount() {\n        this.cancel();\n    }\n\n    /**\n     * Adds new items to the queue when files prop gets updated in window view\n     *\n     * @return {void}\n     */\n    componentDidUpdate(): void {\n        const { files, dataTransferItems, useUploadsManager } = this.props;\n\n        const hasFiles = Array.isArray(files) && files.length > 0;\n        const hasItems = Array.isArray(dataTransferItems) && dataTransferItems.length > 0;\n        const hasUploads = hasFiles || hasItems;\n\n        if (!useUploadsManager || !hasUploads) {\n            return;\n        }\n\n        this.addFilesWithOptionsToUploadQueueAndStartUpload(files, dataTransferItems);\n    }\n\n    /**\n     * Create and return new instance of API creator\n     *\n     * @param {UploadItemAPIOptions} [uploadAPIOptions]\n     * @return {API}\n     */\n    createAPIFactory(uploadAPIOptions?: UploadItemAPIOptions): API {\n        const { rootFolderId } = this.props;\n        const folderId = getProp(uploadAPIOptions, 'folderId') || rootFolderId;\n        const fileId = getProp(uploadAPIOptions, 'fileId');\n        const itemFolderId = getTypedFolderId(folderId);\n        const itemFileId = fileId ? getTypedFileId(fileId) : null;\n\n        return new API({\n            ...this.getBaseAPIOptions(),\n            id: itemFileId || itemFolderId,\n            ...uploadAPIOptions,\n        });\n    }\n\n    /**\n     * Return base API options from props\n     *\n     * @private\n     * @returns {Object}\n     */\n    getBaseAPIOptions = (): Object => {\n        const {\n            token,\n            sharedLink,\n            sharedLinkPassword,\n            apiHost,\n            uploadHost,\n            clientName,\n            requestInterceptor,\n            responseInterceptor,\n        } = this.props;\n\n        return {\n            token,\n            sharedLink,\n            sharedLinkPassword,\n            apiHost,\n            uploadHost,\n            clientName,\n            requestInterceptor,\n            responseInterceptor,\n        };\n    };\n\n    /**\n     * Given an array of files, return the files that are new to the Content Uploader\n     *\n     * @param {Array<UploadFileWithAPIOptions | File>} files\n     */\n    getNewFiles = (files: Array<UploadFileWithAPIOptions | File>): Array<UploadFileWithAPIOptions | File> => {\n        const { rootFolderId } = this.props;\n        const { itemIds } = this.state;\n\n        return Array.from(files).filter(file => !itemIds[getFileId(file, rootFolderId)]);\n    };\n\n    /**\n     * Given an array of files, return the files that are new to the Content Uploader\n     *\n     * @param {Array<UploadFileWithAPIOptions | File>} files\n     */\n    getNewDataTransferItems = (\n        items: Array<DataTransferItem | UploadDataTransferItemWithAPIOptions>,\n    ): Array<DataTransferItem | UploadDataTransferItemWithAPIOptions> => {\n        const { rootFolderId } = this.props;\n        const { itemIds } = this.state;\n\n        return Array.from(items).filter(item => !itemIds[getDataTransferItemId(item, rootFolderId)]);\n    };\n\n    /**\n     * Converts File API to upload items and adds to upload queue.\n     *\n     * @private\n     * @param {Array<UploadFileWithAPIOptions | UploadFile>} files - Files to be added to upload queue\n     * @param {Function} itemUpdateCallback - function to be invoked after items status are updated\n     * @param {boolean} [isRelativePathIgnored] - if true webkitRelativePath property is ignored\n     * @return {void}\n     */\n    addFilesToUploadQueue = (\n        files?: Array<UploadFileWithAPIOptions | UploadFile>,\n        itemUpdateCallback: Function,\n        isRelativePathIgnored?: boolean = false,\n    ) => {\n        const { onBeforeUpload, rootFolderId } = this.props;\n        if (!files || files.length === 0) {\n            return;\n        }\n\n        const newFiles = this.getNewFiles(files);\n\n        if (newFiles.length === 0) {\n            return;\n        }\n\n        const newItemIds = {};\n\n        newFiles.forEach(file => {\n            newItemIds[getFileId(file, rootFolderId)] = true;\n        });\n\n        clearTimeout(this.resetItemsTimeout);\n\n        const firstFile = getFile(newFiles[0]);\n\n        this.setState(\n            state => ({\n                itemIds: {\n                    ...state.itemIds,\n                    ...newItemIds,\n                },\n            }),\n            () => {\n                onBeforeUpload(newFiles);\n                if (firstFile.webkitRelativePath && !isRelativePathIgnored) {\n                    // webkitRelativePath should be ignored when the upload destination folder is known\n                    this.addFilesWithRelativePathToQueue(newFiles, itemUpdateCallback);\n                } else {\n                    this.addFilesWithoutRelativePathToQueue(newFiles, itemUpdateCallback);\n                }\n            },\n        );\n    };\n\n    /**\n     * Add dropped items to the upload queue\n     *\n     * @private\n     * @param {DataTransfer} droppedItems\n     * @param {Function} itemUpdateCallback\n     * @returns {Promise<any>}\n     */\n    addDroppedItemsToUploadQueue = (droppedItems: DataTransfer, itemUpdateCallback: Function): void => {\n        if (droppedItems.items) {\n            this.addDataTransferItemsToUploadQueue(droppedItems.items, itemUpdateCallback);\n        } else {\n            Array.from(droppedItems.files).forEach(file => {\n                this.addFilesToUploadQueue([file], itemUpdateCallback);\n            });\n        }\n    };\n\n    /**\n     * Add dataTransferItems to the upload queue\n     *\n     * @private\n     * @param {DataTransferItemList} dataTransferItems\n     * @param {Function} itemUpdateCallback\n     * @returns {Promise<any>}\n     */\n    addDataTransferItemsToUploadQueue = (\n        dataTransferItems: DataTransferItemList | Array<DataTransferItem | UploadDataTransferItemWithAPIOptions>,\n        itemUpdateCallback: Function,\n    ): void => {\n        const { isFolderUploadEnabled } = this.props;\n        if (!dataTransferItems || dataTransferItems.length === 0) {\n            return;\n        }\n\n        const folderItems = [];\n        const fileItems = [];\n\n        Array.from(dataTransferItems).forEach(item => {\n            const isDirectory = isDataTransferItemAFolder(item);\n            if (isDirectory && isFolderUploadEnabled) {\n                folderItems.push(item);\n            } else if (!isDirectory) {\n                fileItems.push(item);\n            }\n        });\n\n        this.addFileDataTransferItemsToUploadQueue(fileItems, itemUpdateCallback);\n        this.addFolderDataTransferItemsToUploadQueue(folderItems, itemUpdateCallback);\n    };\n\n    /**\n     * Add dataTransferItem of file type to the upload queue\n     *\n     * @private\n     * @param {Array<DataTransferItem | UploadDataTransferItemWithAPIOptions>} dataTransferItems\n     * @param {Function} itemUpdateCallback\n     * @returns {void}\n     */\n    addFileDataTransferItemsToUploadQueue = (\n        dataTransferItems: Array<DataTransferItem | UploadDataTransferItemWithAPIOptions>,\n        itemUpdateCallback: Function,\n    ): void => {\n        dataTransferItems.forEach(async item => {\n            const file = await getFileFromDataTransferItem(item);\n            if (!file) {\n                return;\n            }\n\n            this.addFilesToUploadQueue([file], itemUpdateCallback);\n        });\n    };\n\n    /**\n     * Add dataTransferItem of folder type to the upload queue\n     *\n     * @private\n     * @param {Array<DataTransferItem | UploadDataTransferItemWithAPIOptions>} dataTransferItems\n     * @param {Function} itemUpdateCallback\n     * @returns {Promise<any>}\n     */\n    addFolderDataTransferItemsToUploadQueue = async (\n        dataTransferItems: Array<DataTransferItem | UploadDataTransferItemWithAPIOptions>,\n        itemUpdateCallback: Function,\n    ): Promise<any> => {\n        const { rootFolderId } = this.props;\n        const { itemIds } = this.state;\n        if (dataTransferItems.length === 0) {\n            return;\n        }\n\n        const newItems = this.getNewDataTransferItems(dataTransferItems);\n        newItems.forEach(item => {\n            itemIds[getDataTransferItemId(item, rootFolderId)] = true;\n        });\n\n        if (newItems.length === 0) {\n            return;\n        }\n\n        const fileAPIOptions: Object = getDataTransferItemAPIOptions(newItems[0]);\n        const { folderId = rootFolderId } = fileAPIOptions;\n\n        newItems.forEach(async item => {\n            const folderUpload = this.getFolderUploadAPI(folderId);\n            await folderUpload.buildFolderTreeFromDataTransferItem(item);\n            this.addFolderToUploadQueue(folderUpload, itemUpdateCallback, fileAPIOptions);\n        });\n    };\n\n    /**\n     * Converts File API to upload items and adds to upload queue for files with webkitRelativePath.\n     *\n     * @private\n     * @param {Array<UploadFileWithAPIOptions | File>} files - Files to be added to upload queue\n     * @param {Function} itemUpdateCallback - function to be invoked after items status are updated\n     * @return {void}\n     */\n    addFilesWithRelativePathToQueue(files: Array<UploadFileWithAPIOptions | File>, itemUpdateCallback: Function) {\n        if (files.length === 0) {\n            return;\n        }\n\n        const { rootFolderId } = this.props;\n        const fileAPIOptions: Object = getFileAPIOptions(files[0]);\n        const { folderId = rootFolderId } = fileAPIOptions;\n        const folderUpload = this.getFolderUploadAPI(folderId);\n\n        // Only 1 folder tree can be built with files having webkitRelativePath properties\n        folderUpload.buildFolderTreeFromWebkitRelativePath(files);\n\n        this.addFolderToUploadQueue(folderUpload, itemUpdateCallback, fileAPIOptions);\n    }\n\n    /**\n     * Get folder upload API instance\n     *\n     * @private\n     * @param {string} folderId\n     * @return {FolderUpload}\n     */\n    getFolderUploadAPI = (folderId: string): FolderUpload => {\n        const uploadBaseAPIOptions = this.getBaseAPIOptions();\n\n        return new FolderUpload(this.addFilesToUploadQueue, folderId, this.addToQueue, uploadBaseAPIOptions);\n    };\n\n    /**\n     * Add folder to upload queue\n     *\n     * @private\n     * @param {FolderUpload} folderUpload\n     * @param {Function} itemUpdateCallback\n     * @param {Object} apiOptions\n     * @return {void}\n     */\n    addFolderToUploadQueue = (folderUpload: FolderUpload, itemUpdateCallback: Function, apiOptions: Object): void => {\n        this.addToQueue(\n            [\n                // $FlowFixMe no file property\n                {\n                    api: folderUpload,\n                    extension: '',\n                    isFolder: true,\n                    name: folderUpload.folder.name,\n                    options: apiOptions,\n                    progress: 0,\n                    size: 1,\n                    status: STATUS_PENDING,\n                },\n            ],\n            itemUpdateCallback,\n        );\n    };\n\n    /**\n     * Converts File API to upload items and adds to upload queue for files with webkitRelativePath missing or ignored.\n     *\n     * @private\n     * @param {Array<UploadFileWithAPIOptions | File>} files - Files to be added to upload queue\n     * @param {Function} itemUpdateCallback - function to be invoked after items status are updated\n     * @return {void}\n     */\n    addFilesWithoutRelativePathToQueue = (\n        files: Array<UploadFileWithAPIOptions | File>,\n        itemUpdateCallback: Function,\n    ) => {\n        const { itemIds } = this.state;\n        const { rootFolderId } = this.props;\n\n        // Convert files from the file API to upload items\n        const newItems = files.map(file => {\n            const uploadFile = getFile(file);\n            const uploadAPIOptions = getFileAPIOptions(file);\n            const { name, size } = uploadFile;\n\n            // Extract extension or use empty string if file has no extension\n            let extension = name.substr(name.lastIndexOf('.') + 1);\n            if (extension.length === name.length) {\n                extension = '';\n            }\n\n            const api = this.getUploadAPI(uploadFile, uploadAPIOptions);\n            const uploadItem: Object = {\n                api,\n                extension,\n                file: uploadFile,\n                name,\n                progress: 0,\n                size,\n                status: STATUS_PENDING,\n            };\n\n            if (uploadAPIOptions) {\n                uploadItem.options = uploadAPIOptions;\n            }\n\n            itemIds[getFileId(uploadItem, rootFolderId)] = true;\n\n            return uploadItem;\n        });\n\n        if (newItems.length === 0) {\n            return;\n        }\n\n        this.setState({\n            itemIds,\n        });\n        this.addToQueue(newItems, itemUpdateCallback);\n    };\n\n    /**\n     * Add new items to the upload queue\n     *\n     * @private\n     * @param {Array<UploadFileWithAPIOptions | File>} newItems - Files to be added to upload queue\n     * @param {Function} itemUpdateCallback - function to be invoked after items status are updated\n     * @return {void}\n     */\n    addToQueue = (newItems: UploadItem[], itemUpdateCallback: Function) => {\n        const { fileLimit, useUploadsManager } = this.props;\n        const { items, isUploadsManagerExpanded } = this.state;\n\n        let updatedItems = [];\n        const prevItemsNum = items.length;\n        const totalNumOfItems = prevItemsNum + newItems.length;\n\n        // Don't add more than fileLimit # of items\n        if (totalNumOfItems > fileLimit) {\n            updatedItems = items.concat(newItems.slice(0, fileLimit - items.length));\n            this.setState({\n                errorCode: ERROR_CODE_UPLOAD_FILE_LIMIT,\n            });\n        } else {\n            updatedItems = items.concat(newItems);\n            this.setState({ errorCode: '' });\n\n            // If the number of items being uploaded passes the threshold, expand the upload manager\n            if (\n                prevItemsNum < EXPAND_UPLOADS_MANAGER_ITEMS_NUM_THRESHOLD &&\n                totalNumOfItems >= EXPAND_UPLOADS_MANAGER_ITEMS_NUM_THRESHOLD &&\n                useUploadsManager &&\n                !isUploadsManagerExpanded\n            ) {\n                this.isAutoExpanded = true;\n                this.expandUploadsManager();\n            }\n        }\n\n        this.updateViewAndCollection(updatedItems, () => {\n            if (itemUpdateCallback) {\n                itemUpdateCallback();\n            }\n\n            const { view } = this.state;\n            // Automatically start upload if other files are being uploaded\n            if (view === VIEW_UPLOAD_IN_PROGRESS) {\n                this.upload();\n            }\n        });\n    };\n\n    /**\n     * Returns a new API instance for the given file.\n     *\n     * @private\n     * @param {File} file - File to get a new API instance for\n     * @param {UploadItemAPIOptions} [uploadAPIOptions]\n     * @return {UploadAPI} - Instance of Upload API\n     */\n    getUploadAPI(file: File, uploadAPIOptions?: UploadItemAPIOptions) {\n        const { chunked, isResumableUploadsEnabled, isUploadFallbackLogicEnabled } = this.props;\n        const { size } = file;\n        const factory = this.createAPIFactory(uploadAPIOptions);\n\n        if (chunked && size > CHUNKED_UPLOAD_MIN_SIZE_BYTES) {\n            if (isMultiputSupported()) {\n                const chunkedUploadAPI = factory.getChunkedUploadAPI();\n                if (isResumableUploadsEnabled) {\n                    chunkedUploadAPI.isResumableUploadsEnabled = true;\n                }\n                if (isUploadFallbackLogicEnabled) {\n                    chunkedUploadAPI.isUploadFallbackLogicEnabled = true;\n                }\n                return chunkedUploadAPI;\n            }\n\n            /* eslint-disable no-console */\n            console.warn(\n                'Chunked uploading is enabled, but not supported by your browser. You may need to enable HTTPS.',\n            );\n            /* eslint-enable no-console */\n        }\n\n        const plainUploadAPI = factory.getPlainUploadAPI();\n        if (isUploadFallbackLogicEnabled) {\n            plainUploadAPI.isUploadFallbackLogicEnabled = true;\n        }\n\n        return plainUploadAPI;\n    }\n\n    /**\n     * Removes an item from the upload queue. Cancels upload if in progress.\n     *\n     * @param {UploadItem} item - Item to remove\n     * @return {void}\n     */\n    removeFileFromUploadQueue = (item: UploadItem) => {\n        const { onCancel, useUploadsManager } = this.props;\n        const { items } = this.state;\n        // Clear any error errorCode in footer\n        this.setState({ errorCode: '' });\n\n        const { api } = item;\n        api.cancel();\n\n        items.splice(items.indexOf(item), 1);\n\n        onCancel([item]);\n        this.updateViewAndCollection(items, () => {\n            // Minimize uploads manager if there are no more items\n            if (useUploadsManager && !items.length) {\n                this.minimizeUploadsManager();\n            }\n\n            const { view } = this.state;\n            if (view === VIEW_UPLOAD_IN_PROGRESS) {\n                this.upload();\n            }\n        });\n    };\n\n    /**\n     * Aborts uploads in progress and clears upload list.\n     *\n     * @private\n     * @return {void}\n     */\n    cancel = () => {\n        const { items } = this.state;\n        items.forEach(uploadItem => {\n            const { api, status } = uploadItem;\n            if (status === STATUS_IN_PROGRESS) {\n                api.cancel();\n            }\n        });\n\n        // Reset upload collection\n        this.updateViewAndCollection([]);\n    };\n\n    /**\n     * Uploads all items in the upload collection.\n     *\n     * @private\n     * @return {void}\n     */\n    upload = () => {\n        const { items } = this.state;\n        items.forEach(uploadItem => {\n            if (uploadItem.status === STATUS_PENDING) {\n                this.uploadFile(uploadItem);\n            }\n        });\n    };\n\n    /**\n     * Helper to upload a single file.\n     *\n     * @param {UploadItem} item - Upload item object\n     * @return {void}\n     */\n    uploadFile(item: UploadItem) {\n        const { overwrite, rootFolderId } = this.props;\n        const { api, file, options } = item;\n        const { items } = this.state;\n\n        const numItemsUploading = items.filter(item_t => item_t.status === STATUS_IN_PROGRESS).length;\n\n        if (numItemsUploading >= UPLOAD_CONCURRENCY) {\n            return;\n        }\n\n        const uploadOptions: Object = {\n            file,\n            folderId: options && options.folderId ? options.folderId : rootFolderId,\n            errorCallback: error => this.handleUploadError(item, error),\n            progressCallback: event => this.handleUploadProgress(item, event),\n            successCallback: entries => this.handleUploadSuccess(item, entries),\n            overwrite,\n            fileId: options && options.fileId ? options.fileId : null,\n        };\n\n        item.status = STATUS_IN_PROGRESS;\n        items[items.indexOf(item)] = item;\n\n        api.upload(uploadOptions);\n\n        this.updateViewAndCollection(items);\n    }\n\n    /**\n     * Helper to resume uploading a single file.\n     *\n     * @param {UploadItem} item - Upload item object\n     * @return {void}\n     */\n    resumeFile(item: UploadItem) {\n        const { overwrite, rootFolderId, onResume } = this.props;\n        const { api, file, options } = item;\n        const { items } = this.state;\n\n        const numItemsUploading = items.filter(item_t => item_t.status === STATUS_IN_PROGRESS).length;\n\n        if (numItemsUploading >= UPLOAD_CONCURRENCY) {\n            return;\n        }\n\n        const resumeOptions: Object = {\n            file,\n            folderId: options && options.folderId ? options.folderId : rootFolderId,\n            errorCallback: error => this.handleUploadError(item, error),\n            progressCallback: event => this.handleUploadProgress(item, event),\n            successCallback: entries => this.handleUploadSuccess(item, entries),\n            overwrite,\n            sessionId: api && api.sessionId ? api.sessionId : null,\n            fileId: options && options.fileId ? options.fileId : null,\n        };\n\n        item.status = STATUS_IN_PROGRESS;\n        delete item.error;\n        items[items.indexOf(item)] = item;\n\n        onResume(item);\n        api.resume(resumeOptions);\n\n        this.updateViewAndCollection(items);\n    }\n\n    /**\n     * Helper to reset a file. Cancels any current upload and resets progress.\n     *\n     * @param {UploadItem} item - Upload item to reset\n     * @return {void}\n     */\n    resetFile(item: UploadItem) {\n        const { api, file, options } = item;\n        if (api && typeof api.cancel === 'function') {\n            api.cancel();\n        }\n\n        // Reset API, progress & status\n        item.api = this.getUploadAPI(file, options);\n        item.progress = 0;\n        item.status = STATUS_PENDING;\n        delete item.error;\n\n        const { items } = this.state;\n        items[items.indexOf(item)] = item;\n\n        this.updateViewAndCollection(items);\n    }\n\n    /**\n     * Handles a successful upload.\n     *\n     * @private\n     * @param {UploadItem} item - Upload item corresponding to success event\n     * @param {BoxItem[]} entries - Successfully uploaded Box File objects\n     * @return {void}\n     */\n    handleUploadSuccess = (item: UploadItem, entries?: BoxItem[]) => {\n        const { onUpload, useUploadsManager } = this.props;\n\n        item.progress = 100;\n        if (!item.error) {\n            item.status = STATUS_COMPLETE;\n        }\n\n        // Cache Box File object of successfully uploaded item\n        if (entries && entries.length === 1) {\n            const [boxFile] = entries;\n            item.boxFile = boxFile;\n        }\n\n        const { items } = this.state;\n        items[items.indexOf(item)] = item;\n\n        // Broadcast that a file has been uploaded\n        if (useUploadsManager) {\n            onUpload(item);\n            this.checkClearUploadItems();\n        } else {\n            onUpload(item.boxFile);\n        }\n\n        this.updateViewAndCollection(items, () => {\n            const { view } = this.state;\n            if (view === VIEW_UPLOAD_IN_PROGRESS) {\n                this.upload();\n            }\n        });\n    };\n\n    resetUploadManagerExpandState = () => {\n        this.isAutoExpanded = false;\n        this.setState({\n            isUploadsManagerExpanded: false,\n        });\n    };\n\n    /**\n     * Updates view and internal upload collection with provided items.\n     *\n     * @private\n     * @param {UploadItem[]} item - Items to update collection with\n     * @param {Function} callback\n     * @return {void}\n     */\n    updateViewAndCollection(items: UploadItem[], callback?: Function) {\n        const { onComplete, useUploadsManager, isResumableUploadsEnabled }: Props = this.props;\n        const someUploadIsInProgress = items.some(uploadItem => uploadItem.status !== STATUS_COMPLETE);\n        const someUploadHasFailed = items.some(uploadItem => uploadItem.status === STATUS_ERROR);\n        const allItemsArePending = !items.some(uploadItem => uploadItem.status !== STATUS_PENDING);\n        const noFileIsPendingOrInProgress = items.every(\n            uploadItem => uploadItem.status !== STATUS_PENDING && uploadItem.status !== STATUS_IN_PROGRESS,\n        );\n        const areAllItemsFinished = items.every(\n            uploadItem => uploadItem.status === STATUS_COMPLETE || uploadItem.status === STATUS_ERROR,\n        );\n        const uploadItemsStatus = isResumableUploadsEnabled ? areAllItemsFinished : noFileIsPendingOrInProgress;\n\n        let view = '';\n        if ((items && items.length === 0) || allItemsArePending) {\n            view = VIEW_UPLOAD_EMPTY;\n        } else if (someUploadHasFailed && useUploadsManager) {\n            view = VIEW_ERROR;\n        } else if (someUploadIsInProgress) {\n            view = VIEW_UPLOAD_IN_PROGRESS;\n        } else {\n            view = VIEW_UPLOAD_SUCCESS;\n\n            if (!useUploadsManager) {\n                onComplete(cloneDeep(items.map(item => item.boxFile)));\n                // Reset item collection after successful upload\n                items = [];\n            }\n        }\n\n        if (uploadItemsStatus && useUploadsManager) {\n            if (this.isAutoExpanded) {\n                this.resetUploadManagerExpandState();\n            } // Else manually expanded so don't close\n            onComplete(items);\n        }\n\n        const state: Object = {\n            items,\n            view,\n        };\n\n        if (items.length === 0) {\n            state.itemIds = {};\n            state.errorCode = '';\n        }\n\n        this.setState(state, callback);\n    }\n\n    /**\n     * Handles an upload error.\n     *\n     * @private\n     * @param {UploadItem} item - Upload item corresponding to error\n     * @param {Error} error - Upload error\n     * @return {void}\n     */\n    handleUploadError = (item: UploadItem, error: Error) => {\n        const { onError, useUploadsManager } = this.props;\n        const { file } = item;\n        const { items } = this.state;\n\n        item.status = STATUS_ERROR;\n        item.error = error;\n\n        const newItems = [...items];\n        const index = newItems.findIndex(singleItem => singleItem === item);\n        if (index !== -1) {\n            newItems[index] = item;\n        }\n\n        // Broadcast that there was an error uploading a file\n        const errorData = useUploadsManager\n            ? {\n                  item,\n                  error,\n              }\n            : {\n                  file,\n                  error,\n              };\n\n        onError(errorData);\n\n        this.updateViewAndCollection(newItems, () => {\n            if (useUploadsManager) {\n                this.isAutoExpanded = true;\n                this.expandUploadsManager();\n            }\n            const { view } = this.state;\n            if (view === VIEW_UPLOAD_IN_PROGRESS) {\n                this.upload();\n            }\n        });\n    };\n\n    /**\n     * Handles an upload progress event.\n     *\n     * @private\n     * @param {UploadItem} item - Upload item corresponding to progress event\n     * @param {ProgressEvent} event - Progress event\n     * @return {void}\n     */\n    handleUploadProgress = (item: UploadItem, event: any) => {\n        if (!event.total || item.status === STATUS_COMPLETE || item.status === STATUS_STAGED) {\n            return;\n        }\n\n        item.progress = Math.min(Math.round((event.loaded / event.total) * 100), 100);\n        item.status = item.progress === 100 ? STATUS_STAGED : STATUS_IN_PROGRESS;\n\n        const { onProgress } = this.props;\n        onProgress(item);\n\n        const { items } = this.state;\n        items[items.indexOf(item)] = item;\n\n        this.updateViewAndCollection(items);\n    };\n\n    /**\n     * Updates item based on its status.\n     *\n     * @private\n     * @param {UploadItem} item - The upload item to update\n     * @return {void}\n     */\n    onClick = (item: UploadItem) => {\n        const { chunked, isResumableUploadsEnabled, onClickCancel, onClickResume, onClickRetry } = this.props;\n        const { status, file } = item;\n        const isChunkedUpload =\n            chunked && !item.isFolder && file.size > CHUNKED_UPLOAD_MIN_SIZE_BYTES && isMultiputSupported();\n        const isResumable = isResumableUploadsEnabled && isChunkedUpload && item.api.sessionId;\n\n        switch (status) {\n            case STATUS_IN_PROGRESS:\n            case STATUS_STAGED:\n            case STATUS_COMPLETE:\n            case STATUS_PENDING:\n                this.removeFileFromUploadQueue(item);\n                onClickCancel(item);\n                break;\n            case STATUS_ERROR:\n                if (isResumable) {\n                    item.bytesUploadedOnLastResume = item.api.totalUploadedBytes;\n                    this.resumeFile(item);\n                    onClickResume(item);\n                } else {\n                    this.resetFile(item);\n                    this.uploadFile(item);\n                    onClickRetry(item);\n                }\n                break;\n            default:\n                break;\n        }\n    };\n\n    /**\n     * Click action button for all uploads in the Uploads Manager with the given status.\n     *\n     * @private\n     * @param {UploadStatus} - the status that items should have for their action button to be clicked\n     * @return {void}\n     */\n    clickAllWithStatus = (status?: UploadStatus) => {\n        const { items } = this.state;\n\n        items.forEach(item => {\n            if (!status || item.status === status) {\n                this.onClick(item);\n            }\n        });\n    };\n\n    /**\n     * Expands the upload manager\n     *\n     * @return {void}\n     */\n    expandUploadsManager = (): void => {\n        const { useUploadsManager } = this.props;\n\n        if (!useUploadsManager) {\n            return;\n        }\n\n        clearTimeout(this.resetItemsTimeout);\n\n        this.setState({ isUploadsManagerExpanded: true });\n    };\n\n    /**\n     * Minimizes the upload manager\n     *\n     * @return {void}\n     */\n    minimizeUploadsManager = (): void => {\n        const { useUploadsManager, onMinimize } = this.props;\n\n        if (!useUploadsManager || !onMinimize) {\n            return;\n        }\n\n        clearTimeout(this.resetItemsTimeout);\n\n        onMinimize();\n        this.resetUploadManagerExpandState();\n        this.checkClearUploadItems();\n    };\n\n    /**\n     * Checks if the upload items should be cleared after a timeout\n     *\n     * @return {void}\n     */\n    checkClearUploadItems = () => {\n        this.resetItemsTimeout = setTimeout(\n            this.resetUploadsManagerItemsWhenUploadsComplete,\n            HIDE_UPLOAD_MANAGER_DELAY_MS_DEFAULT,\n        );\n    };\n\n    /**\n     * Toggles the upload manager\n     *\n     * @return {void}\n     */\n    toggleUploadsManager = (): void => {\n        const { isUploadsManagerExpanded } = this.state;\n\n        if (isUploadsManagerExpanded) {\n            this.minimizeUploadsManager();\n        } else {\n            this.expandUploadsManager();\n        }\n    };\n\n    /**\n     * Empties the items queue\n     *\n     * @return {void}\n     */\n    resetUploadsManagerItemsWhenUploadsComplete = (): void => {\n        const { view, items, isUploadsManagerExpanded } = this.state;\n        const { useUploadsManager, onCancel } = this.props;\n\n        // Do not reset items when upload manger is expanded or there're uploads in progress\n        if ((isUploadsManagerExpanded && useUploadsManager && !!items.length) || view === VIEW_UPLOAD_IN_PROGRESS) {\n            return;\n        }\n\n        onCancel(items);\n\n        this.setState({\n            items: [],\n            itemIds: {},\n        });\n    };\n\n    /**\n     * Adds file to the upload queue and starts upload immediately\n     *\n     * @param {Array<UploadFileWithAPIOptions | File>} files - Files to be added to upload queue\n     * @return {void}\n     */\n    addFilesWithOptionsToUploadQueueAndStartUpload = (\n        files?: Array<UploadFileWithAPIOptions | File>,\n        dataTransferItems: Array<DataTransferItem | UploadDataTransferItemWithAPIOptions>,\n    ): void => {\n        this.addFilesToUploadQueue(files, this.upload);\n        this.addDataTransferItemsToUploadQueue(dataTransferItems, this.upload);\n    };\n\n    /**\n     * Renders the content uploader\n     *\n     * @inheritdoc\n     * @return {Component}\n     */\n    render() {\n        const {\n            language,\n            messages,\n            onClose,\n            className,\n            measureRef,\n            isTouch,\n            fileLimit,\n            useUploadsManager,\n            isResumableUploadsEnabled,\n            isFolderUploadEnabled,\n            isDraggingItemsToUploadsManager = false,\n        }: Props = this.props;\n        const { view, items, errorCode, isUploadsManagerExpanded }: State = this.state;\n        const isEmpty = items.length === 0;\n        const isVisible = !isEmpty || !!isDraggingItemsToUploadsManager;\n\n        const hasFiles = items.length !== 0;\n        const isLoading = items.some(item => item.status === STATUS_IN_PROGRESS);\n        const isDone = items.every(item => item.status === STATUS_COMPLETE || item.status === STATUS_STAGED);\n\n        const styleClassName = classNames('bcu', className, {\n            'be-app-element': !useUploadsManager,\n            be: !useUploadsManager,\n        });\n\n        return (\n            <Internationalize language={language} messages={messages}>\n                {useUploadsManager ? (\n                    <div ref={measureRef} className={styleClassName} id={this.id}>\n                        <UploadsManager\n                            isDragging={isDraggingItemsToUploadsManager}\n                            isExpanded={isUploadsManagerExpanded}\n                            isResumableUploadsEnabled={isResumableUploadsEnabled}\n                            isVisible={isVisible}\n                            items={items}\n                            onItemActionClick={this.onClick}\n                            onRemoveActionClick={this.removeFileFromUploadQueue}\n                            onUploadsManagerActionClick={this.clickAllWithStatus}\n                            toggleUploadsManager={this.toggleUploadsManager}\n                            view={view}\n                        />\n                    </div>\n                ) : (\n                    <div ref={measureRef} className={styleClassName} id={this.id}>\n                        <DroppableContent\n                            addDataTransferItemsToUploadQueue={this.addDroppedItemsToUploadQueue}\n                            addFiles={this.addFilesToUploadQueue}\n                            allowedTypes={['Files']}\n                            isFolderUploadEnabled={isFolderUploadEnabled}\n                            isTouch={isTouch}\n                            items={items}\n                            onClick={this.onClick}\n                            view={view}\n                        />\n                        <Footer\n                            errorCode={errorCode}\n                            fileLimit={fileLimit}\n                            hasFiles={hasFiles}\n                            isLoading={isLoading}\n                            onCancel={this.cancel}\n                            onClose={onClose}\n                            onUpload={this.upload}\n                            isDone={isDone}\n                        />\n                    </div>\n                )}\n            </Internationalize>\n        );\n    }\n}\n\nexport type ContentUploaderProps = Props;\nexport default makeResponsive(ContentUploader);\nexport { ContentUploader as ContentUploaderComponent, CHUNKED_UPLOAD_MIN_SIZE_BYTES };\n"]},"metadata":{},"sourceType":"module"}