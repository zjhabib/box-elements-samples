{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * \n * @file Helper for the box comments API\n * @author Box\n */\nimport { COMMENTS_FIELDS_TO_FETCH } from '../utils/fields';\nimport OffsetBasedAPI from './OffsetBasedAPI';\nimport { PERMISSION_CAN_COMMENT, PERMISSION_CAN_DELETE, PERMISSION_CAN_EDIT, ERROR_CODE_CREATE_COMMENT, ERROR_CODE_UPDATE_COMMENT, ERROR_CODE_DELETE_COMMENT, ERROR_CODE_FETCH_COMMENTS } from '../constants';\nvar Comments = /*#__PURE__*/\nfunction (_OffsetBasedAPI) {\n  _inherits(Comments, _OffsetBasedAPI);\n  function Comments() {\n    var _getPrototypeOf2;\n    var _this;\n    _classCallCheck(this, Comments);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Comments)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _defineProperty(_assertThisInitialized(_this), \"successHandler\", function (data) {\n      if (_this.isDestroyed() || typeof _this.successCallback !== 'function') {\n        return;\n      } // There is no response data when deleting a comment\n\n      if (!data) {\n        _this.successCallback();\n        return;\n      } // We don't have entries when updating/creating a comment\n\n      if (!data.entries) {\n        _this.successCallback(_this.format(data));\n        return;\n      }\n      var comments = data.entries.map(_this.format);\n      _this.successCallback(_objectSpread({}, data, {\n        entries: comments\n      }));\n    });\n    return _this;\n  }\n  _createClass(Comments, [{\n    key: \"getUrl\",\n    /**\n     * API URL for comments on a file\n     *\n     * @param {string} id - A box file id\n     * @return {string} base url for files\n     */\n    value: function getUrl(id) {\n      if (!id) {\n        throw new Error('Missing file id!');\n      }\n      return \"\".concat(this.getBaseApiUrl(), \"/files/\").concat(id, \"/comments\");\n    }\n    /**\n     * API URL for comments endpoint\n     *\n     * @param {string} [id] - A box comment id\n     * @return {string} base url for comments\n     */\n  }, {\n    key: \"commentsUrl\",\n    value: function commentsUrl(id) {\n      var baseUrl = \"\".concat(this.getBaseApiUrl(), \"/comments\");\n      return id ? \"\".concat(baseUrl, \"/\").concat(id) : baseUrl;\n    }\n    /**\n     * Formats comment data for use in components.\n     *\n     * @param {string} [id] - An individual comment entry from the API\n     * @return {Task} A task\n     */\n  }, {\n    key: \"format\",\n    value: function format(comment) {\n      return _objectSpread({}, comment, {\n        tagged_message: comment.tagged_message !== '' ? comment.tagged_message : comment.message\n      });\n    }\n    /**\n     * Formats the comments api response to usable data\n     * @param {Object} data the api response data\n     */\n  }, {\n    key: \"createComment\",\n    /**\n     * API for creating a comment on a file\n     *\n     * @param {BoxItem} file - File object for which we are creating a comment\n     * @param {string} message - Comment message\n     * @param {string} taggedMessage - Comment message with @mentions\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    value: function createComment(_ref) {\n      var file = _ref.file,\n        message = _ref.message,\n        taggedMessage = _ref.taggedMessage,\n        successCallback = _ref.successCallback,\n        errorCallback = _ref.errorCallback;\n      this.errorCode = ERROR_CODE_CREATE_COMMENT;\n      var _file$id = file.id,\n        id = _file$id === void 0 ? '' : _file$id,\n        permissions = file.permissions;\n      try {\n        this.checkApiCallValidity(PERMISSION_CAN_COMMENT, permissions, id);\n      } catch (e) {\n        errorCallback(e, this.errorCode);\n        return;\n      }\n      var requestData = {\n        data: {\n          item: {\n            id: id,\n            type: 'file'\n          },\n          message: message,\n          tagged_message: taggedMessage\n        },\n        params: {\n          fields: COMMENTS_FIELDS_TO_FETCH.toString()\n        }\n      };\n      this.post({\n        id: id,\n        url: this.commentsUrl(),\n        data: requestData,\n        successCallback: successCallback,\n        errorCallback: errorCallback\n      });\n    }\n    /**\n     * API for updating a comment on a file\n     *\n     * @param {BoxItem} file - File object for which we are updating a comment\n     * @param {string} commentId - Comment to be edited\n     * @param {string} message - Comment message\n     * @param {BoxItemPermission} permissions - The known permissions of the comment we're updating\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n  }, {\n    key: \"updateComment\",\n    value: function updateComment(_ref2) {\n      var file = _ref2.file,\n        commentId = _ref2.commentId,\n        message = _ref2.message,\n        tagged_message = _ref2.tagged_message,\n        permissions = _ref2.permissions,\n        successCallback = _ref2.successCallback,\n        errorCallback = _ref2.errorCallback;\n      this.errorCode = ERROR_CODE_UPDATE_COMMENT;\n      var _file$id2 = file.id,\n        id = _file$id2 === void 0 ? '' : _file$id2;\n      try {\n        this.checkApiCallValidity(PERMISSION_CAN_EDIT, permissions, id);\n      } catch (e) {\n        errorCallback(e, this.errorCode);\n        return;\n      }\n      var requestData = {\n        data: {\n          message: message,\n          tagged_message: tagged_message\n        }\n      };\n      this.put({\n        id: id,\n        url: this.commentsUrl(commentId),\n        data: requestData,\n        successCallback: successCallback,\n        errorCallback: errorCallback\n      });\n    }\n    /**\n     * API for deleting a comment on a file\n     *\n     * @param {BoxItem} file - File object for which we are deleting a comment\n     * @param {string} commentId - Id of the comment we are deleting\n     * @param {BoxItemPermission} permissions - The known permissions of the comment we're deleting\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n  }, {\n    key: \"deleteComment\",\n    value: function deleteComment(_ref3) {\n      var file = _ref3.file,\n        commentId = _ref3.commentId,\n        permissions = _ref3.permissions,\n        successCallback = _ref3.successCallback,\n        errorCallback = _ref3.errorCallback;\n      this.errorCode = ERROR_CODE_DELETE_COMMENT;\n      var _file$id3 = file.id,\n        id = _file$id3 === void 0 ? '' : _file$id3;\n      try {\n        this.checkApiCallValidity(PERMISSION_CAN_DELETE, permissions, id);\n      } catch (e) {\n        errorCallback(e, this.errorCode);\n        return;\n      }\n      this.delete({\n        id: id,\n        url: this.commentsUrl(commentId),\n        successCallback: successCallback,\n        errorCallback: errorCallback\n      });\n    }\n    /**\n     * API for fetching comments on a file\n     *\n     * @param {string} fileId - the file id\n     * @param {BoxItemPermission} permissions - the permissions for the file\n     * @param {Function} successCallback - the success callback\n     * @param {Function} errorCallback - the error callback\n     * @param {array} fields - the fields to fetch\n     * @param {number} offset - the offset from the start to start fetching at\n     * @param {number} limit - the number of items to fetch\n     * @param {boolean} shouldFetchAll - true if should get all the pages before calling the sucessCallback\n     * @returns {void}\n     */\n  }, {\n    key: \"getComments\",\n    value: function getComments(fileId, permissions, successCallback, errorCallback) {\n      var fields = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : COMMENTS_FIELDS_TO_FETCH;\n      var offset = arguments.length > 5 ? arguments[5] : undefined;\n      var limit = arguments.length > 6 ? arguments[6] : undefined;\n      var shouldFetchAll = arguments.length > 7 ? arguments[7] : undefined;\n      this.errorCode = ERROR_CODE_FETCH_COMMENTS;\n      try {\n        this.checkApiCallValidity(PERMISSION_CAN_COMMENT, permissions, fileId);\n      } catch (e) {\n        errorCallback(e, this.errorCode);\n        return;\n      }\n      this.offsetGet(fileId, successCallback, errorCallback, offset, limit, fields, shouldFetchAll);\n    }\n  }]);\n  return Comments;\n}(OffsetBasedAPI);\nexport default Comments;","map":{"version":3,"sources":["../../src/api/Comments.js"],"names":["COMMENTS_FIELDS_TO_FETCH","OffsetBasedAPI","PERMISSION_CAN_COMMENT","PERMISSION_CAN_DELETE","PERMISSION_CAN_EDIT","ERROR_CODE_CREATE_COMMENT","ERROR_CODE_UPDATE_COMMENT","ERROR_CODE_DELETE_COMMENT","ERROR_CODE_FETCH_COMMENTS","Comments","id","Error","getBaseApiUrl","baseUrl","comment","tagged_message","message","data","isDestroyed","successCallback","entries","format","comments","map","file","taggedMessage","errorCallback","errorCode","permissions","checkApiCallValidity","e","requestData","item","type","params","fields","toString","post","url","commentsUrl","commentId","put","delete","fileId","offset","limit","shouldFetchAll","offsetGet"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAMA,SAASA,wBAAT,QAAyC,iBAAzC;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,SACIC,sBADJ,EAEIC,qBAFJ,EAGIC,mBAHJ,EAIIC,yBAJJ,EAKIC,yBALJ,EAMIC,yBANJ,EAOIC,yBAPJ,QAQO,cARP;IAYMC,Q;;;;;;;;;;;qEA2Ce,UAACQ,IAAD,EAAwB;MACrC,IAAI,KAAA,CAAKC,WAAL,CAAA,CAAA,IAAsB,OAAO,KAAA,CAAKC,eAAZ,KAAgC,UAA1D,EAAsE;QAClE;MACH,CAHoC,CAKrC;;MACA,IAAI,CAACF,IAAL,EAAW;QACP,KAAA,CAAKE,eAAL,CAAA,CAAA;QACA;MACH,CAToC,CAWrC;;MACA,IAAI,CAACF,IAAI,CAACG,OAAV,EAAmB;QACf,KAAA,CAAKD,eAAL,CAAqB,KAAA,CAAKE,MAAL,CAAYJ,IAAZ,CAArB,CAAA;QACA;MACH;MAED,IAAMK,QAAQ,GAAGL,IAAI,CAACG,OAALH,CAAaM,GAAbN,CAAiB,KAAA,CAAKI,MAAtBJ,CAAjB;MACA,KAAA,CAAKE,eAAL,CAAA,aAAA,CAAA,CAAA,CAAA,EAA0BF,IAA1B,EAAA;QAAgCG,OAAO,EAAEE;MAAzC,CAAA,CAAA,CAAA;IACH,C;;;;;IA7DD;;;;;;2BAMOZ,E,EAAqB;MACxB,IAAI,CAACA,EAAL,EAAS;QACL,MAAM,IAAIC,KAAJ,CAAU,kBAAV,CAAN;MACH;MAED,OAAA,EAAA,CAAA,MAAA,CAAU,IAAA,CAAKC,aAAL,CAAA,CAAV,EAAA,SAAA,CAAA,CAAA,MAAA,CAAwCF,EAAxC,EAAA,WAAA,CAAA;IACH;IAED;;;;;;;;gCAMYA,E,EAAqB;MAC7B,IAAMG,OAAO,GAAA,EAAA,CAAA,MAAA,CAAM,IAAA,CAAKD,aAAL,CAAA,CAAN,EAAA,WAAA,CAAb;MACA,OAAOF,EAAE,GAAA,EAAA,CAAA,MAAA,CAAMG,OAAN,EAAA,GAAA,CAAA,CAAA,MAAA,CAAiBH,EAAjB,CAAA,GAAwBG,OAAjC;IACH;IAED;;;;;;;;2BAMOC,O,EAA0B;MAC7B,OAAA,aAAA,CAAA,CAAA,CAAA,EACOA,OADP,EAAA;QAEIC,cAAc,EAAED,OAAO,CAACC,cAARD,KAA2B,EAA3BA,GAAgCA,OAAO,CAACC,cAAxCD,GAAyDA,OAAO,CAACE;MAFrF,CAAA,CAAA;IAIH;IAED;;;;;;IAyBA;;;;;;;;;;wCAsBS;MAAA,IAXLQ,IAWK,GAAA,IAAA,CAXLA,IAWK;QAVLR,OAUK,GAAA,IAAA,CAVLA,OAUK;QATLS,aASK,GAAA,IAAA,CATLA,aASK;QARLN,eAQK,GAAA,IAAA,CARLA,eAQK;QAPLO,aAOK,GAAA,IAAA,CAPLA,aAOK;MACL,IAAA,CAAKC,SAAL,GAAiBtB,yBAAjB;MADK,IAAA,QAAA,GAE4BmB,IAF5B,CAEGd,EAFH;QAEGA,EAFH,GAAA,QAAA,KAAA,KAAA,CAAA,GAEQ,EAFR,GAAA,QAAA;QAEYkB,WAFZ,GAE4BJ,IAF5B,CAEYI,WAFZ;MAIL,IAAI;QACA,IAAA,CAAKC,oBAAL,CAA0B3B,sBAA1B,EAAkD0B,WAAlD,EAA+DlB,EAA/D,CAAA;MACH,CAFD,CAEE,OAAOoB,CAAP,EAAU;QACRJ,aAAa,CAACI,CAAD,EAAI,IAAA,CAAKH,SAAT,CAAbD;QACA;MACH;MAED,IAAMK,WAAW,GAAG;QAChBd,IAAI,EAAE;UACFe,IAAI,EAAE;YACFtB,EAAE,EAAFA,EADE;YAEFuB,IAAI,EAAE;UAFJ,CADJ;UAKFjB,OAAO,EAAPA,OALE;UAMFD,cAAc,EAAEU;QANd,CADU;QAShBS,MAAM,EAAE;UACJC,MAAM,EAAEnC,wBAAwB,CAACoC,QAAzBpC,CAAAA;QADJ;MATQ,CAApB;MAcA,IAAA,CAAKqC,IAAL,CAAU;QACN3B,EAAE,EAAFA,EADM;QAEN4B,GAAG,EAAE,IAAA,CAAKC,WAAL,CAAA,CAFC;QAGNtB,IAAI,EAAEc,WAHA;QAINZ,eAAe,EAAfA,eAJM;QAKNO,aAAa,EAAbA;MALM,CAAV,CAAA;IAOH;IAED;;;;;;;;;;;;;yCA2BS;MAAA,IAfLF,IAeK,GAAA,KAAA,CAfLA,IAeK;QAdLgB,SAcK,GAAA,KAAA,CAdLA,SAcK;QAbLxB,OAaK,GAAA,KAAA,CAbLA,OAaK;QAZLD,cAYK,GAAA,KAAA,CAZLA,cAYK;QAXLa,WAWK,GAAA,KAAA,CAXLA,WAWK;QAVLT,eAUK,GAAA,KAAA,CAVLA,eAUK;QATLO,aASK,GAAA,KAAA,CATLA,aASK;MACL,IAAA,CAAKC,SAAL,GAAiBrB,yBAAjB;MADK,IAAA,SAAA,GAEekB,IAFf,CAEGd,EAFH;QAEGA,EAFH,GAAA,SAAA,KAAA,KAAA,CAAA,GAEQ,EAFR,GAAA,SAAA;MAIL,IAAI;QACA,IAAA,CAAKmB,oBAAL,CAA0BzB,mBAA1B,EAA+CwB,WAA/C,EAA4DlB,EAA5D,CAAA;MACH,CAFD,CAEE,OAAOoB,CAAP,EAAU;QACRJ,aAAa,CAACI,CAAD,EAAI,IAAA,CAAKH,SAAT,CAAbD;QACA;MACH;MAED,IAAMK,WAAW,GAAG;QAChBd,IAAI,EAAE;UAAED,OAAO,EAAPA,OAAF;UAAWD,cAAc,EAAdA;QAAX;MADU,CAApB;MAIA,IAAA,CAAK0B,GAAL,CAAS;QACL/B,EAAE,EAAFA,EADK;QAEL4B,GAAG,EAAE,IAAA,CAAKC,WAAL,CAAiBC,SAAjB,CAFA;QAGLvB,IAAI,EAAEc,WAHD;QAILZ,eAAe,EAAfA,eAJK;QAKLO,aAAa,EAAbA;MALK,CAAT,CAAA;IAOH;IAED;;;;;;;;;;;;yCAsBS;MAAA,IAXLF,IAWK,GAAA,KAAA,CAXLA,IAWK;QAVLgB,SAUK,GAAA,KAAA,CAVLA,SAUK;QATLZ,WASK,GAAA,KAAA,CATLA,WASK;QARLT,eAQK,GAAA,KAAA,CARLA,eAQK;QAPLO,aAOK,GAAA,KAAA,CAPLA,aAOK;MACL,IAAA,CAAKC,SAAL,GAAiBpB,yBAAjB;MADK,IAAA,SAAA,GAEeiB,IAFf,CAEGd,EAFH;QAEGA,EAFH,GAAA,SAAA,KAAA,KAAA,CAAA,GAEQ,EAFR,GAAA,SAAA;MAIL,IAAI;QACA,IAAA,CAAKmB,oBAAL,CAA0B1B,qBAA1B,EAAiDyB,WAAjD,EAA8DlB,EAA9D,CAAA;MACH,CAFD,CAEE,OAAOoB,CAAP,EAAU;QACRJ,aAAa,CAACI,CAAD,EAAI,IAAA,CAAKH,SAAT,CAAbD;QACA;MACH;MAED,IAAA,CAAKgB,MAAL,CAAY;QACRhC,EAAE,EAAFA,EADQ;QAER4B,GAAG,EAAE,IAAA,CAAKC,WAAL,CAAiBC,SAAjB,CAFG;QAGRrB,eAAe,EAAfA,eAHQ;QAIRO,aAAa,EAAbA;MAJQ,CAAZ,CAAA;IAMH;IAED;;;;;;;;;;;;;;;gCAcIiB,M,EACAf,W,EACAT,e,EACAO,a,EAKI;MAAA,IAJJS,MAII,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAJoBnC,wBAIpB;MAAA,IAHJ4C,MAGI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;MAAA,IAFJC,KAEI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;MAAA,IADJC,cACI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;MACJ,IAAA,CAAKnB,SAAL,GAAiBnB,yBAAjB;MACA,IAAI;QACA,IAAA,CAAKqB,oBAAL,CAA0B3B,sBAA1B,EAAkD0B,WAAlD,EAA+De,MAA/D,CAAA;MACH,CAFD,CAEE,OAAOb,CAAP,EAAU;QACRJ,aAAa,CAACI,CAAD,EAAI,IAAA,CAAKH,SAAT,CAAbD;QACA;MACH;MAED,IAAA,CAAKqB,SAAL,CAAeJ,MAAf,EAAuBxB,eAAvB,EAAwCO,aAAxC,EAAuDkB,MAAvD,EAA+DC,KAA/D,EAAsEV,MAAtE,EAA8EW,cAA9E,CAAA;IACH;;;EApPkB7C,c;AAuPvB,eAAeQ,QAAf","sourcesContent":["/**\n * @flow\n * @file Helper for the box comments API\n * @author Box\n */\n\nimport { COMMENTS_FIELDS_TO_FETCH } from '../utils/fields';\nimport OffsetBasedAPI from './OffsetBasedAPI';\nimport {\n    PERMISSION_CAN_COMMENT,\n    PERMISSION_CAN_DELETE,\n    PERMISSION_CAN_EDIT,\n    ERROR_CODE_CREATE_COMMENT,\n    ERROR_CODE_UPDATE_COMMENT,\n    ERROR_CODE_DELETE_COMMENT,\n    ERROR_CODE_FETCH_COMMENTS,\n} from '../constants';\nimport type { ElementsXhrError, ElementsErrorCallback } from '../common/types/api';\nimport type { BoxItem, BoxItemPermission } from '../common/types/core';\n\nclass Comments extends OffsetBasedAPI {\n    /**\n     * API URL for comments on a file\n     *\n     * @param {string} id - A box file id\n     * @return {string} base url for files\n     */\n    getUrl(id?: string): string {\n        if (!id) {\n            throw new Error('Missing file id!');\n        }\n\n        return `${this.getBaseApiUrl()}/files/${id}/comments`;\n    }\n\n    /**\n     * API URL for comments endpoint\n     *\n     * @param {string} [id] - A box comment id\n     * @return {string} base url for comments\n     */\n    commentsUrl(id?: string): string {\n        const baseUrl = `${this.getBaseApiUrl()}/comments`;\n        return id ? `${baseUrl}/${id}` : baseUrl;\n    }\n\n    /**\n     * Formats comment data for use in components.\n     *\n     * @param {string} [id] - An individual comment entry from the API\n     * @return {Task} A task\n     */\n    format(comment: Object): Comment {\n        return {\n            ...comment,\n            tagged_message: comment.tagged_message !== '' ? comment.tagged_message : comment.message,\n        };\n    }\n\n    /**\n     * Formats the comments api response to usable data\n     * @param {Object} data the api response data\n     */\n    successHandler = (data: Object): void => {\n        if (this.isDestroyed() || typeof this.successCallback !== 'function') {\n            return;\n        }\n\n        // There is no response data when deleting a comment\n        if (!data) {\n            this.successCallback();\n            return;\n        }\n\n        // We don't have entries when updating/creating a comment\n        if (!data.entries) {\n            this.successCallback(this.format(data));\n            return;\n        }\n\n        const comments = data.entries.map(this.format);\n        this.successCallback({ ...data, entries: comments });\n    };\n\n    /**\n     * API for creating a comment on a file\n     *\n     * @param {BoxItem} file - File object for which we are creating a comment\n     * @param {string} message - Comment message\n     * @param {string} taggedMessage - Comment message with @mentions\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    createComment({\n        file,\n        message,\n        taggedMessage,\n        successCallback,\n        errorCallback,\n    }: {\n        errorCallback: ElementsErrorCallback,\n        file: BoxItem,\n        message?: string,\n        successCallback: Function,\n        taggedMessage?: string,\n    }): void {\n        this.errorCode = ERROR_CODE_CREATE_COMMENT;\n        const { id = '', permissions } = file;\n\n        try {\n            this.checkApiCallValidity(PERMISSION_CAN_COMMENT, permissions, id);\n        } catch (e) {\n            errorCallback(e, this.errorCode);\n            return;\n        }\n\n        const requestData = {\n            data: {\n                item: {\n                    id,\n                    type: 'file',\n                },\n                message,\n                tagged_message: taggedMessage,\n            },\n            params: {\n                fields: COMMENTS_FIELDS_TO_FETCH.toString(),\n            },\n        };\n\n        this.post({\n            id,\n            url: this.commentsUrl(),\n            data: requestData,\n            successCallback,\n            errorCallback,\n        });\n    }\n\n    /**\n     * API for updating a comment on a file\n     *\n     * @param {BoxItem} file - File object for which we are updating a comment\n     * @param {string} commentId - Comment to be edited\n     * @param {string} message - Comment message\n     * @param {BoxItemPermission} permissions - The known permissions of the comment we're updating\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    updateComment({\n        file,\n        commentId,\n        message,\n        tagged_message,\n        permissions,\n        successCallback,\n        errorCallback,\n    }: {\n        commentId: string,\n        errorCallback: ElementsErrorCallback,\n        file: BoxItem,\n        message: string,\n        permissions: BoxItemPermission,\n        successCallback: Function,\n        tagged_message?: string,\n    }): void {\n        this.errorCode = ERROR_CODE_UPDATE_COMMENT;\n        const { id = '' } = file;\n\n        try {\n            this.checkApiCallValidity(PERMISSION_CAN_EDIT, permissions, id);\n        } catch (e) {\n            errorCallback(e, this.errorCode);\n            return;\n        }\n\n        const requestData = {\n            data: { message, tagged_message },\n        };\n\n        this.put({\n            id,\n            url: this.commentsUrl(commentId),\n            data: requestData,\n            successCallback,\n            errorCallback,\n        });\n    }\n\n    /**\n     * API for deleting a comment on a file\n     *\n     * @param {BoxItem} file - File object for which we are deleting a comment\n     * @param {string} commentId - Id of the comment we are deleting\n     * @param {BoxItemPermission} permissions - The known permissions of the comment we're deleting\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @return {void}\n     */\n    deleteComment({\n        file,\n        commentId,\n        permissions,\n        successCallback,\n        errorCallback,\n    }: {\n        commentId: string,\n        errorCallback: ElementsErrorCallback,\n        file: BoxItem,\n        permissions: BoxItemPermission,\n        successCallback: Function,\n    }): void {\n        this.errorCode = ERROR_CODE_DELETE_COMMENT;\n        const { id = '' } = file;\n\n        try {\n            this.checkApiCallValidity(PERMISSION_CAN_DELETE, permissions, id);\n        } catch (e) {\n            errorCallback(e, this.errorCode);\n            return;\n        }\n\n        this.delete({\n            id,\n            url: this.commentsUrl(commentId),\n            successCallback,\n            errorCallback,\n        });\n    }\n\n    /**\n     * API for fetching comments on a file\n     *\n     * @param {string} fileId - the file id\n     * @param {BoxItemPermission} permissions - the permissions for the file\n     * @param {Function} successCallback - the success callback\n     * @param {Function} errorCallback - the error callback\n     * @param {array} fields - the fields to fetch\n     * @param {number} offset - the offset from the start to start fetching at\n     * @param {number} limit - the number of items to fetch\n     * @param {boolean} shouldFetchAll - true if should get all the pages before calling the sucessCallback\n     * @returns {void}\n     */\n    getComments(\n        fileId: string,\n        permissions: BoxItemPermission,\n        successCallback: Function,\n        errorCallback: (e: ElementsXhrError, code: string) => void,\n        fields: Array<string> = COMMENTS_FIELDS_TO_FETCH,\n        offset?: number,\n        limit?: number,\n        shouldFetchAll?: boolean,\n    ): void {\n        this.errorCode = ERROR_CODE_FETCH_COMMENTS;\n        try {\n            this.checkApiCallValidity(PERMISSION_CAN_COMMENT, permissions, fileId);\n        } catch (e) {\n            errorCallback(e, this.errorCode);\n            return;\n        }\n\n        this.offsetGet(fileId, successCallback, errorCallback, offset, limit, fields, shouldFetchAll);\n    }\n}\n\nexport default Comments;\n"]},"metadata":{},"sourceType":"module"}