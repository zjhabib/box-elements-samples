{"ast":null,"code":"import _regeneratorRuntime from \"/Users/zhabib/Documents/GitHub/box-elements-samples/demo-box-metadata-views/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n  return _assertThisInitialized(self);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\n/**\n * \n * @file Helper for the box Users API\n * @author Box\n */\nimport queryString from 'query-string';\nimport TokenService from '../utils/TokenService';\nimport { getTypedFileId } from '../utils/file';\nimport Base from './Base';\nimport { ERROR_CODE_FETCH_CURRENT_USER } from '../constants';\nvar Users = /*#__PURE__*/\nfunction (_Base) {\n  _inherits(Users, _Base);\n  function Users() {\n    _classCallCheck(this, Users);\n    return _possibleConstructorReturn(this, _getPrototypeOf(Users).apply(this, arguments));\n  }\n  _createClass(Users, [{\n    key: \"getUrl\",\n    /**\n     * API URL for Users\n     *\n     * @returns {string} base url for users\n     */\n    value: function getUrl() {\n      return \"\".concat(this.getBaseApiUrl(), \"/users/me\");\n    }\n    /**\n     * API URL for Users avatar\n     *\n     * @param {string} id - A box user id.\n     * @returns {string} base url for users\n     */\n  }, {\n    key: \"getAvatarUrl\",\n    value: function getAvatarUrl(id) {\n      if (!id) {\n        throw new Error('Missing user id');\n      }\n      return \"\".concat(this.getBaseApiUrl(), \"/users/\").concat(id, \"/avatar\");\n    }\n    /**\n     * Gets authenticated user avatar URL from cache or by getting new token\n     *\n     * @param {string} userId the user id\n     * @param {string} fileId the file id\n     * @returns {string} the user avatar URL string for a given user with access token attached\n     */\n  }, {\n    key: \"getAvatarUrlWithAccessToken\",\n    value: function () {\n      var _getAvatarUrlWithAccessToken = _asyncToGenerator( /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(userId, fileId) {\n        var cache, accessToken, options, urlParams, url;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (userId) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt(\"return\", null);\n              case 2:\n                // treat cache as key-value pairs of { userId: avatarUrl }\n                cache = this.getCache();\n                if (!cache.has(userId)) {\n                  _context.next = 5;\n                  break;\n                }\n                return _context.abrupt(\"return\", cache.get(userId));\n              case 5:\n                _context.next = 7;\n                return TokenService.getReadToken(getTypedFileId(fileId), this.options.token);\n              case 7:\n                accessToken = _context.sent;\n                if (!(typeof accessToken === 'string')) {\n                  _context.next = 14;\n                  break;\n                }\n                options = {\n                  access_token: accessToken,\n                  pic_type: 'large'\n                };\n                urlParams = queryString.stringify(options);\n                url = \"\".concat(this.getAvatarUrl(userId), \"?\").concat(urlParams);\n                cache.set(userId, url);\n                return _context.abrupt(\"return\", url);\n              case 14:\n                return _context.abrupt(\"return\", null);\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n      function getAvatarUrlWithAccessToken(_x, _x2) {\n        return _getAvatarUrlWithAccessToken.apply(this, arguments);\n      }\n      return getAvatarUrlWithAccessToken;\n    }()\n    /**\n     * API for fetching a user\n     *\n     * @param {string} id - a Box item id\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param {Object} requestData - additional request data\n     * @returns {Promise<void>}\n     */\n  }, {\n    key: \"getUser\",\n    value: function getUser(id, successCallback, errorCallback) {\n      var requestData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.errorCode = ERROR_CODE_FETCH_CURRENT_USER;\n      this.get({\n        id: id,\n        successCallback: successCallback,\n        errorCallback: errorCallback,\n        requestData: requestData\n      });\n    }\n  }]);\n  return Users;\n}(Base);\nexport default Users;","map":{"version":3,"sources":["../../src/api/Users.js"],"names":["queryString","TokenService","getTypedFileId","Base","ERROR_CODE_FETCH_CURRENT_USER","Users","getBaseApiUrl","id","Error","userId","fileId","cache","getCache","has","get","accessToken","getReadToken","options","token","access_token","pic_type","urlParams","stringify","url","getAvatarUrl","set","successCallback","errorCallback","requestData","errorCode"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;AAMA,OAAOA,WAAP,MAAwB,cAAxB;AACA,OAAOC,YAAP,MAAyB,uBAAzB;AACA,SAASC,cAAT,QAA+B,eAA/B;AACA,OAAOC,IAAP,MAAiB,QAAjB;AACA,SAASC,6BAAT,QAA8C,cAA9C;IAIMC,K;;;;;;;;;IACF;;;;;6BAKiB;MACb,OAAA,EAAA,CAAA,MAAA,CAAU,IAAA,CAAKC,aAAL,CAAA,CAAV,EAAA,WAAA,CAAA;IACH;IAED;;;;;;;;iCAMaC,E,EAAoB;MAC7B,IAAI,CAACA,EAAL,EAAS;QACL,MAAM,IAAIC,KAAJ,CAAU,iBAAV,CAAN;MACH;MAED,OAAA,EAAA,CAAA,MAAA,CAAU,IAAA,CAAKF,aAAL,CAAA,CAAV,EAAA,SAAA,CAAA,CAAA,MAAA,CAAwCC,EAAxC,EAAA,SAAA,CAAA;IACH;IAED;;;;;;;;;;;gDAOkCE,M,EAAkBC,M;;;;;;oBAC3CD,M;;;;iDACM,I;;gBAGX;gBACME,K,GAAQ,IAAA,CAAKC,QAAL,CAAA,C;qBACVD,KAAK,CAACE,GAANF,CAAUF,MAAVE,C;;;;iDACOA,KAAK,CAACG,GAANH,CAAUF,MAAVE,C;;;uBAG6BV,YAAY,CAACe,YAAbf,CAA0BC,cAAc,CAACQ,MAAD,CAAxCT,EAAkD,IAAA,CAAKgB,OAAL,CAAaC,KAA/DjB,C;;gBAAlCc,W;sBAEF,OAAOA,WAAP,KAAuB,Q;;;;gBACjBE,O,GAAU;kBACZE,YAAY,EAAEJ,WADF;kBAEZK,QAAQ,EAAE;gBAFE,C;gBAIVC,S,GAAYrB,WAAW,CAACsB,SAAZtB,CAAsBiB,OAAtBjB,C;gBACZuB,G,aAAS,IAAA,CAAKC,YAAL,CAAkBf,MAAlB,C,cAA6BY,S;gBAC5CV,KAAK,CAACc,GAANd,CAAUF,MAAVE,EAAkBY,GAAlBZ,CAAAA;iDACOY,G;;iDAGJ,I;;;;;;;;;;;;;IAGX;;;;;;;;;;;4BAUIhB,E,EACAmB,e,EACAC,a,EAEI;MAAA,IADJC,WACI,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADkB,CAAA,CAClB;MACJ,IAAA,CAAKC,SAAL,GAAiBzB,6BAAjB;MACA,IAAA,CAAKU,GAAL,CAAS;QACLP,EAAE,EAAFA,EADK;QAELmB,eAAe,EAAfA,eAFK;QAGLC,aAAa,EAAbA,aAHK;QAILC,WAAW,EAAXA;MAJK,CAAT,CAAA;IAMH;;;EAhFezB,I;AAmFpB,eAAeE,KAAf","sourcesContent":["/**\n * @flow\n * @file Helper for the box Users API\n * @author Box\n */\n\nimport queryString from 'query-string';\nimport TokenService from '../utils/TokenService';\nimport { getTypedFileId } from '../utils/file';\nimport Base from './Base';\nimport { ERROR_CODE_FETCH_CURRENT_USER } from '../constants';\nimport type { ElementsErrorCallback } from '../common/types/api';\nimport type { TokenLiteral } from '../common/types/core';\n\nclass Users extends Base {\n    /**\n     * API URL for Users\n     *\n     * @returns {string} base url for users\n     */\n    getUrl(): string {\n        return `${this.getBaseApiUrl()}/users/me`;\n    }\n\n    /**\n     * API URL for Users avatar\n     *\n     * @param {string} id - A box user id.\n     * @returns {string} base url for users\n     */\n    getAvatarUrl(id: string): string {\n        if (!id) {\n            throw new Error('Missing user id');\n        }\n\n        return `${this.getBaseApiUrl()}/users/${id}/avatar`;\n    }\n\n    /**\n     * Gets authenticated user avatar URL from cache or by getting new token\n     *\n     * @param {string} userId the user id\n     * @param {string} fileId the file id\n     * @returns {string} the user avatar URL string for a given user with access token attached\n     */\n    async getAvatarUrlWithAccessToken(userId?: ?string, fileId: string): Promise<?string> {\n        if (!userId) {\n            return null;\n        }\n\n        // treat cache as key-value pairs of { userId: avatarUrl }\n        const cache = this.getCache();\n        if (cache.has(userId)) {\n            return cache.get(userId);\n        }\n\n        const accessToken: TokenLiteral = await TokenService.getReadToken(getTypedFileId(fileId), this.options.token);\n\n        if (typeof accessToken === 'string') {\n            const options = {\n                access_token: accessToken,\n                pic_type: 'large',\n            };\n            const urlParams = queryString.stringify(options);\n            const url = `${this.getAvatarUrl(userId)}?${urlParams}`;\n            cache.set(userId, url);\n            return url;\n        }\n\n        return null;\n    }\n\n    /**\n     * API for fetching a user\n     *\n     * @param {string} id - a Box item id\n     * @param {Function} successCallback - Success callback\n     * @param {Function} errorCallback - Error callback\n     * @param {Object} requestData - additional request data\n     * @returns {Promise<void>}\n     */\n    getUser(\n        id: string,\n        successCallback: Function,\n        errorCallback: ElementsErrorCallback,\n        requestData: Object = {},\n    ): void {\n        this.errorCode = ERROR_CODE_FETCH_CURRENT_USER;\n        this.get({\n            id,\n            successCallback,\n            errorCallback,\n            requestData,\n        });\n    }\n}\n\nexport default Users;\n"]},"metadata":{},"sourceType":"module"}